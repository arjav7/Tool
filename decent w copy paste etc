"use client"

import { useEffect, useRef, useState, useCallback } from "react"
import { addPropertyControls, ControlType } from "framer"
import { motion } from "framer-motion"

interface Element {
    id: string
    x: number
    y: number
    radius: number // For circles; for text/rectangles, it's an effective radius for physics/placement
    color: string
    state: "default" | "selected" | "moveable"
    type: "circle" | "text" | "rectangle" // Added rectangle
    text?: string
    fontSize?: number
    width?: number // For rectangles
    height?: number // For rectangles
    // Physics properties
    vx: number
    vy: number
    mass: number
}

// Helper for deep cloning elements, crucial for history and clipboard
const cloneElements = (elements: Element[]): Element[] => {
    return elements.map((el) => ({ ...el }))
}

/**
 * @framerDisableUnlink
 * @framerSupportedLayoutWidth any
 * @framerSupportedLayoutHeight any
 * @framerIntrinsicWidth 800
 * @framerIntrinsicHeight 600
 */
export default function InteractiveCanvas(props) {
    const {
        backgroundColor = "#f0f0f0",
        physicsBackgroundColor = "#e8f4f8",
        circleColor = "#3b82f6",
        textColor = "#2563eb",
        rectangleColor = "#10b981", // Added default rectangle color
        selectedColor = "#ff00ff",
        moveableColor = "#ff0000",
        strokeColor = "#000000",
        strokeWidth = 2,
        selectedStrokeWidth = 3,
        moveableStrokeWidth = 4,
        overlapColor2 = "#ff6b35",
        overlapColor3 = "#ff3535",
        overlapColor4 = "#ff0000",
        minRadius = 20, // Used for min size of circles and effective min size for rects
        maxRadius = 100, // Used for max size of circles and effective max size for rects
        initialRadius = 40,
        fontSize = 32,
        movementSpeed = 15,
        gravity = 0.5,
        friction = 0.98,
        bounciness = 0.7,
        showInstructions = true, // Prop for instructions visibility
        showScreenshotButton = true, // Prop for screenshot button
        screenshotIconSrc = "/placeholder.svg?width=24&height=24", // Default placeholder
        style,
    } = props

    const containerRef = useRef<HTMLDivElement>(null)
    const canvasRef = useRef<HTMLCanvasElement>(null)
    const animationFrameRef = useRef<number>()
    const mouseInteractionTimeoutRef = useRef<NodeJS.Timeout>()

    const [elements, setElements] = useState<Element[]>([])
    const [selectedElementIndex, setSelectedElementIndex] = useState<number>(-1) // Primary selected (e.g., for single ops)
    const [multiSelectedElementIndices, setMultiSelectedElementIndices] =
        useState<number[]>([])
    const [moveableElementIndex, setMoveableElementIndex] = useState<number>(-1) // Element being actively moved/edited
    const [hoverElementId, setHoverElementId] = useState<string | null>(null)
    const [keyboardMode, setKeyboardMode] = useState(false)
    const [dragOffset, setDragOffset] = useState<{ x: number; y: number }>({
        x: 0,
        y: 0,
    })
    const [physicsActive, setPhysicsActive] = useState(false)
    const [isGravityPaused, setIsGravityPaused] = useState(false) // For spacebar pause
    const [isCreatingElement, setIsCreatingElement] = useState(false)
    const [creationStart, setCreationStart] = useState<{
        x: number
        y: number
    } | null>(null)
    const creatingElementId = useRef<string | null>(null)
    const [gravityDirection, setGravityDirection] = useState<
        "down" | "up" | "left" | "right"
    >("down")

    const [isPinching, setIsPinching] = useState(false)
    const [pinchStartDistance, setPinchStartDistance] = useState(0)
    const [pinchStartRadius, setPinchStartRadius] = useState(0)
    const [pinchElementIndex, setPinchElementIndex] = useState(-1)

    const [isClearing, setIsClearing] = useState(false)
    const [wasPhysicsActiveBeforeClearing, setWasPhysicsActiveBeforeClearing] =
        useState(false)
    const [lastUsedRadius, setLastUsedRadius] = useState(initialRadius)

    // History for Undo/Redo
    const [history, setHistory] = useState<Element[][]>([[]])
    const [historyIndex, setHistoryIndex] = useState<number>(0)

    // Clipboard for Copy/Paste
    const [clipboard, setClipboard] = useState<Element[] | null>(null)

    const isTypingIntoTextElement = useRef(false)

    // Function to save current state to history
    const saveHistory = useCallback(() => {
        // console.log("Saving history. Current elements:", elements);
        const newHistory = history.slice(0, historyIndex + 1)
        newHistory.push(cloneElements(elements)) // Store a clone
        setHistory(newHistory)
        setHistoryIndex(newHistory.length - 1)
    }, [elements, history, historyIndex])

    // Generate unique ID for elements
    const generateId = () => Math.random().toString(36).substr(2, 9)

    // Calculate distance between two points
    const distance = (x1: number, y1: number, x2: number, y2: number) => {
        return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
    }

    // Calculate distance between two touch points
    const getTouchDistance = (touch1: Touch, touch2: Touch) => {
        const dx = touch2.clientX - touch1.clientX
        const dy = touch2.clientY - touch1.clientY
        return Math.sqrt(dx * dx + dy * dy)
    }

    // Get center point between two touches
    const getTouchCenter = (touch1: Touch, touch2: Touch) => {
        const rect = canvasRef.current?.getBoundingClientRect()
        if (!rect) return { x: 0, y: 0 }

        return {
            x: (touch1.clientX + touch2.clientX) / 2 - rect.left,
            y: (touch1.clientY + touch2.clientY) / 2 - rect.top,
        }
    }

    // Get text dimensions
    const getTextDimensions = useCallback(
        (text: string, currentFontSize: number) => {
            const canvas = canvasRef.current
            if (!canvas) return { width: 0, height: 0 }

            const ctx = canvas.getContext("2d")
            if (!ctx) return { width: 0, height: 0 }

            ctx.font = `${currentFontSize}px Arial` // Use currentFontSize passed
            const metrics = ctx.measureText(text)
            return {
                width: metrics.width,
                height: currentFontSize, // Use currentFontSize passed
            }
        },
        []
    )

    // Calculate center of mass for all elements
    const calculateCenterOfMass = useCallback(() => {
        if (elements.length === 0) {
            const canvas = canvasRef.current
            if (!canvas) return { x: 400, y: 300 }
            const rect = canvas.getBoundingClientRect()
            return { x: rect.width / 2, y: rect.height / 2 }
        }

        let totalMass = 0
        let weightedX = 0
        let weightedY = 0

        elements.forEach((element) => {
            const mass = element.mass || element.radius / 10
            totalMass += mass
            weightedX += element.x * mass
            weightedY += element.y * mass
        })

        return {
            x: weightedX / totalMass,
            y: weightedY / totalMass,
        }
    }, [elements])

    // Check if two circles overlap
    const circlesOverlap = useCallback((circle1: Element, circle2: Element) => {
        if (circle1.type !== "circle" || circle2.type !== "circle") return false
        const dist = distance(circle1.x, circle1.y, circle2.x, circle2.y)
        return dist < circle1.radius + circle2.radius
    }, [])

    // Basic AABB overlap check for rectangles
    const rectanglesOverlap = useCallback((rect1: Element, rect2: Element) => {
        if (
            rect1.type !== "rectangle" ||
            rect2.type !== "rectangle" ||
            !rect1.width ||
            !rect1.height ||
            !rect2.width ||
            !rect2.height
        )
            return false
        return (
            rect1.x - rect1.width / 2 < rect2.x + rect2.width / 2 &&
            rect1.x + rect1.width / 2 > rect2.x - rect2.width / 2 &&
            rect1.y - rect1.height / 2 < rect2.y + rect2.height / 2 &&
            rect1.y + rect1.height / 2 > rect2.y - rect2.height / 2
        )
    }, [])

    // Circle-Rectangle overlap (simplified AABB for rectangle for now)
    const circleRectangleOverlap = useCallback(
        (circle: Element, rect: Element) => {
            if (
                circle.type !== "circle" ||
                rect.type !== "rectangle" ||
                !rect.width ||
                !rect.height
            )
                return false
            const circleDistanceX = Math.abs(circle.x - rect.x)
            const circleDistanceY = Math.abs(circle.y - rect.y)

            if (circleDistanceX > rect.width / 2 + circle.radius) return false
            if (circleDistanceY > rect.height / 2 + circle.radius) return false

            if (circleDistanceX <= rect.width / 2) return true
            if (circleDistanceY <= rect.height / 2) return true

            const cornerDistanceSq =
                (circleDistanceX - rect.width / 2) ** 2 +
                (circleDistanceY - rect.height / 2) ** 2
            return cornerDistanceSq <= circle.radius ** 2
        },
        []
    )

    // Get overlap color based on count
    const getOverlapColor = useCallback(
        (overlapCount: number) => {
            if (overlapCount === 1) return overlapColor2
            if (overlapCount === 2) return overlapColor3
            return overlapColor4 // 3 or more overlaps
        },
        [overlapColor2, overlapColor3, overlapColor4]
    )

    const countCharacterOverlaps = useCallback(
        (
            charX: number,
            charY: number,
            charWidth: number,
            charHeight: number,
            allElements: Element[],
            excludeId: string
        ): number => {
            let overlapCount = 0
            allElements.forEach((otherElement) => {
                if (otherElement.id === excludeId) return

                if (otherElement.type === "circle") {
                    const closestX = Math.max(
                        charX - charWidth / 2,
                        Math.min(otherElement.x, charX + charWidth / 2)
                    )
                    const closestY = Math.max(
                        charY - charHeight / 2,
                        Math.min(otherElement.y, charY + charHeight / 2)
                    )
                    const distanceToRect = distance(
                        otherElement.x,
                        otherElement.y,
                        closestX,
                        closestY
                    )
                    if (distanceToRect < otherElement.radius) {
                        overlapCount++
                    }
                } else if (
                    otherElement.type === "rectangle" &&
                    otherElement.width &&
                    otherElement.height
                ) {
                    // AABB check for char vs rectangle
                    const rectLeft = otherElement.x - otherElement.width / 2
                    const rectRight = otherElement.x + otherElement.width / 2
                    const rectTop = otherElement.y - otherElement.height / 2
                    const rectBottom = otherElement.y + otherElement.height / 2

                    const charRectLeft = charX - charWidth / 2
                    const charRectRight = charX + charWidth / 2
                    const charRectTop = charY - charHeight / 2
                    const charRectBottom = charY + charHeight / 2

                    if (
                        !(
                            charRectRight < rectLeft ||
                            rectRight < charRectLeft ||
                            charRectBottom < rectTop ||
                            rectBottom < charRectTop
                        )
                    ) {
                        overlapCount++
                    }
                } else if (otherElement.type === "text" && otherElement.text) {
                    const otherTextDims = getTextDimensions(
                        otherElement.text,
                        otherElement.fontSize || fontSize
                    )
                    const otherRect = {
                        left: otherElement.x - otherTextDims.width / 2,
                        right: otherElement.x + otherTextDims.width / 2,
                        top: otherElement.y - otherTextDims.height / 2,
                        bottom: otherElement.y + otherTextDims.height / 2,
                    }

                    const charRect = {
                        left: charX - charWidth / 2,
                        right: charX + charWidth / 2,
                        top: charY - charHeight / 2,
                        bottom: charY + charHeight / 2,
                    }

                    if (
                        !(
                            charRect.right < otherRect.left ||
                            otherRect.right < charRect.left ||
                            charRect.bottom < otherRect.top ||
                            otherRect.bottom < charRect.top
                        )
                    ) {
                        overlapCount++
                    }
                }
            })
            return overlapCount
        },
        [getTextDimensions, fontSize]
    )

    // Find element at position
    const findElementAt = useCallback(
        (x: number, y: number): { element: Element; index: number } | null => {
            for (let i = elements.length - 1; i >= 0; i--) {
                const element = elements[i]

                if (element.type === "circle") {
                    if (
                        distance(x, y, element.x, element.y) <= element.radius
                    ) {
                        return { element, index: i }
                    }
                } else if (
                    element.type === "rectangle" &&
                    element.width &&
                    element.height
                ) {
                    if (
                        x >= element.x - element.width / 2 &&
                        x <= element.x + element.width / 2 &&
                        y >= element.y - element.height / 2 &&
                        y <= element.y + element.height / 2
                    ) {
                        return { element, index: i }
                    }
                } else if (element.type === "text" && element.text) {
                    const dims = getTextDimensions(
                        element.text,
                        element.fontSize || fontSize
                    )
                    const halfWidth = dims.width / 2
                    const halfHeight = dims.height / 2

                    if (
                        x >= element.x - halfWidth &&
                        x <= element.x + halfWidth &&
                        y >= element.y - halfHeight &&
                        y <= element.y + halfHeight
                    ) {
                        return { element, index: i }
                    }
                }
            }
            return null
        },
        [elements, getTextDimensions, fontSize, distance]
    )

    const findMostEmptyArea = useCallback(
        (newElementSize: number = initialRadius) => {
            // newElementSize can be radius or effective size for rect
            const canvas = canvasRef.current
            if (!canvas) return { x: 400, y: 300 }

            const rect = canvas.getBoundingClientRect()
            const canvasCenter = { x: rect.width / 2, y: rect.height / 2 }
            const currentCenterOfMass = calculateCenterOfMass()

            const baseGridSize = Math.max(30, newElementSize * 1.2)
            const gridSize =
                elements.length > 20 ? baseGridSize * 0.7 : baseGridSize

            const logicalWidth = rect.width
            const logicalHeight = rect.height
            const cols = Math.floor(logicalWidth / gridSize)
            const rows = Math.floor(logicalHeight / gridSize)

            let bestScore = Number.POSITIVE_INFINITY
            let bestX = canvasCenter.x
            let bestY = canvasCenter.y

            const searchPasses = elements.length > 15 ? 2 : 1

            for (let pass = 0; pass < searchPasses; pass++) {
                const margin =
                    pass === 0 ? newElementSize + 15 : newElementSize + 5

                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const centerX = col * gridSize + gridSize / 2
                        const centerY = row * gridSize + gridSize / 2

                        if (
                            centerX < margin ||
                            centerX > logicalWidth - margin ||
                            centerY < margin ||
                            centerY > logicalHeight - margin
                        ) {
                            continue
                        }

                        let overlapPenalty = 0
                        let minDistanceToAnyElement = Number.POSITIVE_INFINITY

                        elements.forEach((element) => {
                            const dist = distance(
                                centerX,
                                centerY,
                                element.x,
                                element.y
                            )
                            minDistanceToAnyElement = Math.min(
                                minDistanceToAnyElement,
                                dist
                            )

                            // Use element.radius as a general size for penalty calculation
                            const effectiveRadius =
                                element.type === "rectangle"
                                    ? Math.min(
                                          element.width || 0,
                                          element.height || 0
                                      ) / 2
                                    : element.radius
                            const minAllowedDist =
                                effectiveRadius +
                                newElementSize +
                                (pass === 0 ? 20 : 10)
                            if (dist < minAllowedDist) {
                                overlapPenalty +=
                                    Math.pow(minAllowedDist - dist, 2) *
                                    (pass === 0 ? 100 : 50)
                            }
                        })

                        if (pass === 0 && overlapPenalty > 0) {
                            continue
                        }

                        const newMass = newElementSize / 10
                        const totalMass =
                            elements.reduce(
                                (sum, el) => sum + (el.mass || el.radius / 10),
                                0
                            ) + newMass

                        let balanceBonus = 0
                        if (totalMass > 0) {
                            const currentTotalMass = totalMass - newMass
                            const newCenterOfMass = {
                                x:
                                    currentTotalMass > 0
                                        ? (currentCenterOfMass.x *
                                              currentTotalMass +
                                              centerX * newMass) /
                                          totalMass
                                        : centerX,
                                y:
                                    currentTotalMass > 0
                                        ? (currentCenterOfMass.y *
                                              currentTotalMass +
                                              centerY * newMass) /
                                          totalMass
                                        : centerY,
                            }

                            const currentDistanceFromCenter = distance(
                                currentCenterOfMass.x,
                                currentCenterOfMass.y,
                                canvasCenter.x,
                                canvasCenter.y
                            )
                            const newDistanceFromCenter = distance(
                                newCenterOfMass.x,
                                newCenterOfMass.y,
                                canvasCenter.x,
                                canvasCenter.y
                            )
                            balanceBonus = Math.max(
                                0,
                                (currentDistanceFromCenter -
                                    newDistanceFromCenter) *
                                    2
                            )
                        }

                        const spreadBonus = Math.min(
                            minDistanceToAnyElement * 0.1,
                            50
                        )
                        const totalScore =
                            overlapPenalty -
                            balanceBonus -
                            spreadBonus +
                            Math.random() * 5

                        if (totalScore < bestScore) {
                            bestScore = totalScore
                            bestX = centerX
                            bestY = centerY
                        }
                    }
                }
                if (bestScore < 1000) break
            }
            return { x: bestX, y: bestY }
        },
        [elements, initialRadius, calculateCenterOfMass, distance]
    )

    const getCanvasCoordinates = (e: MouseEvent | TouchEvent) => {
        const rect = canvasRef.current?.getBoundingClientRect()
        if (!rect) return { x: 0, y: 0 }

        let clientX, clientY
        if (e instanceof MouseEvent) {
            clientX = e.clientX
            clientY = e.clientY
        } else {
            clientX = e.touches[0]?.clientX || e.changedTouches[0]?.clientX || 0
            clientY = e.touches[0]?.clientY || e.changedTouches[0]?.clientY || 0
        }

        return {
            x: clientX - rect.left,
            y: clientY - rect.top,
        }
    }

    const getSelectedOrMoveableIndices = useCallback(() => {
        if (multiSelectedElementIndices.length > 0)
            return multiSelectedElementIndices
        if (moveableElementIndex !== -1) return [moveableElementIndex]
        if (selectedElementIndex !== -1) return [selectedElementIndex]
        return []
    }, [
        multiSelectedElementIndices,
        moveableElementIndex,
        selectedElementIndex,
    ])

    const findNearestElementInDirection = useCallback(
        (direction: "left" | "right" | "up" | "down") => {
            const currentElement =
                elements[selectedElementIndex] ??
                elements[moveableElementIndex] ??
                elements[multiSelectedElementIndices[0]]
            if (elements.length <= 1 || !currentElement) {
                return elements.length > 0 ? 0 : -1
            }

            const candidates: Array<{
                index: number
                distance: number
                alignmentScore: number
            }> = []

            elements.forEach((element, index) => {
                if (element.id === currentElement.id) return

                const dx = element.x - currentElement.x
                const dy = element.y - currentElement.y
                const distVal = Math.sqrt(dx * dx + dy * dy) // Renamed to avoid conflict

                if (distVal < 5) return

                let isInDirection = false
                let alignmentScore = 0

                switch (direction) {
                    case "right":
                        isInDirection = dx > 0
                        alignmentScore = Math.abs(dy)
                        break
                    case "left":
                        isInDirection = dx < 0
                        alignmentScore = Math.abs(dy)
                        break
                    case "down":
                        isInDirection = dy > 0
                        alignmentScore = Math.abs(dx)
                        break
                    case "up":
                        isInDirection = dy < 0
                        alignmentScore = Math.abs(dx)
                        break
                }

                if (isInDirection) {
                    candidates.push({
                        index,
                        distance: distVal,
                        alignmentScore,
                    })
                }
            })

            if (candidates.length === 0) return -1

            candidates.sort((a, b) => {
                const alignmentDiff = a.alignmentScore - b.alignmentScore
                if (Math.abs(alignmentDiff) > 20) {
                    return alignmentDiff
                }
                return a.distance - b.distance
            })

            return candidates[0].index
        },
        [
            elements,
            selectedElementIndex,
            moveableElementIndex,
            multiSelectedElementIndices,
        ]
    )

    const handleMouseInteraction = useCallback(() => {
        if (keyboardMode) {
            setKeyboardMode(false)
            if (mouseInteractionTimeoutRef.current) {
                clearTimeout(mouseInteractionTimeoutRef.current)
            }
            // Don't clear selection immediately on mouse move if keyboard mode was active
            // mouseInteractionTimeoutRef.current = setTimeout(() => {
            //   setSelectedElementIndex(-1)
            //   setMultiSelectedElementIndices([])
            // }, 100)
        }
    }, [keyboardMode])

    const handleWheel = useCallback(
        (e: WheelEvent) => {
            e.preventDefault()
            const { x, y } = getCanvasCoordinates(e as any)
            const result = findElementAt(x, y)

            if (result) {
                const { element, index } = result
                const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1
                let changed = false

                setElements((prev) => {
                    const newElements = prev.map((el, idx) => {
                        if (idx === index) {
                            changed = true
                            if (el.type === "circle") {
                                const newRadius = Math.max(
                                    minRadius,
                                    Math.min(maxRadius, el.radius * scaleFactor)
                                )
                                setLastUsedRadius(newRadius)
                                return {
                                    ...el,
                                    radius: newRadius,
                                    mass: newRadius / 10,
                                }
                            } else if (el.type === "text") {
                                const newFontSize = Math.max(
                                    16,
                                    Math.min(
                                        72,
                                        (el.fontSize || fontSize) * scaleFactor
                                    )
                                )
                                const newRadius = Math.max(newFontSize / 2, 20) // effective radius for text
                                return {
                                    ...el,
                                    fontSize: newFontSize,
                                    radius: newRadius,
                                    mass: newRadius / 10,
                                }
                            } else if (
                                el.type === "rectangle" &&
                                el.width &&
                                el.height
                            ) {
                                const newWidth = Math.max(
                                    minRadius,
                                    el.width * scaleFactor
                                ) // Use minRadius as min dim
                                const newHeight = Math.max(
                                    minRadius,
                                    el.height * scaleFactor
                                )
                                const newRadius =
                                    Math.min(newWidth, newHeight) / 2 // effective radius
                                return {
                                    ...el,
                                    width: newWidth,
                                    height: newHeight,
                                    radius: newRadius,
                                    mass: (newWidth * newHeight) / 100,
                                }
                            }
                        }
                        return el
                    })
                    if (changed) saveHistory()
                    return newElements
                })

                setMoveableElementIndex(index)
                setSelectedElementIndex(-1)
                setMultiSelectedElementIndices([])
                setPhysicsActive(false)
            }
        },
        [
            findElementAt,
            minRadius,
            maxRadius,
            fontSize,
            lastUsedRadius,
            saveHistory,
        ]
    )

    const updatePhysics = useCallback(() => {
        const canvas = canvasRef.current
        if (!canvas || !physicsActive) return

        setElements((prevElements) => {
            let hasMovement = false
            const newElements = prevElements.map((el) => ({ ...el })) // Create a mutable copy

            for (let i = 0; i < newElements.length; i++) {
                const element = newElements[i]

                if (element.state === "moveable") continue

                if (isGravityPaused) {
                    element.vx *= 0.92 // Deceleration factor
                    element.vy *= 0.92
                    if (Math.abs(element.vx) < 0.05) element.vx = 0
                    if (Math.abs(element.vy) < 0.05) element.vy = 0
                    if (element.vx !== 0 || element.vy !== 0) hasMovement = true
                } else {
                    switch (gravityDirection) {
                        case "down":
                            element.vy += gravity
                            break
                        case "up":
                            element.vy -= gravity
                            break
                        case "left":
                            element.vx -= gravity
                            break
                        case "right":
                            element.vx += gravity
                            break
                    }
                    element.vx *= friction
                    element.vy *= friction
                }

                element.x += element.vx
                element.y += element.vy

                if (
                    Math.abs(element.vx) > 0.01 ||
                    Math.abs(element.vy) > 0.01
                ) {
                    hasMovement = true
                }

                const rect = canvas.getBoundingClientRect()
                const logicalWidth = rect.width
                const logicalHeight = rect.height
                const effectiveRadius =
                    element.type === "rectangle"
                        ? Math.min(element.width || 0, element.height || 0) / 2
                        : element.radius

                if (
                    gravityDirection === "down" &&
                    element.y + effectiveRadius > logicalHeight
                ) {
                    if (isClearing) continue
                    element.y = logicalHeight - effectiveRadius
                    element.vy *= -bounciness
                    if (Math.abs(element.vy) < 0.5) element.vy = 0
                } else if (
                    gravityDirection === "up" &&
                    element.y - effectiveRadius < 0
                ) {
                    if (isClearing) continue
                    element.y = effectiveRadius
                    element.vy *= -bounciness
                    if (Math.abs(element.vy) < 0.5) element.vy = 0
                } else if (
                    gravityDirection === "left" &&
                    element.x - effectiveRadius < 0
                ) {
                    if (isClearing) continue
                    element.x = effectiveRadius
                    element.vx *= -bounciness
                    if (Math.abs(element.vx) < 0.5) element.vx = 0
                } else if (
                    gravityDirection === "right" &&
                    element.x + effectiveRadius > logicalWidth
                ) {
                    if (isClearing) continue
                    element.x = logicalWidth - effectiveRadius
                    element.vx *= -bounciness
                    if (Math.abs(element.vx) < 0.5) element.vx = 0
                }

                if (gravityDirection === "down" || gravityDirection === "up") {
                    if (element.x - effectiveRadius < 0) {
                        element.x = effectiveRadius
                        element.vx *= -bounciness
                    }
                    if (element.x + effectiveRadius > logicalWidth) {
                        element.x = logicalWidth - effectiveRadius
                        element.vx *= -bounciness
                    }
                } else {
                    if (element.y - effectiveRadius < 0) {
                        element.y = effectiveRadius
                        element.vy *= -bounciness
                    }
                    if (element.y + effectiveRadius > logicalHeight) {
                        element.y = logicalHeight - effectiveRadius
                        element.vy *= -bounciness
                    }
                }
            }

            if (!isGravityPaused) {
                // Collisions only if not paused
                for (let i = 0; i < newElements.length; i++) {
                    for (let j = i + 1; j < newElements.length; j++) {
                        const el1 = newElements[i]
                        const el2 = newElements[j]
                        if (
                            el1.state === "moveable" ||
                            el2.state === "moveable"
                        )
                            continue

                        // Simplified collision: treat all as circles with effectiveRadius for now
                        const r1 =
                            el1.type === "rectangle"
                                ? Math.min(el1.width || 0, el1.height || 0) / 2
                                : el1.radius
                        const r2 =
                            el2.type === "rectangle"
                                ? Math.min(el2.width || 0, el2.height || 0) / 2
                                : el2.radius

                        const dx = el2.x - el1.x
                        const dy = el2.y - el1.y
                        const dist = Math.sqrt(dx * dx + dy * dy)
                        const minDist = r1 + r2

                        if (dist < minDist && dist > 0) {
                            hasMovement = true
                            const nx = dx / dist
                            const ny = dy / dist
                            const overlap = minDist - dist
                            const sepX = (overlap * nx) / 2
                            const sepY = (overlap * ny) / 2

                            el1.x -= sepX
                            el1.y -= sepY
                            el2.x += sepX
                            el2.y += sepY

                            const dvx = el2.vx - el1.vx
                            const dvy = el2.vy - el1.vy
                            const dvn = dvx * nx + dvy * ny
                            if (dvn > 0) continue

                            const impulse = (2 * dvn) / (el1.mass + el2.mass)
                            el1.vx += impulse * el2.mass * nx * bounciness
                            el1.vy += impulse * el2.mass * ny * bounciness
                            el2.vx -= impulse * el1.mass * nx * bounciness
                            el2.vy -= impulse * el1.mass * ny * bounciness
                        }
                    }
                }
            }

            if (!hasMovement && !isGravityPaused) {
                // Only stop physics if not paused and no movement
                setTimeout(() => setPhysicsActive(false), 100)
            }
            return newElements
        })
    }, [
        physicsActive,
        gravity,
        friction,
        bounciness,
        isClearing,
        gravityDirection,
        isGravityPaused,
    ])

    useEffect(() => {
        if (physicsActive) {
            const animate = () => {
                updatePhysics()
                animationFrameRef.current = requestAnimationFrame(animate)
            }
            animationFrameRef.current = requestAnimationFrame(animate)
        } else {
            if (animationFrameRef.current) {
                cancelAnimationFrame(animationFrameRef.current)
            }
        }
        return () => {
            if (animationFrameRef.current) {
                cancelAnimationFrame(animationFrameRef.current)
            }
        }
    }, [physicsActive, updatePhysics])

    useEffect(() => {
        if (isClearing && elements.length > 0) {
            const canvas = canvasRef.current
            if (!canvas) return
            const rect = canvas.getBoundingClientRect()
            const logicalHeight = rect.height
            const allElementsFallen = elements.every(
                (element) =>
                    element.y -
                        (element.type === "rectangle"
                            ? (element.height || 0) / 2
                            : element.radius) >
                    logicalHeight
            )

            if (allElementsFallen) {
                setElements([])
                setIsClearing(false)
                setSelectedElementIndex(-1)
                setMoveableElementIndex(-1)
                setMultiSelectedElementIndices([])
                setHoverElementId(null)
                if (!wasPhysicsActiveBeforeClearing) {
                    setPhysicsActive(false)
                }
                saveHistory()
            }
        }
    }, [elements, isClearing, wasPhysicsActiveBeforeClearing, saveHistory])

    const splitWordsIntoCharacters = useCallback(() => {
        setElements((prev) => {
            const newElements: Element[] = []
            let changed = false
            prev.forEach((element) => {
                if (
                    element.type === "text" &&
                    element.text &&
                    element.text.length > 1
                ) {
                    changed = true
                    const chars = element.text.split("")
                    const charSpacing = (element.fontSize || fontSize) * 0.6
                    const startX =
                        element.x - ((chars.length - 1) * charSpacing) / 2
                    chars.forEach((char, index) => {
                        newElements.push({
                            ...element,
                            id: generateId(),
                            x: startX + index * charSpacing,
                            text: char,
                            vx: (Math.random() - 0.5) * 2,
                            vy: Math.random() * -2,
                            mass: (element.fontSize || fontSize) / 20,
                        })
                    })
                } else {
                    newElements.push({
                        ...element,
                        vx: (Math.random() - 0.5) * 2,
                        vy: Math.random() * -2,
                        mass: element.radius / 10, // Ensure mass is set
                    })
                }
            })
            if (changed) saveHistory()
            return newElements
        })
    }, [fontSize, saveHistory])

    const handleUndo = useCallback(() => {
        if (historyIndex > 0) {
            setHistoryIndex((prev) => prev - 1)
            setElements(cloneElements(history[historyIndex - 1])) // Use clone
            setSelectedElementIndex(-1)
            setMoveableElementIndex(-1)
            setMultiSelectedElementIndices([])
        }
    }, [history, historyIndex])

    const handleRedo = useCallback(() => {
        if (historyIndex < history.length - 1) {
            setHistoryIndex((prev) => prev + 1)
            setElements(cloneElements(history[historyIndex + 1])) // Use clone
            setSelectedElementIndex(-1)
            setMoveableElementIndex(-1)
            setMultiSelectedElementIndices([])
        }
    }, [history, historyIndex])

    const handleCopy = useCallback(() => {
        const indicesToCopy = getSelectedOrMoveableIndices()
        if (indicesToCopy.length > 0) {
            const copied = indicesToCopy.map((index) => ({
                ...elements[index],
            }))
            setClipboard(copied)
        }
    }, [elements, getSelectedOrMoveableIndices])

    const handlePaste = useCallback(() => {
        if (clipboard) {
            const newPastedElements: Element[] = clipboard.map((el) => {
                const emptyArea = findMostEmptyArea(el.radius) // Use original radius/size for placement
                return {
                    ...el,
                    id: generateId(),
                    x: emptyArea.x,
                    y: emptyArea.y,
                    vx: 0,
                    vy: 0,
                    state: "default",
                }
            })
            setElements((prev) => [...prev, ...newPastedElements])
            // Select the newly pasted elements
            const newIndices = newPastedElements.map(
                (_, i) => elements.length + i
            )
            setMultiSelectedElementIndices(newIndices)
            setSelectedElementIndex(-1)
            setMoveableElementIndex(-1)
            saveHistory()
        }
    }, [clipboard, elements.length, findMostEmptyArea, saveHistory])

    const handleDelete = useCallback(() => {
        const indicesToDelete = getSelectedOrMoveableIndices()
        if (indicesToDelete.length > 0) {
            setElements((prev) =>
                prev.filter((_, index) => !indicesToDelete.includes(index))
            )
            setSelectedElementIndex(-1)
            setMoveableElementIndex(-1)
            setMultiSelectedElementIndices([])
            saveHistory()
        }
    }, [getSelectedOrMoveableIndices, saveHistory])

    const handleKeyDown = useCallback(
        (e: KeyboardEvent) => {
            const canvas = canvasRef.current
            if (!canvas) return

            setKeyboardMode(true)
            if (mouseInteractionTimeoutRef.current) {
                clearTimeout(mouseInteractionTimeoutRef.current)
            }

            const currentMoveableIndex = moveableElementIndex
            const moveableEl =
                currentMoveableIndex !== -1
                    ? elements[currentMoveableIndex]
                    : null
            // Update isTypingIntoTextElement based on whether the moveable element is text
            isTypingIntoTextElement.current = !!(
                moveableEl && moveableEl.type === "text"
            )

            if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === "z") {
                e.preventDefault()
                if (e.shiftKey) handleRedo()
                else handleUndo()
                return
            }
            if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === "c") {
                e.preventDefault()
                handleCopy()
                return
            }
            if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === "v") {
                e.preventDefault()
                handlePaste()
                return
            }
            if (
                e.key === "Delete" ||
                (e.key === "Backspace" && !isTypingIntoTextElement.current)
            ) {
                // Check isTyping...
                e.preventDefault()
                handleDelete()
                return
            }

            const rect = canvas.getBoundingClientRect()
            const logicalWidth = rect.width
            const logicalHeight = rect.height

            switch (e.key) {
                case "ArrowUp":
                case "ArrowDown":
                case "ArrowLeft":
                case "ArrowRight":
                    e.preventDefault()
                    if (physicsActive && !isGravityPaused) {
                        // Allow gravity direction change only if not paused
                        if (e.key === "ArrowUp") setGravityDirection("up")
                        else if (e.key === "ArrowDown")
                            setGravityDirection("down")
                        else if (e.key === "ArrowLeft")
                            setGravityDirection("left")
                        else if (e.key === "ArrowRight")
                            setGravityDirection("right")
                    } else if (moveableEl) {
                        const newElements = elements.map((el, index) => {
                            if (index === currentMoveableIndex) {
                                const effectiveRadius =
                                    el.type === "rectangle"
                                        ? Math.min(
                                              el.width || 0,
                                              el.height || 0
                                          ) / 2
                                        : el.radius
                                let newX = el.x,
                                    newY = el.y
                                if (e.key === "ArrowUp")
                                    newY = Math.max(
                                        effectiveRadius,
                                        el.y - movementSpeed
                                    )
                                else if (e.key === "ArrowDown")
                                    newY = Math.min(
                                        logicalHeight - effectiveRadius,
                                        el.y + movementSpeed
                                    )
                                else if (e.key === "ArrowLeft")
                                    newX = Math.max(
                                        effectiveRadius,
                                        el.x - movementSpeed
                                    )
                                else if (e.key === "ArrowRight")
                                    newX = Math.min(
                                        logicalWidth - effectiveRadius,
                                        el.x + movementSpeed
                                    )
                                return { ...el, x: newX, y: newY }
                            }
                            return el
                        })
                        setElements(newElements)
                        // No saveHistory here for performance during dragging-like movement
                    } else {
                        if (elements.length > 0) {
                            const dir = e.key.substring(5).toLowerCase() as
                                | "left"
                                | "right"
                                | "up"
                                | "down"
                            const nearestIndex =
                                findNearestElementInDirection(dir)
                            if (nearestIndex >= 0) {
                                setSelectedElementIndex(nearestIndex)
                                setMultiSelectedElementIndices([nearestIndex]) // Also update multi-select
                                setMoveableElementIndex(-1)
                            } else if (
                                selectedElementIndex < 0 &&
                                multiSelectedElementIndices.length === 0
                            ) {
                                setSelectedElementIndex(0)
                                setMultiSelectedElementIndices([0])
                            }
                        }
                    }
                    break

                case " ": // Space key
                    e.preventDefault()
                    if (physicsActive) {
                        setIsGravityPaused((prev) => !prev) // Toggle gravity pause
                    } else if (currentMoveableIndex !== -1) {
                        const currentIsText =
                            elements[currentMoveableIndex]?.type === "text"
                        setMoveableElementIndex(-1)
                        setSelectedElementIndex(currentMoveableIndex)
                        setMultiSelectedElementIndices([currentMoveableIndex])
                        if (currentIsText)
                            isTypingIntoTextElement.current = false // Exit typing mode
                        saveHistory()
                    } else if (multiSelectedElementIndices.length === 1) {
                        const idxToMove = multiSelectedElementIndices[0]
                        setMoveableElementIndex(idxToMove)
                        setSelectedElementIndex(-1)
                        setMultiSelectedElementIndices([])
                        if (elements[idxToMove]?.type === "text")
                            isTypingIntoTextElement.current = true // Enter typing mode
                    } else if (selectedElementIndex !== -1) {
                        setMoveableElementIndex(selectedElementIndex)
                        setSelectedElementIndex(-1)
                        setMultiSelectedElementIndices([])
                        if (elements[selectedElementIndex]?.type === "text")
                            isTypingIntoTextElement.current = true // Enter typing mode
                    }
                    break

                case "Enter":
                case "Return":
                    e.preventDefault()
                    if (
                        isTypingIntoTextElement.current &&
                        moveableEl &&
                        moveableEl.type === "text"
                    ) {
                        setMoveableElementIndex(-1)
                        setSelectedElementIndex(currentMoveableIndex)
                        setMultiSelectedElementIndices([currentMoveableIndex])
                        isTypingIntoTextElement.current = false
                        saveHistory()
                    } else if (elements.length > 0) {
                        if (physicsActive) {
                            setPhysicsActive(false)
                            setIsGravityPaused(false)
                        } else {
                            splitWordsIntoCharacters()
                            setPhysicsActive(true)
                            setIsGravityPaused(false)
                        }
                    }
                    break

                case "Escape":
                    e.preventDefault()
                    if (isTypingIntoTextElement.current && moveableEl) {
                        setMoveableElementIndex(-1)
                        setSelectedElementIndex(currentMoveableIndex) // Keep it selected
                        setMultiSelectedElementIndices([currentMoveableIndex])
                        isTypingIntoTextElement.current = false
                        saveHistory() // Save text changes on escape
                    } else if (
                        multiSelectedElementIndices.length > 0 ||
                        selectedElementIndex !== -1 ||
                        moveableElementIndex !== -1
                    ) {
                        // If something is selected or moveable, deselect all
                        setSelectedElementIndex(-1)
                        setMoveableElementIndex(-1)
                        setMultiSelectedElementIndices([])
                    } else if (elements.length > 0 && !isClearing) {
                        // Clear all if nothing selected
                        setIsClearing(true)
                        setWasPhysicsActiveBeforeClearing(physicsActive)
                        if (!physicsActive) {
                            setElements((prev) =>
                                prev.map((el) => ({
                                    ...el,
                                    vx: (Math.random() - 0.5) * 2,
                                    vy: Math.random() * -2,
                                    mass: el.radius / 10,
                                }))
                            )
                            setPhysicsActive(true)
                        }
                    }
                    break

                case "Backspace":
                    if (
                        isTypingIntoTextElement.current &&
                        moveableEl &&
                        moveableEl.type === "text" &&
                        moveableEl.text
                    ) {
                        e.preventDefault()
                        if (moveableEl.text.length > 1) {
                            setElements((prev) =>
                                prev.map((el, idx) =>
                                    idx === currentMoveableIndex
                                        ? { ...el, text: el.text!.slice(0, -1) }
                                        : el
                                )
                            )
                        } else {
                            setElements((prev) =>
                                prev.filter(
                                    (_, idx) => idx !== currentMoveableIndex
                                )
                            )
                            setMoveableElementIndex(-1)
                            setSelectedElementIndex(-1)
                            setMultiSelectedElementIndices([])
                            isTypingIntoTextElement.current = false
                            saveHistory()
                        }
                    }
                    break

                default:
                    if (
                        e.key.length === 1 &&
                        !e.metaKey &&
                        !e.ctrlKey &&
                        !e.altKey
                    ) {
                        // Single character, not a modifier combo
                        const char = e.key

                        if (
                            isTypingIntoTextElement.current &&
                            moveableEl &&
                            moveableEl.type === "text"
                        ) {
                            e.preventDefault()
                            setElements((prev) =>
                                prev.map((el, idx) =>
                                    idx === currentMoveableIndex
                                        ? {
                                              ...el,
                                              text: (el.text || "") + char,
                                          }
                                        : el
                                )
                            )
                        } else if (char.match(/^[a-zA-Z]$/i) && !e.shiftKey) {
                            // Only unshifted letters start new text elements
                            e.preventDefault()
                            const textRadius = Math.max(fontSize / 2, 20)
                            const emptyArea = findMostEmptyArea(textRadius)
                            const newElementId = generateId()
                            const newElement: Element = {
                                id: newElementId,
                                x: emptyArea.x,
                                y: emptyArea.y,
                                radius: textRadius,
                                color: textColor,
                                type: "text",
                                text: char,
                                fontSize: fontSize,
                                state: "moveable",
                                vx: 0,
                                vy: 0,
                                mass: textRadius / 10,
                            }
                            setElements((prev) => {
                                const updatedElements = [...prev, newElement]
                                setMoveableElementIndex(
                                    updatedElements.length - 1
                                )
                                setSelectedElementIndex(-1)
                                setMultiSelectedElementIndices([])
                                isTypingIntoTextElement.current = true
                                saveHistory()
                                return updatedElements
                            })
                        } else if (
                            !isTypingIntoTextElement.current &&
                            char.match(/^[0-9]$/)
                        ) {
                            e.preventDefault()
                            const numberValue =
                                char === "0" ? 10 : Number.parseInt(char)
                            let newElementToAdd: Element | null = null
                            let updatedElements = [...elements] // Start with current elements
                            let elementChanged = false

                            if (
                                e.shiftKey &&
                                selectedElementIndex === -1 &&
                                moveableElementIndex === -1 &&
                                multiSelectedElementIndices.length === 0
                            ) {
                                const baseAreaValue =
                                    minRadius +
                                    (numberValue - 1) *
                                        ((maxRadius - minRadius) / 9)
                                const area =
                                    baseAreaValue * baseAreaValue * Math.PI
                                const ratio = Math.random() * 1.5 + 0.5 // width/height ratio (0.5 to 2.0)
                                const rectWidth = Math.max(
                                    minRadius / 2,
                                    Math.sqrt(area * ratio)
                                ) // Ensure min dimension
                                const rectHeight = Math.max(
                                    minRadius / 2,
                                    area / rectWidth
                                )
                                const rectRadius =
                                    Math.min(rectWidth, rectHeight) / 2
                                const emptyArea = findMostEmptyArea(rectRadius)

                                newElementToAdd = {
                                    id: generateId(),
                                    x: emptyArea.x,
                                    y: emptyArea.y,
                                    radius: rectRadius,
                                    width: rectWidth,
                                    height: rectHeight,
                                    color: rectangleColor,
                                    type: "rectangle",
                                    state: "default",
                                    vx: 0,
                                    vy: 0,
                                    mass: (rectWidth * rectHeight) / 100,
                                }
                            } else if (!e.shiftKey) {
                                const newCircleRadius = Math.max(
                                    minRadius,
                                    Math.min(
                                        maxRadius,
                                        minRadius +
                                            (numberValue - 1) *
                                                ((maxRadius - minRadius) / 9)
                                    )
                                )
                                let targetIndex = -1
                                if (moveableEl?.type === "circle")
                                    targetIndex = currentMoveableIndex
                                else if (
                                    selectedElementIndex !== -1 &&
                                    elements[selectedElementIndex]?.type ===
                                        "circle" &&
                                    keyboardMode
                                )
                                    targetIndex = selectedElementIndex
                                else if (
                                    multiSelectedElementIndices.length === 1 &&
                                    elements[multiSelectedElementIndices[0]]
                                        ?.type === "circle" &&
                                    keyboardMode
                                )
                                    targetIndex = multiSelectedElementIndices[0]

                                if (targetIndex !== -1) {
                                    updatedElements = updatedElements.map(
                                        (el, idx) =>
                                            idx === targetIndex
                                                ? {
                                                      ...el,
                                                      radius: newCircleRadius,
                                                      mass:
                                                          newCircleRadius / 10,
                                                  }
                                                : el
                                    )
                                    setLastUsedRadius(newCircleRadius)
                                    elementChanged = true
                                } else if (
                                    selectedElementIndex === -1 &&
                                    moveableElementIndex === -1 &&
                                    multiSelectedElementIndices.length === 0
                                ) {
                                    const emptyArea =
                                        findMostEmptyArea(newCircleRadius)
                                    newElementToAdd = {
                                        id: generateId(),
                                        x: emptyArea.x,
                                        y: emptyArea.y,
                                        radius: newCircleRadius,
                                        color: circleColor,
                                        type: "circle",
                                        state: "default",
                                        vx: 0,
                                        vy: 0,
                                        mass: newCircleRadius / 10,
                                    }
                                    setLastUsedRadius(newCircleRadius)
                                }
                            }
                            if (newElementToAdd) {
                                updatedElements.push(newElementToAdd)
                                elementChanged = true
                            }
                            if (elementChanged) {
                                setElements(updatedElements)
                                setSelectedElementIndex(-1)
                                setMoveableElementIndex(-1)
                                setMultiSelectedElementIndices([])
                                saveHistory()
                            }
                        }
                    }
                    break
            }
        },
        [
            elements,
            selectedElementIndex,
            moveableElementIndex,
            multiSelectedElementIndices,
            movementSpeed,
            initialRadius,
            circleColor,
            textColor,
            rectangleColor,
            minRadius,
            maxRadius,
            physicsActive,
            isGravityPaused,
            findNearestElementInDirection,
            findMostEmptyArea,
            lastUsedRadius,
            fontSize,
            splitWordsIntoCharacters,
            keyboardMode,
            saveHistory,
            handleUndo,
            handleRedo,
            handleCopy,
            handlePaste,
            handleDelete,
        ]
    )

    useEffect(() => {
        setElements((prev) =>
            prev.map((element, index) => {
                let state: Element["state"] = "default"
                if (index === moveableElementIndex) {
                    state = "moveable"
                } else if (
                    multiSelectedElementIndices.includes(index) &&
                    keyboardMode
                ) {
                    state = "selected"
                } else if (
                    index === selectedElementIndex &&
                    keyboardMode &&
                    multiSelectedElementIndices.length === 0
                ) {
                    // Fallback for single selection if multi is empty
                    state = "selected"
                } else if (
                    element.id === hoverElementId &&
                    !keyboardMode &&
                    moveableElementIndex === -1 &&
                    multiSelectedElementIndices.length === 0
                ) {
                    state = "selected" // Hover selection only if nothing else is actively manipulated or multi-selected
                }
                return { ...element, state }
            })
        )
    }, [
        selectedElementIndex,
        moveableElementIndex,
        multiSelectedElementIndices,
        hoverElementId,
        keyboardMode,
    ])

    const draw = useCallback(() => {
        const canvas = canvasRef.current
        if (!canvas) return

        const ctx = canvas.getContext("2d")
        if (!ctx) return

        const rect = canvas.getBoundingClientRect()
        const logicalWidth = rect.width
        const logicalHeight = rect.height

        ctx.fillStyle = physicsActive ? physicsBackgroundColor : backgroundColor
        ctx.fillRect(0, 0, logicalWidth, logicalHeight)

        elements.forEach((element) => {
            let elStrokeColor = strokeColor
            let elLineWidth = strokeWidth
            const isSelectedOrMoveable =
                element.state === "selected" || element.state === "moveable"

            if (element.state === "selected") {
                elStrokeColor = selectedColor
                elLineWidth = selectedStrokeWidth
            } else if (element.state === "moveable") {
                elStrokeColor = moveableColor
                elLineWidth = moveableStrokeWidth
            }

            ctx.strokeStyle = elStrokeColor
            ctx.lineWidth = elLineWidth

            if (element.type === "circle") {
                ctx.beginPath()
                ctx.arc(element.x, element.y, element.radius, 0, 2 * Math.PI)
                ctx.fillStyle = element.color
                ctx.fill()
                if (isSelectedOrMoveable || element.state === "default") {
                    ctx.stroke()
                }
            } else if (
                element.type === "rectangle" &&
                element.width &&
                element.height
            ) {
                ctx.fillStyle = element.color
                ctx.fillRect(
                    element.x - element.width / 2,
                    element.y - element.height / 2,
                    element.width,
                    element.height
                )
                if (isSelectedOrMoveable || element.state === "default") {
                    ctx.strokeRect(
                        element.x - element.width / 2,
                        element.y - element.height / 2,
                        element.width,
                        element.height
                    )
                }
            } else if (element.type === "text" && element.text) {
                ctx.font = `${element.fontSize || fontSize}px Arial`
                ctx.textAlign = "center"
                ctx.textBaseline = "middle"

                const overlapDegree = countCharacterOverlaps(
                    element.x,
                    element.y,
                    getTextDimensions(
                        element.text,
                        element.fontSize || fontSize
                    ).width,
                    element.fontSize || fontSize,
                    elements,
                    element.id
                )
                ctx.fillStyle =
                    overlapDegree > 0
                        ? getOverlapColor(overlapDegree)
                        : element.color
                ctx.fillText(element.text, element.x, element.y)
                // No separate strokeText for selected/moveable text, only bounding box
            }

            // Draw selection/moveable indicators (dashed boxes)
            if (element.state === "selected") {
                const dims =
                    element.type === "text"
                        ? getTextDimensions(
                              element.text || "",
                              element.fontSize || fontSize
                          )
                        : {
                              width: element.radius * 2,
                              height: element.radius * 2,
                          }
                const padding = 5
                ctx.strokeStyle = selectedColor
                ctx.lineWidth = 1
                ctx.setLineDash([5, 5])
                if (element.type === "circle") {
                    ctx.beginPath()
                    ctx.arc(
                        element.x,
                        element.y,
                        element.radius + padding,
                        0,
                        2 * Math.PI
                    )
                    ctx.stroke()
                } else {
                    // Text or Rectangle
                    const w =
                        element.type === "rectangle"
                            ? element.width!
                            : dims.width
                    const h =
                        element.type === "rectangle"
                            ? element.height!
                            : dims.height
                    ctx.strokeRect(
                        element.x - w / 2 - padding,
                        element.y - h / 2 - padding,
                        w + padding * 2,
                        h + padding * 2
                    )
                }
                ctx.setLineDash([])
            }
            if (element.state === "moveable") {
                const dims =
                    element.type === "text"
                        ? getTextDimensions(
                              element.text || "",
                              element.fontSize || fontSize
                          )
                        : {
                              width: element.radius * 2,
                              height: element.radius * 2,
                          }
                const padding = 8
                ctx.strokeStyle = moveableColor
                ctx.lineWidth = 2
                ctx.setLineDash([3, 3])
                if (element.type === "circle") {
                    ctx.beginPath()
                    ctx.arc(
                        element.x,
                        element.y,
                        element.radius + padding,
                        0,
                        2 * Math.PI
                    )
                    ctx.stroke()
                } else {
                    // Text or Rectangle
                    const w =
                        element.type === "rectangle"
                            ? element.width!
                            : dims.width
                    const h =
                        element.type === "rectangle"
                            ? element.height!
                            : dims.height
                    ctx.strokeRect(
                        element.x - w / 2 - padding,
                        element.y - h / 2 - padding,
                        w + padding * 2,
                        h + padding * 2
                    )
                }
                ctx.setLineDash([])
            }
        })

        // Simplified Overlap Drawing (Circles only for now, needs extension for Rects)
        const allCircleElements = elements.filter((el) => el.type === "circle")
        if (allCircleElements.length >= 2) {
            for (let i = 0; i < allCircleElements.length; i++) {
                for (let j = i + 1; j < allCircleElements.length; j++) {
                    const c1 = allCircleElements[i]
                    const c2 = allCircleElements[j]
                    if (!circlesOverlap(c1, c2)) continue
                    ctx.save()
                    ctx.beginPath()
                    ctx.arc(c1.x, c1.y, c1.radius, 0, 2 * Math.PI)
                    ctx.clip()
                    ctx.beginPath()
                    ctx.arc(c2.x, c2.y, c2.radius, 0, 2 * Math.PI)
                    ctx.fillStyle = getOverlapColor(1)
                    ctx.fill()
                    ctx.restore()
                }
            }
        }
        // TODO: Extend overlap drawing for 3+, 4+ circles and all rectangle combinations. This is complex.
    }, [
        elements,
        backgroundColor,
        physicsBackgroundColor,
        strokeColor,
        strokeWidth,
        selectedColor,
        moveableColor,
        physicsActive,
        fontSize,
        getTextDimensions,
        countCharacterOverlaps,
        circlesOverlap,
        getOverlapColor,
        selectedStrokeWidth,
        moveableStrokeWidth,
        distance,
        rectanglesOverlap,
        circleRectangleOverlap,
    ])

    const handleMouseDown = useCallback(
        (e: MouseEvent) => {
            e.preventDefault()
            handleMouseInteraction()
            const { x, y } = getCanvasCoordinates(e)
            const result = findElementAt(x, y)

            if (result) {
                const { element, index } = result
                if (e.shiftKey) {
                    setMultiSelectedElementIndices((prev) => {
                        const newSelection = prev.includes(index)
                            ? prev.filter((i) => i !== index)
                            : [...prev, index]
                        if (newSelection.length === 1)
                            setSelectedElementIndex(newSelection[0])
                        else setSelectedElementIndex(-1)
                        return newSelection
                    })
                    setMoveableElementIndex(-1)
                } else {
                    setMoveableElementIndex(index)
                    setSelectedElementIndex(index)
                    setMultiSelectedElementIndices([index])
                    if (element.type === "text")
                        isTypingIntoTextElement.current = true
                }
                setPhysicsActive(false)
                setDragOffset({ x: x - element.x, y: y - element.y })
            } else {
                if (!e.shiftKey) {
                    setSelectedElementIndex(-1)
                    setMultiSelectedElementIndices([])
                }
                setMoveableElementIndex(-1)
                isTypingIntoTextElement.current = false

                const newElementId = generateId()
                const newElement: Element = {
                    id: newElementId,
                    x,
                    y,
                    radius: 5,
                    color: circleColor,
                    type: "circle",
                    state: "default",
                    vx: 0,
                    vy: 0,
                    mass: 1,
                }
                setElements((prev) => {
                    const newElements = [...prev, newElement]
                    saveHistory()
                    return newElements
                })
                setIsCreatingElement(true)
                setCreationStart({ x, y })
                creatingElementId.current = newElementId
            }
        },
        [findElementAt, handleMouseInteraction, circleColor, saveHistory]
    )

    const handleMouseMove = useCallback(
        (e: MouseEvent) => {
            const { x, y } = getCanvasCoordinates(e)

            if (
                isCreatingElement &&
                creationStart &&
                creatingElementId.current
            ) {
                const dragDistance = distance(
                    creationStart.x,
                    creationStart.y,
                    x,
                    y
                )
                const newRadius = Math.max(
                    minRadius,
                    Math.min(maxRadius, dragDistance)
                )
                setElements((prev) =>
                    prev.map((element) =>
                        element.id === creatingElementId.current
                            ? {
                                  ...element,
                                  radius: newRadius,
                                  mass: newRadius / 10,
                              }
                            : element
                    )
                )
            } else if (moveableElementIndex !== -1 && e.buttons === 1) {
                const canvas = canvasRef.current
                if (!canvas) return
                const canvasRect = canvas.getBoundingClientRect()
                const moveableEl = elements[moveableElementIndex]
                if (moveableEl) {
                    const effectiveRadius =
                        moveableEl.type === "rectangle"
                            ? Math.min(
                                  moveableEl.width || 0,
                                  moveableEl.height || 0
                              ) / 2
                            : moveableEl.radius
                    const newX = Math.max(
                        effectiveRadius,
                        Math.min(
                            canvasRect.width - effectiveRadius,
                            x - dragOffset.x
                        )
                    )
                    const newY = Math.max(
                        effectiveRadius,
                        Math.min(
                            canvasRect.height - effectiveRadius,
                            y - dragOffset.y
                        )
                    )
                    setElements((prev) =>
                        prev.map((el, idx) =>
                            idx === moveableElementIndex
                                ? { ...el, x: newX, y: newY }
                                : el
                        )
                    )
                }
            } else {
                if (e.buttons === 0) {
                    handleMouseInteraction()
                    const result = findElementAt(x, y)
                    setHoverElementId(result?.element.id || null)
                }
            }
        },
        [
            moveableElementIndex,
            dragOffset,
            findElementAt,
            handleMouseInteraction,
            isCreatingElement,
            creationStart,
            creatingElementId,
            minRadius,
            maxRadius,
            elements,
            distance,
        ]
    )

    const handleMouseUp = useCallback(() => {
        if (isCreatingElement && creatingElementId.current) {
            setIsCreatingElement(false)
            setCreationStart(null)
            const finalElement = elements.find(
                (el) => el.id === creatingElementId.current
            )
            if (finalElement && finalElement.radius < minRadius / 2) {
                setElements((prev) =>
                    prev.filter((el) => el.id !== creatingElementId.current)
                )
            } else if (finalElement) {
                saveHistory()
            }
            creatingElementId.current = null
        }

        if (moveableElementIndex !== -1) {
            saveHistory()
        }
    }, [
        isCreatingElement,
        creatingElementId,
        moveableElementIndex,
        elements,
        saveHistory,
        minRadius,
    ])

    const handleTouchStart = useCallback(
        (e: TouchEvent) => {
            e.preventDefault()
            handleMouseInteraction()
            const touch = e.touches[0]
            const { x, y } = getCanvasCoordinates(touch as any)

            if (e.touches.length === 2) {
                // ... (pinch logic unchanged)
            } else if (e.touches.length === 1) {
                const result = findElementAt(x, y)
                if (result) {
                    const { element, index } = result
                    // Shift key detection for touch is tricky, often not standard.
                    // For simplicity, touch start won't support multi-select for now.
                    // if (e.shiftKey) { ... }
                    setMoveableElementIndex(index)
                    setSelectedElementIndex(index)
                    setMultiSelectedElementIndices([index])
                    if (element.type === "text")
                        isTypingIntoTextElement.current = true
                    setPhysicsActive(false)
                    setDragOffset({ x: x - element.x, y: y - element.y })
                } else {
                    setSelectedElementIndex(-1)
                    setMultiSelectedElementIndices([])
                    setMoveableElementIndex(-1)
                    isTypingIntoTextElement.current = false
                    const newElementId = generateId()
                    const newElement: Element = {
                        id: newElementId,
                        x,
                        y,
                        radius: initialRadius / 2,
                        color: circleColor,
                        type: "circle",
                        state: "default",
                        vx: 0,
                        vy: 0,
                        mass: initialRadius / 2 / 10,
                    }
                    setElements((prev) => {
                        const newElements = [...prev, newElement]
                        saveHistory()
                        return newElements
                    })
                }
            }
        },
        [
            findElementAt,
            handleMouseInteraction,
            circleColor,
            initialRadius,
            saveHistory,
        ]
    )

    const handleTouchMove = useCallback(
        (e: TouchEvent) => {
            e.preventDefault()
            if (
                isPinching &&
                e.touches.length === 2 &&
                pinchElementIndex >= 0
            ) {
                // ... (pinch resize logic unchanged, but ensure saveHistory is called if element changes)
            } else if (e.touches.length === 1 && moveableElementIndex !== -1) {
                const touch = e.touches[0]
                const { x, y } = getCanvasCoordinates(touch as any)
                const canvas = canvasRef.current
                if (!canvas) return
                const canvasRect = canvas.getBoundingClientRect()
                const moveableEl = elements[moveableElementIndex]
                if (moveableEl) {
                    const effectiveRadius =
                        moveableEl.type === "rectangle"
                            ? Math.min(
                                  moveableEl.width || 0,
                                  moveableEl.height || 0
                              ) / 2
                            : moveableEl.radius
                    const newX = Math.max(
                        effectiveRadius,
                        Math.min(
                            canvasRect.width - effectiveRadius,
                            x - dragOffset.x
                        )
                    )
                    const newY = Math.max(
                        effectiveRadius,
                        Math.min(
                            canvasRect.height - effectiveRadius,
                            y - dragOffset.y
                        )
                    )
                    setElements((prev) =>
                        prev.map((el, idx) =>
                            idx === moveableElementIndex
                                ? { ...el, x: newX, y: newY }
                                : el
                        )
                    )
                }
            }
        },
        [
            isPinching,
            pinchElementIndex,
            pinchStartDistance,
            pinchStartRadius,
            minRadius,
            maxRadius,
            moveableElementIndex,
            dragOffset,
            lastUsedRadius,
            fontSize,
            elements,
            distance,
            saveHistory, // Added saveHistory
        ]
    )

    const handleTouchEnd = useCallback(
        (e: TouchEvent) => {
            e.preventDefault()
            if (isPinching) {
                setIsPinching(false)
                setPinchStartDistance(0)
                setPinchStartRadius(0)
                setPinchElementIndex(-1)
                saveHistory()
            }
            if (moveableElementIndex !== -1 && e.touches.length === 0) {
                saveHistory()
            }
        },
        [isPinching, moveableElementIndex, saveHistory, elements]
    )

    const handleContainerClick = useCallback(() => {
        if (containerRef.current) {
            containerRef.current.focus()
        }
    }, [])

    const handleScreenshotDownload = useCallback(() => {
        const canvas = canvasRef.current
        if (canvas) {
            const dataURL = canvas.toDataURL("image/png")
            const link = document.createElement("a")
            link.download = "interactive-canvas.png"
            link.href = dataURL
            link.click()
        }
    }, [])

    useEffect(() => {
        const canvas = canvasRef.current
        const container = containerRef.current
        if (!canvas || !container) return

        const resizeCanvas = () => {
            const rect = container.getBoundingClientRect()
            canvas.width = rect.width
            canvas.height = rect.height
            canvas.style.width = rect.width + "px"
            canvas.style.height = rect.height + "px"
            draw()
        }
        resizeCanvas()

        if (
            history.length === 1 &&
            history[0].length === 0 &&
            elements.length === 0
        ) {
            // Initial history setup
        }

        canvas.addEventListener("mousedown", handleMouseDown)
        canvas.addEventListener("mousemove", handleMouseMove)
        canvas.addEventListener("mouseup", handleMouseUp)
        canvas.addEventListener("touchstart", handleTouchStart, {
            passive: false,
        })
        canvas.addEventListener("touchmove", handleTouchMove, {
            passive: false,
        })
        canvas.addEventListener("touchend", handleTouchEnd, { passive: false })
        canvas.addEventListener("mouseleave", () => {
            setHoverElementId(null)
        })
        canvas.addEventListener("wheel", handleWheel, { passive: false })
        container.addEventListener("keydown", handleKeyDown)

        window.addEventListener("resize", resizeCanvas)

        return () => {
            canvas.removeEventListener("mousedown", handleMouseDown)
            canvas.removeEventListener("mousemove", handleMouseMove)
            canvas.removeEventListener("mouseup", handleMouseUp)
            canvas.removeEventListener("touchstart", handleTouchStart)
            canvas.removeEventListener("touchmove", handleTouchMove)
            canvas.removeEventListener("touchend", handleTouchEnd)
            canvas.removeEventListener("mouseleave", () => {
                setHoverElementId(null)
            })
            canvas.removeEventListener("wheel", handleWheel)
            container.removeEventListener("keydown", handleKeyDown)
            window.removeEventListener("resize", resizeCanvas)
            if (mouseInteractionTimeoutRef.current) {
                clearTimeout(mouseInteractionTimeoutRef.current)
            }
        }
    }, [
        handleMouseDown,
        handleMouseMove,
        handleMouseUp,
        handleTouchStart,
        handleTouchMove,
        handleTouchEnd,
        handleKeyDown,
        draw,
        handleWheel,
        history,
        elements.length,
    ])

    useEffect(() => {
        draw()
    }, [draw])

    return (
        <motion.div
            ref={containerRef}
            onClick={handleContainerClick}
            style={{
                ...style,
                width: "100%",
                height: "100%",
                minHeight: "400px",
                position: "relative",
                overflow: "hidden",
                outline: "none",
                cursor: "crosshair",
            }}
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ duration: 0.3 }}
            tabIndex={0}
        >
            <canvas
                ref={canvasRef}
                style={{
                    display: "block",
                    width: "100%",
                    height: "100%",
                    touchAction: "none",
                }}
            />

            {showInstructions && elements.length === 0 && (
                <div
                    style={{
                        position: "absolute",
                        top: "50%",
                        left: "50%",
                        transform: "translate(-50%, -50%)",
                        textAlign: "center",
                        pointerEvents: "none",
                        color: "#666",
                        fontSize: "16px",
                    }}
                >
                    <div>
                        Press numbers (1-9,0) to create circles. Shift+Numbers
                        for rectangles. Letters (a-z) for text.
                    </div>
                    <div style={{ fontSize: "14px", marginTop: "8px" }}>
                        Arrows to select  Space to move/edit  Enter for
                        gravity/finalize text  ESC to clear/cancel text
                    </div>
                    <div style={{ fontSize: "12px", marginTop: "6px" }}>
                        Ctrl/Cmd+Z: Undo, Ctrl/Cmd+Shift+Z: Redo, Ctrl/Cmd+C:
                        Copy, Ctrl/Cmd+V: Paste, Del: Delete
                    </div>
                </div>
            )}

            {showScreenshotButton && (
                <button
                    onClick={handleScreenshotDownload}
                    title="Download Screenshot"
                    style={{
                        position: "absolute",
                        top: "10px",
                        right: "10px",
                        background: "rgba(255,255,255,0.8)",
                        border: "1px solid #ccc",
                        borderRadius: "4px",
                        padding: "5px",
                        cursor: "pointer",
                        zIndex: 10,
                    }}
                >
                    <img
                        src={screenshotIconSrc || "/placeholder.svg"}
                        alt="Screenshot"
                        style={{
                            width: "24px",
                            height: "24px",
                            display: "block",
                        }}
                    />
                </button>
            )}

            <div
                style={{
                    position: "absolute",
                    top: "10px",
                    left: "10px",
                    background: "rgba(0,0,0,0.7)",
                    color: "white",
                    padding: "10px",
                    borderRadius: "5px",
                    fontSize: "12px",
                    pointerEvents: "none",
                    opacity: elements.length > 0 ? 1 : 0,
                    transition: "opacity 0.3s",
                    zIndex: 5,
                }}
            >
                <div> Controls:</div>
                <div>1-9,0: Circles  Shift+1-9,0: Rects  A-Z: Text</div>
                <div>
                     Select/Move  Space: Toggle Move/Edit/Pause Gravity
                </div>
                <div>
                    Enter: Gravity/Finalize Text  ESC: Clear All/Cancel Text
                </div>
                <div>Ctrl/Cmd+Z/Y/C/V, Del: Edit Actions</div>
                {multiSelectedElementIndices.length > 1 && (
                    <div>
                         Selected: {multiSelectedElementIndices.length} items
                    </div>
                )}
                {(multiSelectedElementIndices.length === 1 ||
                    selectedElementIndex !== -1) &&
                    !moveableElementIndex && (
                        <div>
                             Selected: Element{" "}
                            {multiSelectedElementIndices[0] !== undefined
                                ? multiSelectedElementIndices[0] + 1
                                : selectedElementIndex + 1}
                        </div>
                    )}
                {moveableElementIndex !== -1 && (
                    <div>
                         Moving/Editing: Element {moveableElementIndex + 1}{" "}
                        {elements[moveableElementIndex]?.type === "text" &&
                        isTypingIntoTextElement.current
                            ? "(Typing...)"
                            : ""}
                    </div>
                )}
                {physicsActive && (
                    <div>
                         Gravity: {gravityDirection.toUpperCase()}{" "}
                        {isGravityPaused ? "(Paused)" : "(Active)"}
                    </div>
                )}
            </div>
        </motion.div>
    )
}

// Property Controls
addPropertyControls(InteractiveCanvas, {
    backgroundColor: {
        type: ControlType.Color,
        title: "Background",
        defaultValue: "#f0f0f0",
    },
    physicsBackgroundColor: {
        type: ControlType.Color,
        title: "Physics BG",
        defaultValue: "#e8f4f8",
    },
    circleColor: {
        type: ControlType.Color,
        title: "Circle Color",
        defaultValue: "#3b82f6",
    },
    textColor: {
        type: ControlType.Color,
        title: "Text Color",
        defaultValue: "#2563eb",
    },
    rectangleColor: {
        type: ControlType.Color,
        title: "Rectangle Color",
        defaultValue: "#10b981",
    }, // New
    selectedColor: {
        type: ControlType.Color,
        title: "Selected/Hover",
        defaultValue: "#ff00ff",
    },
    moveableColor: {
        type: ControlType.Color,
        title: "Moveable",
        defaultValue: "#ff0000",
    },
    strokeColor: {
        type: ControlType.Color,
        title: "Default Stroke",
        defaultValue: "#000000",
    },
    strokeWidth: {
        type: ControlType.Number,
        title: "Stroke Width",
        min: 1,
        max: 10,
        step: 1,
        unit: "px",
        defaultValue: 2,
    },
    selectedStrokeWidth: {
        type: ControlType.Number,
        title: "Selected Stroke",
        min: 1,
        max: 10,
        step: 1,
        unit: "px",
        defaultValue: 3,
    },
    moveableStrokeWidth: {
        type: ControlType.Number,
        title: "Moveable Stroke",
        min: 1,
        max: 10,
        step: 1,
        unit: "px",
        defaultValue: 4,
    },
    overlapColor2: {
        type: ControlType.Color,
        title: "2-Overlap Color",
        defaultValue: "#ff6b35",
    },
    overlapColor3: {
        type: ControlType.Color,
        title: "3-Overlap Color",
        defaultValue: "#ff3535",
    },
    overlapColor4: {
        type: ControlType.Color,
        title: "4+ Overlap Color",
        defaultValue: "#ff0000",
    },
    fontSize: {
        type: ControlType.Number,
        title: "Font Size",
        min: 16,
        max: 72,
        step: 4,
        unit: "px",
        defaultValue: 32,
    },
    movementSpeed: {
        type: ControlType.Number,
        title: "Move Speed",
        min: 5,
        max: 50,
        step: 5,
        unit: "px",
        defaultValue: 15,
    },
    initialRadius: {
        type: ControlType.Number,
        title: "Initial Radius",
        min: 10,
        max: 200,
        step: 5,
        unit: "px",
        defaultValue: 40,
    },
    minRadius: {
        type: ControlType.Number,
        title: "Min Radius/Size",
        min: 5,
        max: 100,
        step: 5,
        unit: "px",
        defaultValue: 20,
    },
    maxRadius: {
        type: ControlType.Number,
        title: "Max Radius/Size",
        min: 50,
        max: 300,
        step: 10,
        unit: "px",
        defaultValue: 100,
    },
    gravity: {
        type: ControlType.Number,
        title: "Gravity",
        min: 0.1,
        max: 2,
        step: 0.1,
        defaultValue: 0.5,
    },
    friction: {
        type: ControlType.Number,
        title: "Friction",
        min: 0.9,
        max: 1,
        step: 0.01,
        defaultValue: 0.98,
    },
    bounciness: {
        type: ControlType.Number,
        title: "Bounciness",
        min: 0,
        max: 1,
        step: 0.1,
        defaultValue: 0.7,
    },
    showInstructions: {
        type: ControlType.Boolean,
        title: "Show Instructions",
        defaultValue: true,
    }, // New
    showScreenshotButton: {
        type: ControlType.Boolean,
        title: "Show Screenshot Btn",
        defaultValue: true,
    }, // New
    screenshotIconSrc: {
        type: ControlType.File,
        title: "Screenshot Icon",
        allowedFileTypes: ["svg", "png", "jpg"],
        defaultValue: "/placeholder.svg?width=24&height=24",
    }, // New
})
