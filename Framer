"use client"

import { useEffect, useRef, useState, useCallback } from "react"
import { addPropertyControls, ControlType } from "framer"
import { motion } from "framer-motion"

interface Element {
    id: string
    x: number
    y: number
    radius: number
    color: string
    state: "default" | "selected" | "moveable"
    type: "circle" | "text"
    text?: string
    fontSize?: number
    // Physics properties
    vx: number
    vy: number
    mass: number
}

/**
 * @framerDisableUnlink
 * @framerSupportedLayoutWidth any
 * @framerSupportedLayoutHeight any
 * @framerIntrinsicWidth 800
 * @framerIntrinsicHeight 600
 */
export default function InteractiveCanvas(props) {
    const {
        backgroundColor = "#f0f0f0",
        physicsBackgroundColor = "#e8f4f8",
        circleColor = "#3b82f6",
        textColor = "#2563eb",
        hoverColor = "#00ff00",
        selectedColor = "#ff00ff",
        moveableColor = "#ff0000",
        strokeColor = "#000000",
        strokeWidth = 2,
        overlapColor2 = "#ff6b35",
        overlapColor3 = "#ff3535",
        overlapColor4 = "#ff0000",
        minRadius = 20,
        maxRadius = 100,
        initialRadius = 40,
        fontSize = 32,
        movementSpeed = 15,
        gravity = 0.5,
        friction = 0.98,
        bounciness = 0.7,
        style,
    } = props

    const containerRef = useRef<HTMLDivElement>(null)
    const canvasRef = useRef<HTMLCanvasElement>(null)
    const animationFrameRef = useRef<number>()
    const mouseInteractionTimeoutRef = useRef<NodeJS.Timeout>()

    const [elements, setElements] = useState<Element[]>([])
    const [selectedElementIndex, setSelectedElementIndex] = useState<number>(-1)
    const [moveableElementIndex, setMoveableElementIndex] = useState<number>(-1)
    const [hoverElementId, setHoverElementId] = useState<string | null>(null)
    const [keyboardMode, setKeyboardMode] = useState(false)
    const [dragOffset, setDragOffset] = useState<{ x: number; y: number }>({
        x: 0,
        y: 0,
    })
    const [physicsActive, setPhysicsActive] = useState(false)
    const [isCreatingElement, setIsCreatingElement] = useState(false)
    const [creationStart, setCreationStart] = useState<{
        x: number
        y: number
    } | null>(null)
    const creatingElementId = useRef<string | null>(null)
    const [gravityDirection, setGravityDirection] = useState<
        "down" | "up" | "left" | "right"
    >("down")

    // Pinch gesture state
    const [isPinching, setIsPinching] = useState(false)
    const [pinchStartDistance, setPinchStartDistance] = useState(0)
    const [pinchStartRadius, setPinchStartRadius] = useState(0)
    const [pinchElementIndex, setPinchElementIndex] = useState(-1)

    const [isClearing, setIsClearing] = useState(false)
    const [wasPhysicsActiveBeforeClearing, setWasPhysicsActiveBeforeClearing] =
        useState(false)
    const [lastUsedRadius, setLastUsedRadius] = useState(initialRadius)

    // Generate unique ID for elements
    const generateId = () => Math.random().toString(36).substr(2, 9)

    // Calculate distance between two points
    const distance = (x1: number, y1: number, x2: number, y2: number) => {
        return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
    }

    // Calculate distance between two touch points
    const getTouchDistance = (touch1: Touch, touch2: Touch) => {
        const dx = touch2.clientX - touch1.clientX
        const dy = touch2.clientY - touch1.clientY
        return Math.sqrt(dx * dx + dy * dy)
    }

    // Get center point between two touches
    const getTouchCenter = (touch1: Touch, touch2: Touch) => {
        const rect = canvasRef.current?.getBoundingClientRect()
        if (!rect) return { x: 0, y: 0 }

        return {
            x: (touch1.clientX + touch2.clientX) / 2 - rect.left,
            y: (touch1.clientY + touch2.clientY) / 2 - rect.top,
        }
    }

    // Get text dimensions
    const getTextDimensions = useCallback((text: string, fontSize: number) => {
        const canvas = canvasRef.current
        if (!canvas) return { width: 0, height: 0 }

        const ctx = canvas.getContext("2d")
        if (!ctx) return { width: 0, height: 0 }

        ctx.font = `${fontSize}px Arial`
        const metrics = ctx.measureText(text)
        return {
            width: metrics.width,
            height: fontSize,
        }
    }, [])

    // Calculate center of mass for all elements
    const calculateCenterOfMass = useCallback(() => {
        if (elements.length === 0) {
            const canvas = canvasRef.current
            if (!canvas) return { x: 400, y: 300 }
            const rect = canvas.getBoundingClientRect()
            return { x: rect.width / 2, y: rect.height / 2 }
        }

        let totalMass = 0
        let weightedX = 0
        let weightedY = 0

        elements.forEach((element) => {
            const mass = element.mass || element.radius / 10
            totalMass += mass
            weightedX += element.x * mass
            weightedY += element.y * mass
        })

        return {
            x: weightedX / totalMass,
            y: weightedY / totalMass,
        }
    }, [elements])

    // Check if two circles overlap
    const circlesOverlap = useCallback((circle1: Element, circle2: Element) => {
        if (circle1.type !== "circle" || circle2.type !== "circle") return false
        const dist = distance(circle1.x, circle1.y, circle2.x, circle2.y)
        return dist < circle1.radius + circle2.radius
    }, [])

    // Get overlap color based on count
    const getOverlapColor = useCallback(
        (overlapCount: number) => {
            if (overlapCount === 1) return overlapColor2
            if (overlapCount === 2) return overlapColor3
            return overlapColor4 // 3 or more overlaps
        },
        [overlapColor2, overlapColor3, overlapColor4]
    )

    // Draw circle intersection with multi-level colors
    const drawCircleIntersection = useCallback(
        (ctx: CanvasRenderingContext2D, circle1: Element, circle2: Element) => {
            if (!circlesOverlap(circle1, circle2)) return

            const d = distance(circle1.x, circle1.y, circle2.x, circle2.y)
            const r1 = circle1.radius
            const r2 = circle2.radius

            // Count overlaps for both circles to determine color
            const circle1Overlaps = elements.filter(
                (el) =>
                    el.id !== circle1.id &&
                    el.type === "circle" &&
                    circlesOverlap(circle1, el)
            ).length
            const circle2Overlaps = elements.filter(
                (el) =>
                    el.id !== circle2.id &&
                    el.type === "circle" &&
                    circlesOverlap(circle2, el)
            ).length

            // Use the higher overlap count for the intersection color
            const maxOverlaps = Math.max(circle1Overlaps, circle2Overlaps)
            const intersectionColor = getOverlapColor(maxOverlaps)

            // If one circle is completely inside the other
            if (d <= Math.abs(r1 - r2)) {
                const smallerCircle = r1 < r2 ? circle1 : circle2
                ctx.beginPath()
                ctx.arc(
                    smallerCircle.x,
                    smallerCircle.y,
                    smallerCircle.radius,
                    0,
                    2 * Math.PI
                )
                ctx.fillStyle = intersectionColor
                ctx.fill()
                return
            }

            // Draw the intersection area using clipping
            ctx.save()
            ctx.beginPath()
            ctx.arc(circle1.x, circle1.y, circle1.radius, 0, 2 * Math.PI)
            ctx.clip()

            ctx.beginPath()
            ctx.arc(circle2.x, circle2.y, circle2.radius, 0, 2 * Math.PI)
            ctx.fillStyle = intersectionColor
            ctx.fill()
            ctx.restore()
        },
        [circlesOverlap, getOverlapColor, elements]
    )

    // Check if a character at a specific position overlaps with any element
    const characterOverlaps = useCallback(
        (
            charX: number,
            charY: number,
            charWidth: number,
            charHeight: number,
            allElements: Element[],
            excludeId: string
        ) => {
            return allElements.some((otherElement) => {
                if (otherElement.id === excludeId) return false

                if (otherElement.type === "circle") {
                    // Check if character bounding box intersects with circle
                    const closestX = Math.max(
                        charX - charWidth / 2,
                        Math.min(otherElement.x, charX + charWidth / 2)
                    )
                    const closestY = Math.max(
                        charY - charHeight / 2,
                        Math.min(otherElement.y, charY + charHeight / 2)
                    )
                    const distanceToRect = distance(
                        otherElement.x,
                        otherElement.y,
                        closestX,
                        closestY
                    )
                    return distanceToRect < otherElement.radius
                } else if (otherElement.type === "text" && otherElement.text) {
                    // Check if two character bounding boxes overlap
                    const otherTextDims = getTextDimensions(
                        otherElement.text,
                        otherElement.fontSize || fontSize
                    )
                    const otherRect = {
                        left: otherElement.x - otherTextDims.width / 2,
                        right: otherElement.x + otherTextDims.width / 2,
                        top: otherElement.y - otherTextDims.height / 2,
                        bottom: otherElement.y + otherTextDims.height / 2,
                    }

                    const charRect = {
                        left: charX - charWidth / 2,
                        right: charX + charWidth / 2,
                        top: charY - charHeight / 2,
                        bottom: charY + charHeight / 2,
                    }

                    return !(
                        charRect.right < otherRect.left ||
                        otherRect.right < charRect.left ||
                        charRect.bottom < otherRect.top ||
                        otherRect.bottom < charRect.top
                    )
                }

                return false
            })
        },
        [getTextDimensions, fontSize]
    )

    // Find element at position
    const findElementAt = useCallback(
        (x: number, y: number): { element: Element; index: number } | null => {
            for (let i = elements.length - 1; i >= 0; i--) {
                const element = elements[i]

                if (element.type === "circle") {
                    if (
                        distance(x, y, element.x, element.y) <= element.radius
                    ) {
                        return { element, index: i }
                    }
                } else if (element.type === "text" && element.text) {
                    const dims = getTextDimensions(
                        element.text,
                        element.fontSize || fontSize
                    )
                    const halfWidth = dims.width / 2
                    const halfHeight = dims.height / 2

                    if (
                        x >= element.x - halfWidth &&
                        x <= element.x + halfWidth &&
                        y >= element.y - halfHeight &&
                        y <= element.y + halfHeight
                    ) {
                        return { element, index: i }
                    }
                }
            }
            return null
        },
        [elements, getTextDimensions, fontSize]
    )

    // Find the most empty area on canvas with balanced placement
    const findMostEmptyArea = useCallback(
        (newElementRadius: number = initialRadius) => {
            const canvas = canvasRef.current
            if (!canvas) return { x: 400, y: 300 }

            const rect = canvas.getBoundingClientRect()
            const canvasCenter = { x: rect.width / 2, y: rect.height / 2 }
            const currentCenterOfMass = calculateCenterOfMass()

            const gridSize = Math.max(40, newElementRadius * 1.5)
            const logicalWidth = rect.width
            const logicalHeight = rect.height
            const cols = Math.floor(logicalWidth / gridSize)
            const rows = Math.floor(logicalHeight / gridSize)

            let bestScore = Number.POSITIVE_INFINITY
            let bestX = canvasCenter.x
            let bestY = canvasCenter.y

            // Check each grid cell
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const centerX = col * gridSize + gridSize / 2
                    const centerY = row * gridSize + gridSize / 2

                    // Skip if too close to edges
                    const margin = newElementRadius + 15
                    if (
                        centerX < margin ||
                        centerX > logicalWidth - margin ||
                        centerY < margin ||
                        centerY > logicalHeight - margin
                    ) {
                        continue
                    }

                    // Calculate overlap penalty with much higher weight
                    let overlapPenalty = 0
                    elements.forEach((element) => {
                        const dist = distance(
                            centerX,
                            centerY,
                            element.x,
                            element.y
                        )
                        const minDistance =
                            element.radius + newElementRadius + 20
                        if (dist < minDistance) {
                            overlapPenalty +=
                                Math.pow(minDistance - dist, 2) * 100 // Exponential penalty
                        }
                    })

                    // Skip positions with any overlap
                    if (overlapPenalty > 0) {
                        continue
                    }

                    // Calculate balance score
                    const newMass = newElementRadius / 10
                    const totalMass =
                        elements.reduce(
                            (sum, el) => sum + (el.mass || el.radius / 10),
                            0
                        ) + newMass

                    if (totalMass > 0) {
                        const currentTotalMass = totalMass - newMass
                        const newCenterOfMass = {
                            x:
                                currentTotalMass > 0
                                    ? (currentCenterOfMass.x *
                                          currentTotalMass +
                                          centerX * newMass) /
                                      totalMass
                                    : centerX,
                            y:
                                currentTotalMass > 0
                                    ? (currentCenterOfMass.y *
                                          currentTotalMass +
                                          centerY * newMass) /
                                      totalMass
                                    : centerY,
                        }

                        const currentDistanceFromCenter = distance(
                            currentCenterOfMass.x,
                            currentCenterOfMass.y,
                            canvasCenter.x,
                            canvasCenter.y
                        )
                        const newDistanceFromCenter = distance(
                            newCenterOfMass.x,
                            newCenterOfMass.y,
                            canvasCenter.x,
                            canvasCenter.y
                        )
                        const balanceBonus = Math.max(
                            0,
                            (currentDistanceFromCenter -
                                newDistanceFromCenter) *
                                3
                        )

                        const totalScore = -balanceBonus + Math.random() * 10 // Add small random factor for variety

                        if (totalScore < bestScore) {
                            bestScore = totalScore
                            bestX = centerX
                            bestY = centerY
                        }
                    }
                }
            }

            return { x: bestX, y: bestY }
        },
        [elements, initialRadius, calculateCenterOfMass]
    )

    // Get canvas coordinates from event
    const getCanvasCoordinates = (e: MouseEvent | TouchEvent) => {
        const rect = canvasRef.current?.getBoundingClientRect()
        if (!rect) return { x: 0, y: 0 }

        let clientX, clientY
        if (e instanceof MouseEvent) {
            clientX = e.clientX
            clientY = e.clientY
        } else {
            clientX = e.touches[0]?.clientX || e.changedTouches[0]?.clientX || 0
            clientY = e.touches[0]?.clientY || e.changedTouches[0]?.clientY || 0
        }

        return {
            x: clientX - rect.left,
            y: clientY - rect.top,
        }
    }

    // Get selected element
    const getSelectedElement = useCallback(() => {
        if (
            selectedElementIndex >= 0 &&
            selectedElementIndex < elements.length
        ) {
            return elements[selectedElementIndex]
        }
        return null
    }, [elements, selectedElementIndex])

    // Get moveable element
    const getMoveableElement = useCallback(() => {
        if (
            moveableElementIndex >= 0 &&
            moveableElementIndex < elements.length
        ) {
            return elements[moveableElementIndex]
        }
        return null
    }, [elements, moveableElementIndex])

    // Find nearest element in a direction
    const findNearestElementInDirection = useCallback(
        (direction: "left" | "right" | "up" | "down") => {
            const currentElement = getSelectedElement()
            if (elements.length <= 1) return -1

            if (!currentElement) {
                return 0
            }

            const candidates: Array<{
                index: number
                distance: number
                alignmentScore: number
            }> = []

            elements.forEach((element, index) => {
                if (element.id === currentElement.id) return

                const dx = element.x - currentElement.x
                const dy = element.y - currentElement.y
                const distance = Math.sqrt(dx * dx + dy * dy)

                if (distance < 5) return

                let isInDirection = false
                let alignmentScore = 0

                switch (direction) {
                    case "right":
                        isInDirection = dx > 0
                        alignmentScore = Math.abs(dy)
                        break
                    case "left":
                        isInDirection = dx < 0
                        alignmentScore = Math.abs(dy)
                        break
                    case "down":
                        isInDirection = dy > 0
                        alignmentScore = Math.abs(dx)
                        break
                    case "up":
                        isInDirection = dy < 0
                        alignmentScore = Math.abs(dx)
                        break
                }

                if (isInDirection) {
                    candidates.push({
                        index,
                        distance,
                        alignmentScore,
                    })
                }
            })

            if (candidates.length === 0) return -1

            candidates.sort((a, b) => {
                const alignmentDiff = a.alignmentScore - b.alignmentScore
                if (Math.abs(alignmentDiff) > 20) {
                    return alignmentDiff
                }
                return a.distance - b.distance
            })

            return candidates[0].index
        },
        [elements, getSelectedElement]
    )

    // Clear selection when switching to mouse mode
    const handleMouseInteraction = useCallback(() => {
        if (keyboardMode) {
            setKeyboardMode(false)
            if (mouseInteractionTimeoutRef.current) {
                clearTimeout(mouseInteractionTimeoutRef.current)
            }
            mouseInteractionTimeoutRef.current = setTimeout(() => {
                setSelectedElementIndex(-1)
            }, 100)
        }
    }, [keyboardMode])

    // Handle wheel/trackpad zoom
    const handleWheel = useCallback(
        (e: WheelEvent) => {
            e.preventDefault()

            const { x, y } = getCanvasCoordinates(e as any)
            const result = findElementAt(x, y)

            if (result) {
                const { element, index } = result
                const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1

                if (element.type === "circle") {
                    const newRadius = Math.max(
                        minRadius,
                        Math.min(maxRadius, element.radius * scaleFactor)
                    )
                    setLastUsedRadius(newRadius)

                    setElements((prev) =>
                        prev.map((el, idx) =>
                            idx === index
                                ? {
                                      ...el,
                                      radius: newRadius,
                                      mass: newRadius / 10,
                                  }
                                : el
                        )
                    )
                } else if (element.type === "text") {
                    const newFontSize = Math.max(
                        16,
                        Math.min(
                            72,
                            (element.fontSize || fontSize) * scaleFactor
                        )
                    )
                    const newRadius = Math.max(newFontSize / 2, 20)

                    setElements((prev) =>
                        prev.map((el, idx) =>
                            idx === index
                                ? {
                                      ...el,
                                      fontSize: newFontSize,
                                      radius: newRadius,
                                      mass: newRadius / 10,
                                  }
                                : el
                        )
                    )
                }

                // Make the element moveable when scaling
                setMoveableElementIndex(index)
                setSelectedElementIndex(-1)
                setPhysicsActive(false)
            }
        },
        [findElementAt, minRadius, maxRadius, fontSize, lastUsedRadius]
    )

    // Physics simulation
    const updatePhysics = useCallback(() => {
        const canvas = canvasRef.current
        if (!canvas || !physicsActive) return

        setElements((prevElements) => {
            const newElements = [...prevElements]
            let hasMovement = false

            // Apply gravity and update positions
            for (let i = 0; i < newElements.length; i++) {
                const element = newElements[i]

                // Skip physics for moveable elements
                if (element.state === "moveable") continue

                // Apply gravity based on direction
                switch (gravityDirection) {
                    case "down":
                        element.vy += gravity
                        break
                    case "up":
                        element.vy -= gravity
                        break
                    case "left":
                        element.vx -= gravity
                        break
                    case "right":
                        element.vx += gravity
                        break
                }

                // Apply friction
                element.vx *= friction
                element.vy *= friction

                // Update position
                element.x += element.vx
                element.y += element.vy

                const rect = canvas.getBoundingClientRect()
                const logicalWidth = rect.width
                const logicalHeight = rect.height

                // Check boundaries based on gravity direction
                if (
                    gravityDirection === "down" &&
                    element.y + element.radius > logicalHeight
                ) {
                    if (isClearing) {
                        continue
                    } else {
                        element.y = logicalHeight - element.radius
                        element.vy *= -bounciness
                        if (Math.abs(element.vy) < 0.5) element.vy = 0
                    }
                } else if (
                    gravityDirection === "up" &&
                    element.y - element.radius < 0
                ) {
                    if (isClearing) {
                        continue
                    } else {
                        element.y = element.radius
                        element.vy *= -bounciness
                        if (Math.abs(element.vy) < 0.5) element.vy = 0
                    }
                } else if (
                    gravityDirection === "left" &&
                    element.x - element.radius < 0
                ) {
                    if (isClearing) {
                        continue
                    } else {
                        element.x = element.radius
                        element.vx *= -bounciness
                        if (Math.abs(element.vx) < 0.5) element.vx = 0
                    }
                } else if (
                    gravityDirection === "right" &&
                    element.x + element.radius > logicalWidth
                ) {
                    if (isClearing) {
                        continue
                    } else {
                        element.x = logicalWidth - element.radius
                        element.vx *= -bounciness
                        if (Math.abs(element.vx) < 0.5) element.vx = 0
                    }
                }

                // Handle perpendicular boundaries
                if (gravityDirection === "down" || gravityDirection === "up") {
                    if (element.x - element.radius < 0) {
                        element.x = element.radius
                        element.vx *= -bounciness
                    }
                    if (element.x + element.radius > logicalWidth) {
                        element.x = logicalWidth - element.radius
                        element.vx *= -bounciness
                    }
                } else {
                    if (element.y - element.radius < 0) {
                        element.y = element.radius
                        element.vy *= -bounciness
                    }
                    if (element.y + element.radius > logicalHeight) {
                        element.y = logicalHeight - element.radius
                        element.vy *= -bounciness
                    }
                }

                if (Math.abs(element.vx) > 0.1 || Math.abs(element.vy) > 0.1) {
                    hasMovement = true
                }
            }

            // Element-to-element collisions
            for (let i = 0; i < newElements.length; i++) {
                for (let j = i + 1; j < newElements.length; j++) {
                    const element1 = newElements[i]
                    const element2 = newElements[j]

                    // Skip collisions if either element is moveable
                    if (
                        element1.state === "moveable" ||
                        element2.state === "moveable"
                    )
                        continue

                    const dx = element2.x - element1.x
                    const dy = element2.y - element1.y
                    const dist = Math.sqrt(dx * dx + dy * dy)
                    const minDist = element1.radius + element2.radius

                    if (dist < minDist) {
                        hasMovement = true

                        const nx = dx / dist
                        const ny = dy / dist

                        const overlap = minDist - dist
                        const separationX = (overlap * nx) / 2
                        const separationY = (overlap * ny) / 2

                        element1.x -= separationX
                        element1.y -= separationY
                        element2.x += separationX
                        element2.y += separationY

                        const dvx = element2.vx - element1.vx
                        const dvy = element2.vy - element1.vy
                        const dvn = dvx * nx + dvy * ny

                        if (dvn > 0) continue

                        const impulse =
                            (2 * dvn) / (element1.mass + element2.mass)

                        element1.vx += impulse * element2.mass * nx * bounciness
                        element1.vy += impulse * element2.mass * ny * bounciness
                        element2.vx -= impulse * element1.mass * nx * bounciness
                        element2.vy -= impulse * element1.mass * ny * bounciness
                    }
                }
            }

            // Stop physics if no movement
            if (!hasMovement) {
                setTimeout(() => setPhysicsActive(false), 100)
            }

            return newElements
        })
    }, [
        physicsActive,
        gravity,
        friction,
        bounciness,
        isClearing,
        gravityDirection,
    ])

    // Physics animation loop
    useEffect(() => {
        if (physicsActive) {
            const animate = () => {
                updatePhysics()
                animationFrameRef.current = requestAnimationFrame(animate)
            }
            animationFrameRef.current = requestAnimationFrame(animate)
        } else {
            if (animationFrameRef.current) {
                cancelAnimationFrame(animationFrameRef.current)
            }
        }

        return () => {
            if (animationFrameRef.current) {
                cancelAnimationFrame(animationFrameRef.current)
            }
        }
    }, [physicsActive, updatePhysics])

    // Check if clearing is complete
    useEffect(() => {
        if (isClearing && elements.length > 0) {
            const canvas = canvasRef.current
            if (!canvas) return

            const rect = canvas.getBoundingClientRect()
            const logicalHeight = rect.height
            const allElementsFallen = elements.every(
                (element) => element.y - element.radius > logicalHeight
            )

            if (allElementsFallen) {
                // All elements have fallen off screen
                setElements([])
                setIsClearing(false)
                setSelectedElementIndex(-1)
                setMoveableElementIndex(-1)
                setHoverElementId(null)

                // Restore physics state
                if (!wasPhysicsActiveBeforeClearing) {
                    setPhysicsActive(false)
                }
            }
        }
    }, [elements, isClearing, wasPhysicsActiveBeforeClearing])

    // Split text elements into individual characters for physics
    const splitWordsIntoCharacters = useCallback(() => {
        setElements((prev) => {
            const newElements: Element[] = []

            prev.forEach((element) => {
                if (
                    element.type === "text" &&
                    element.text &&
                    element.text.length > 1
                ) {
                    // Split multi-character text into individual characters
                    const chars = element.text.split("")
                    const charSpacing = (element.fontSize || fontSize) * 0.6
                    const startX =
                        element.x - ((chars.length - 1) * charSpacing) / 2

                    chars.forEach((char, index) => {
                        const charElement: Element = {
                            ...element,
                            id: generateId(),
                            x: startX + index * charSpacing,
                            text: char,
                            vx: (Math.random() - 0.5) * 2,
                            vy: Math.random() * -2,
                            mass: (element.fontSize || fontSize) / 20,
                        }
                        newElements.push(charElement)
                    })
                } else {
                    // Keep circles and single characters as-is, but add physics properties
                    newElements.push({
                        ...element,
                        vx: (Math.random() - 0.5) * 2,
                        vy: Math.random() * -2,
                        mass: element.radius / 10,
                    })
                }
            })

            return newElements
        })
    }, [fontSize])

    // Handle keyboard events
    const handleKeyDown = useCallback(
        (e: KeyboardEvent) => {
            const canvas = canvasRef.current
            if (!canvas) return

            setKeyboardMode(true)
            if (mouseInteractionTimeoutRef.current) {
                clearTimeout(mouseInteractionTimeoutRef.current)
            }

            const moveableElementIndexLocal = moveableElementIndex
            const moveableElement =
                moveableElementIndexLocal >= 0
                    ? elements[moveableElementIndexLocal]
                    : null

            const rect = canvas.getBoundingClientRect()
            const logicalWidth = rect.width
            const logicalHeight = rect.height

            switch (e.key) {
                case "ArrowUp":
                    e.preventDefault()
                    if (physicsActive) {
                        setGravityDirection("up")
                    } else if (moveableElement) {
                        setElements((prev) =>
                            prev.map((element, index) =>
                                index === moveableElementIndexLocal
                                    ? {
                                          ...element,
                                          y: Math.max(
                                              element.radius,
                                              element.y - movementSpeed
                                          ),
                                      }
                                    : element
                            )
                        )
                    } else {
                        if (elements.length > 0) {
                            const nearestIndex =
                                findNearestElementInDirection("up")
                            if (nearestIndex >= 0) {
                                setSelectedElementIndex(nearestIndex)
                            } else if (selectedElementIndex < 0) {
                                setSelectedElementIndex(0)
                            }
                        }
                    }
                    break

                case "ArrowDown":
                    e.preventDefault()
                    if (physicsActive) {
                        setGravityDirection("down")
                    } else if (moveableElement) {
                        setElements((prev) =>
                            prev.map((element, index) =>
                                index === moveableElementIndexLocal
                                    ? {
                                          ...element,
                                          y: Math.min(
                                              logicalHeight - element.radius,
                                              element.y + movementSpeed
                                          ),
                                      }
                                    : element
                            )
                        )
                    } else {
                        if (elements.length > 0) {
                            const nearestIndex =
                                findNearestElementInDirection("down")
                            if (nearestIndex >= 0) {
                                setSelectedElementIndex(nearestIndex)
                            } else if (selectedElementIndex < 0) {
                                setSelectedElementIndex(0)
                            }
                        }
                    }
                    break

                case "ArrowLeft":
                    e.preventDefault()
                    if (physicsActive) {
                        setGravityDirection("left")
                    } else if (moveableElement) {
                        setElements((prev) =>
                            prev.map((element, index) =>
                                index === moveableElementIndexLocal
                                    ? {
                                          ...element,
                                          x: Math.max(
                                              element.radius,
                                              element.x - movementSpeed
                                          ),
                                      }
                                    : element
                            )
                        )
                    } else {
                        if (elements.length > 0) {
                            const nearestIndex =
                                findNearestElementInDirection("left")
                            if (nearestIndex >= 0) {
                                setSelectedElementIndex(nearestIndex)
                            } else if (selectedElementIndex < 0) {
                                setSelectedElementIndex(0)
                            }
                        }
                    }
                    break

                case "ArrowRight":
                    e.preventDefault()
                    if (physicsActive) {
                        setGravityDirection("right")
                    } else if (moveableElement) {
                        setElements((prev) =>
                            prev.map((element, index) =>
                                index === moveableElementIndexLocal
                                    ? {
                                          ...element,
                                          x: Math.min(
                                              logicalWidth - element.radius,
                                              element.x + movementSpeed
                                          ),
                                      }
                                    : element
                            )
                        )
                    } else {
                        if (elements.length > 0) {
                            const nearestIndex =
                                findNearestElementInDirection("right")
                            if (nearestIndex >= 0) {
                                setSelectedElementIndex(nearestIndex)
                            } else if (selectedElementIndex < 0) {
                                setSelectedElementIndex(0)
                            }
                        }
                    }
                    break

                case " ": // Space key - toggle moveable state
                    e.preventDefault()
                    if (moveableElementIndexLocal >= 0) {
                        // Stop moving
                        setMoveableElementIndex(-1)
                    } else if (selectedElementIndex >= 0) {
                        // Start moving
                        setMoveableElementIndex(selectedElementIndex)
                        setSelectedElementIndex(-1)
                    }
                    break

                case "Enter":
                case "Return": // Enter key - toggle gravity
                    e.preventDefault()
                    if (elements.length > 0) {
                        if (physicsActive) {
                            setPhysicsActive(false)
                        } else {
                            // Split words into characters and start gravity
                            splitWordsIntoCharacters()
                            setPhysicsActive(true)
                        }
                    }
                    break

                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                case "0":
                    e.preventDefault()
                    const numberValue =
                        e.key === "0" ? 10 : Number.parseInt(e.key)
                    const newRadius = Math.max(
                        minRadius,
                        Math.min(
                            maxRadius,
                            minRadius +
                                (numberValue - 1) *
                                    ((maxRadius - minRadius) / 9)
                        )
                    )

                    // Check if we have a selected or moveable element to resize
                    const targetElement =
                        moveableElement || getSelectedElement()
                    if (targetElement) {
                        // Resize existing element
                        setLastUsedRadius(newRadius)
                        const targetIndex =
                            moveableElementIndexLocal >= 0
                                ? moveableElementIndexLocal
                                : selectedElementIndex

                        setElements((prev) =>
                            prev.map((element, index) => {
                                if (index === targetIndex) {
                                    if (element.type === "circle") {
                                        return {
                                            ...element,
                                            radius: newRadius,
                                            mass: newRadius / 10,
                                        }
                                    } else if (element.type === "text") {
                                        const newFontSize = Math.max(
                                            16,
                                            Math.min(
                                                72,
                                                16 + (numberValue - 1) * 6
                                            )
                                        )
                                        const textRadius = Math.max(
                                            newFontSize / 2,
                                            20
                                        )
                                        return {
                                            ...element,
                                            fontSize: newFontSize,
                                            radius: textRadius,
                                            mass: textRadius / 10,
                                        }
                                    }
                                }
                                return element
                            })
                        )
                    } else {
                        // Create new circle with balanced placement - set to default state
                        setLastUsedRadius(newRadius)
                        const emptyArea = findMostEmptyArea(newRadius)
                        const newElementId = generateId()
                        const newElement: Element = {
                            id: newElementId,
                            x: emptyArea.x,
                            y: emptyArea.y,
                            radius: newRadius,
                            color: circleColor,
                            type: "circle",
                            state: "default", // Changed from "moveable" to "default"
                            vx: 0,
                            vy: 0,
                            mass: newRadius / 10,
                        }
                        setElements((prev) => [...prev, newElement])
                        // Don't set as moveable anymore
                        setSelectedElementIndex(-1)
                        setMoveableElementIndex(-1)
                    }
                    break

                case "Escape":
                    e.preventDefault()
                    if (elements.length > 0) {
                        // Start clearing process
                        setIsClearing(true)
                        setWasPhysicsActiveBeforeClearing(physicsActive)

                        if (!physicsActive) {
                            // Turn on physics if it wasn't already on
                            setElements((prev) =>
                                prev.map((element) => ({
                                    ...element,
                                    vx: (Math.random() - 0.5) * 2,
                                    vy: Math.random() * -2,
                                    mass: element.radius / 10,
                                }))
                            )
                            setPhysicsActive(true)
                        }

                        // Clear any selected/moveable states
                        setSelectedElementIndex(-1)
                        setMoveableElementIndex(-1)
                    }
                    break

                case "Backspace":
                    e.preventDefault()
                    // Check if we have a moveable text element to remove characters from
                    const moveableElementLocal = moveableElement
                    if (
                        moveableElementLocal &&
                        moveableElementLocal.type === "text" &&
                        moveableElementLocal.text
                    ) {
                        if (moveableElementLocal.text.length > 1) {
                            // Remove last character
                            setElements((prev) =>
                                prev.map((element, index) =>
                                    index === moveableElementIndexLocal
                                        ? {
                                              ...element,
                                              text: element.text!.slice(0, -1),
                                          }
                                        : element
                                )
                            )
                        } else {
                            // If only one character left, remove the entire element
                            setElements((prev) =>
                                prev.filter(
                                    (_, index) =>
                                        index !== moveableElementIndexLocal
                                )
                            )
                            setMoveableElementIndex(-1)
                            setSelectedElementIndex(-1)
                        }
                    }
                    break

                default:
                    // Handle letter keys
                    if (e.key.length === 1 && e.key.match(/[a-zA-Z]/)) {
                        e.preventDefault()
                        const letter = e.key.toLowerCase()

                        // Check if we have a moveable text element to append to
                        const moveableElementLocal = moveableElement
                        if (
                            moveableElementLocal &&
                            moveableElementLocal.type === "text"
                        ) {
                            // Append to existing text element
                            setElements((prev) =>
                                prev.map((element, index) =>
                                    index === moveableElementIndexLocal
                                        ? {
                                              ...element,
                                              text:
                                                  (element.text || "") + letter,
                                          }
                                        : element
                                )
                            )
                        } else {
                            // Create new text element with balanced placement - set to moveable for text editing
                            const textRadius = Math.max(fontSize / 2, 20)
                            const emptyArea = findMostEmptyArea(textRadius)
                            const newElementId = generateId()

                            const newElement: Element = {
                                id: newElementId,
                                x: emptyArea.x,
                                y: emptyArea.y,
                                radius: textRadius,
                                color: textColor,
                                type: "text",
                                text: letter,
                                fontSize: fontSize,
                                state: "moveable", // Keep moveable for text editing
                                vx: 0,
                                vy: 0,
                                mass: textRadius / 10,
                            }
                            setElements((prev) => [...prev, newElement])
                            setMoveableElementIndex(elements.length)
                            setSelectedElementIndex(-1)
                        }
                    }
                    break
            }
        },
        [
            elements,
            selectedElementIndex,
            moveableElementIndex,
            movementSpeed,
            initialRadius,
            circleColor,
            textColor,
            minRadius,
            maxRadius,
            physicsActive,
            getSelectedElement,
            findNearestElementInDirection,
            findMostEmptyArea,
            lastUsedRadius,
            fontSize,
            splitWordsIntoCharacters,
        ]
    )

    // Update element states
    useEffect(() => {
        setElements((prev) =>
            prev.map((element, index) => {
                let state: Element["state"] = "default"

                if (index === moveableElementIndex) {
                    state = "moveable"
                } else if (index === selectedElementIndex && keyboardMode) {
                    state = "selected"
                } else if (element.id === hoverElementId && !keyboardMode) {
                    state = "selected"
                }

                return { ...element, state }
            })
        )
    }, [
        selectedElementIndex,
        moveableElementIndex,
        hoverElementId,
        keyboardMode,
    ])

    // Drawing function
    const draw = useCallback(() => {
        const canvas = canvasRef.current
        if (!canvas) return

        const ctx = canvas.getContext("2d")
        if (!ctx) return

        // Use logical dimensions (CSS size) for drawing calculations
        const rect = canvas.getBoundingClientRect()
        const logicalWidth = rect.width
        const logicalHeight = rect.height

        // Clear canvas with dynamic background
        ctx.fillStyle = physicsActive ? physicsBackgroundColor : backgroundColor
        ctx.fillRect(0, 0, logicalWidth, logicalHeight)

        // Draw circles first
        elements.forEach((element) => {
            if (element.type === "circle") {
                ctx.beginPath()
                ctx.arc(element.x, element.y, element.radius, 0, 2 * Math.PI)

                // Fill with original color
                ctx.fillStyle = element.color
                ctx.fill()

                // Stroke based on state
                let strokeColorToUse = strokeColor
                let lineWidth = strokeWidth

                switch (element.state) {
                    case "selected":
                        strokeColorToUse = selectedColor
                        lineWidth = strokeWidth + 1
                        break
                    case "moveable":
                        strokeColorToUse = moveableColor
                        lineWidth = strokeWidth + 2
                        break
                    default:
                        strokeColorToUse = strokeColor
                        lineWidth = strokeWidth
                }

                ctx.strokeStyle = strokeColorToUse
                ctx.lineWidth = lineWidth
                ctx.stroke()

                // Draw selection indicator
                if (element.state === "selected") {
                    ctx.beginPath()
                    ctx.arc(
                        element.x,
                        element.y,
                        element.radius + 5,
                        0,
                        2 * Math.PI
                    )
                    ctx.strokeStyle = selectedColor
                    ctx.lineWidth = 1
                    ctx.setLineDash([5, 5])
                    ctx.stroke()
                    ctx.setLineDash([])
                }

                // Draw moveable indicator
                if (element.state === "moveable") {
                    ctx.beginPath()
                    ctx.arc(
                        element.x,
                        element.y,
                        element.radius + 8,
                        0,
                        2 * Math.PI
                    )
                    ctx.strokeStyle = moveableColor
                    ctx.lineWidth = 2
                    ctx.setLineDash([3, 3])
                    ctx.stroke()
                    ctx.setLineDash([])
                }
            }
        })

        // Draw overlapping areas for circles
        const circleElements = elements.filter((el) => el.type === "circle")
        for (let i = 0; i < circleElements.length; i++) {
            for (let j = i + 1; j < circleElements.length; j++) {
                drawCircleIntersection(
                    ctx,
                    circleElements[i],
                    circleElements[j]
                )
            }
        }

        // Draw text elements with character-level overlap detection
        elements.forEach((element) => {
            if (element.type === "text" && element.text) {
                ctx.font = `${element.fontSize || fontSize}px Arial`
                ctx.textAlign = "center"
                ctx.textBaseline = "middle"

                // For multi-character text, check each character individually
                if (element.text.length > 1) {
                    const chars = element.text.split("")
                    const charSpacing = (element.fontSize || fontSize) * 0.6
                    const startX =
                        element.x - ((chars.length - 1) * charSpacing) / 2

                    chars.forEach((char, index) => {
                        const charX = startX + index * charSpacing
                        const charY = element.y
                        const charWidth = ctx.measureText(char).width
                        const charHeight = element.fontSize || fontSize

                        // Check if this character overlaps with any other element
                        const hasOverlap = characterOverlaps(
                            charX,
                            charY,
                            charWidth,
                            charHeight,
                            elements,
                            element.id
                        )
                        const charColor = hasOverlap
                            ? overlapColor2
                            : element.color

                        ctx.fillStyle = charColor
                        ctx.fillText(char, charX, charY)
                    })
                } else {
                    // Single character - check if it overlaps
                    const charWidth = ctx.measureText(element.text).width
                    const charHeight = element.fontSize || fontSize
                    const hasOverlap = characterOverlaps(
                        element.x,
                        element.y,
                        charWidth,
                        charHeight,
                        elements,
                        element.id
                    )
                    const textFillColor = hasOverlap
                        ? overlapColor2
                        : element.color

                    ctx.fillStyle = textFillColor
                    ctx.fillText(element.text, element.x, element.y)
                }

                // Draw outline based on state
                let strokeColorToUse = strokeColor
                let lineWidth = strokeWidth

                switch (element.state) {
                    case "selected":
                        strokeColorToUse = selectedColor
                        lineWidth = strokeWidth + 1
                        break
                    case "moveable":
                        strokeColorToUse = moveableColor
                        lineWidth = strokeWidth + 2
                        break
                    default:
                        strokeColorToUse = strokeColor
                        lineWidth = strokeWidth
                }

                if (element.state !== "default") {
                    ctx.strokeStyle = strokeColorToUse
                    ctx.lineWidth = lineWidth
                    ctx.strokeText(element.text, element.x, element.y)
                }

                // Draw selection indicator for text
                if (element.state === "selected") {
                    const dims = getTextDimensions(
                        element.text,
                        element.fontSize || fontSize
                    )
                    ctx.strokeStyle = selectedColor
                    ctx.lineWidth = 1
                    ctx.setLineDash([5, 5])
                    ctx.strokeRect(
                        element.x - dims.width / 2 - 5,
                        element.y - dims.height / 2 - 5,
                        dims.width + 10,
                        dims.height + 10
                    )
                    ctx.setLineDash([])
                }

                // Draw moveable indicator for text
                if (element.state === "moveable") {
                    const dims = getTextDimensions(
                        element.text,
                        element.fontSize || fontSize
                    )
                    ctx.strokeStyle = moveableColor
                    ctx.lineWidth = 2
                    ctx.setLineDash([3, 3])
                    ctx.strokeRect(
                        element.x - dims.width / 2 - 8,
                        element.y - dims.height / 2 - 8,
                        dims.width + 16,
                        dims.height + 16
                    )
                    ctx.setLineDash([])
                }
            }
        })
    }, [
        elements,
        backgroundColor,
        physicsBackgroundColor,
        strokeColor,
        strokeWidth,
        selectedColor,
        moveableColor,
        physicsActive,
        fontSize,
        getTextDimensions,
        drawCircleIntersection,
        characterOverlaps,
        overlapColor2,
    ])

    // Handle mouse down
    const handleMouseDown = useCallback(
        (e: MouseEvent) => {
            e.preventDefault()
            handleMouseInteraction()

            const { x, y } = getCanvasCoordinates(e)
            const result = findElementAt(x, y)

            if (result) {
                const { element, index } = result
                // Make clicked element moveable
                setMoveableElementIndex(index)
                setSelectedElementIndex(-1)
                setPhysicsActive(false) // Stop physics when dragging

                setDragOffset({
                    x: x - element.x,
                    y: y - element.y,
                })
            } else {
                // Clear any moveable element when clicking outside
                setMoveableElementIndex(-1)
                setSelectedElementIndex(-1)

                // Start creating new circle
                const newElementId = generateId()
                const newElement: Element = {
                    id: newElementId,
                    x,
                    y,
                    radius: 5,
                    color: circleColor,
                    type: "circle",
                    state: "default",
                    vx: 0,
                    vy: 0,
                    mass: 1,
                }
                setElements((prev) => [...prev, newElement])
                setIsCreatingElement(true)
                setCreationStart({ x, y })
                creatingElementId.current = newElementId
            }
        },
        [findElementAt, handleMouseInteraction, circleColor]
    )

    // Handle mouse move
    const handleMouseMove = useCallback(
        (e: MouseEvent) => {
            const { x, y } = getCanvasCoordinates(e)

            if (
                isCreatingElement &&
                creationStart &&
                creatingElementId.current
            ) {
                // Update radius of circle being created
                const dragDistance = distance(
                    creationStart.x,
                    creationStart.y,
                    x,
                    y
                )
                const newRadius = Math.max(
                    minRadius,
                    Math.min(maxRadius, dragDistance)
                )

                setElements((prev) =>
                    prev.map((element) =>
                        element.id === creatingElementId.current
                            ? {
                                  ...element,
                                  radius: newRadius,
                                  mass: newRadius / 10,
                              }
                            : element
                    )
                )
            } else if (moveableElementIndex >= 0 && e.buttons === 1) {
                // Handle dragging moveable element
                const canvas = canvasRef.current
                if (!canvas) return

                const rect = canvas.getBoundingClientRect()
                const logicalWidth = rect.width
                const logicalHeight = rect.height

                const moveableElement = elements[moveableElementIndex]
                if (moveableElement) {
                    const newX = Math.max(
                        moveableElement.radius,
                        Math.min(
                            logicalWidth - moveableElement.radius,
                            x - dragOffset.x
                        )
                    )
                    const newY = Math.max(
                        moveableElement.radius,
                        Math.min(
                            logicalHeight - moveableElement.radius,
                            y - dragOffset.y
                        )
                    )

                    setElements((prev) =>
                        prev.map((element, index) =>
                            index === moveableElementIndex
                                ? { ...element, x: newX, y: newY }
                                : element
                        )
                    )
                }
            } else {
                // Handle hover
                handleMouseInteraction()
                const result = findElementAt(x, y)
                setHoverElementId(result?.element.id || null)
            }
        },
        [
            moveableElementIndex,
            dragOffset,
            findElementAt,
            handleMouseInteraction,
            isCreatingElement,
            creationStart,
            creatingElementId,
            minRadius,
            maxRadius,
            elements,
        ]
    )

    // Handle mouse up
    const handleMouseUp = useCallback(() => {
        if (isCreatingElement && creatingElementId.current) {
            // Finish creating element
            setIsCreatingElement(false)
            setCreationStart(null)
            creatingElementId.current = null
        }

        // Reset moveable element when mouse is released
        if (moveableElementIndex >= 0) {
            setMoveableElementIndex(-1)
        }
    }, [isCreatingElement, creatingElementId, moveableElementIndex])

    // Handle touch start
    const handleTouchStart = useCallback(
        (e: TouchEvent) => {
            e.preventDefault()
            handleMouseInteraction()

            if (e.touches.length === 2) {
                // Two finger pinch
                const touch1 = e.touches[0]
                const touch2 = e.touches[1]
                const center = getTouchCenter(touch1, touch2)
                const result = findElementAt(center.x, center.y)

                if (result) {
                    const { element, index } = result
                    setIsPinching(true)
                    setPinchStartDistance(getTouchDistance(touch1, touch2))
                    setPinchStartRadius(element.radius)
                    setPinchElementIndex(index)

                    // Make the pinched element moveable
                    setMoveableElementIndex(index)
                    setSelectedElementIndex(-1)
                    setPhysicsActive(false)
                }
            } else if (e.touches.length === 1) {
                // Single finger - treat like mouse
                const { x, y } = getCanvasCoordinates(e)
                const result = findElementAt(x, y)

                if (result) {
                    const { element, index } = result
                    setMoveableElementIndex(index)
                    setSelectedElementIndex(-1)
                    setPhysicsActive(false)

                    setDragOffset({
                        x: x - element.x,
                        y: y - element.y,
                    })
                } else {
                    setMoveableElementIndex(-1)
                    setSelectedElementIndex(-1)

                    const newElementId = generateId()
                    const newElement: Element = {
                        id: newElementId,
                        x,
                        y,
                        radius: 5,
                        color: circleColor,
                        type: "circle",
                        state: "default",
                        vx: 0,
                        vy: 0,
                        mass: 1,
                    }
                    setElements((prev) => [...prev, newElement])
                    setIsCreatingElement(true)
                    setCreationStart({ x, y })
                    creatingElementId.current = newElementId
                }
            }
        },
        [findElementAt, handleMouseInteraction, circleColor]
    )

    // Handle touch move
    const handleTouchMove = useCallback(
        (e: TouchEvent) => {
            e.preventDefault()

            if (
                isPinching &&
                e.touches.length === 2 &&
                pinchElementIndex >= 0
            ) {
                // Handle pinch resize
                const touch1 = e.touches[0]
                const touch2 = e.touches[1]
                const currentDistance = getTouchDistance(touch1, touch2)
                const scale = currentDistance / pinchStartDistance

                const element = elements[pinchElementIndex]
                if (element.type === "circle") {
                    const newRadius = Math.max(
                        minRadius,
                        Math.min(maxRadius, pinchStartRadius * scale)
                    )
                    setLastUsedRadius(newRadius)

                    setElements((prev) =>
                        prev.map((el, index) =>
                            index === pinchElementIndex
                                ? {
                                      ...el,
                                      radius: newRadius,
                                      mass: newRadius / 10,
                                  }
                                : el
                        )
                    )
                } else if (element.type === "text") {
                    const newFontSize = Math.max(
                        16,
                        Math.min(72, (element.fontSize || fontSize) * scale)
                    )
                    const newRadius = Math.max(newFontSize / 2, 20)

                    setElements((prev) =>
                        prev.map((el, index) =>
                            index === pinchElementIndex
                                ? {
                                      ...el,
                                      fontSize: newFontSize,
                                      radius: newRadius,
                                      mass: newRadius / 10,
                                  }
                                : el
                        )
                    )
                }
            } else if (e.touches.length === 1) {
                // Single finger - treat like mouse move
                const { x, y } = getCanvasCoordinates(e)

                if (
                    isCreatingElement &&
                    creationStart &&
                    creatingElementId.current
                ) {
                    const dragDistance = distance(
                        creationStart.x,
                        creationStart.y,
                        x,
                        y
                    )
                    const newRadius = Math.max(
                        minRadius,
                        Math.min(maxRadius, dragDistance)
                    )

                    setElements((prev) =>
                        prev.map((element) =>
                            element.id === creatingElementId.current
                                ? {
                                      ...element,
                                      radius: newRadius,
                                      mass: newRadius / 10,
                                  }
                                : element
                        )
                    )
                } else if (moveableElementIndex >= 0) {
                    const canvas = canvasRef.current
                    if (!canvas) return

                    const rect = canvas.getBoundingClientRect()
                    const logicalWidth = rect.width
                    const logicalHeight = rect.height

                    const moveableElement = elements[moveableElementIndex]
                    if (moveableElement) {
                        const newX = Math.max(
                            moveableElement.radius,
                            Math.min(
                                logicalWidth - moveableElement.radius,
                                x - dragOffset.x
                            )
                        )
                        const newY = Math.max(
                            moveableElement.radius,
                            Math.min(
                                logicalHeight - moveableElement.radius,
                                y - dragOffset.y
                            )
                        )

                        setElements((prev) =>
                            prev.map((element, index) =>
                                index === moveableElementIndex
                                    ? { ...element, x: newX, y: newY }
                                    : element
                            )
                        )
                    }
                }
            }
        },
        [
            isPinching,
            pinchElementIndex,
            pinchStartDistance,
            pinchStartRadius,
            minRadius,
            maxRadius,
            isCreatingElement,
            creationStart,
            creatingElementId,
            moveableElementIndex,
            dragOffset,
            lastUsedRadius,
            fontSize,
            elements,
        ]
    )

    // Handle touch end
    const handleTouchEnd = useCallback(
        (e: TouchEvent) => {
            e.preventDefault()

            if (isPinching) {
                setIsPinching(false)
                setPinchStartDistance(0)
                setPinchStartRadius(0)
                setPinchElementIndex(-1)
            }

            if (
                isCreatingElement &&
                creatingElementId.current &&
                e.touches.length === 0
            ) {
                setIsCreatingElement(false)
                setCreationStart(null)
                creatingElementId.current = null
            }
        },
        [isPinching, isCreatingElement, creatingElementId]
    )

    const handleContainerClick = useCallback(() => {
        if (containerRef.current) {
            containerRef.current.focus()
        }
    }, [])

    // Setup canvas and event listeners
    useEffect(() => {
        const canvas = canvasRef.current
        const container = containerRef.current
        if (!canvas || !container) return

        const resizeCanvas = () => {
            const rect = container.getBoundingClientRect()

            // Set canvas size to match container exactly
            canvas.width = rect.width
            canvas.height = rect.height
            canvas.style.width = rect.width + "px"
            canvas.style.height = rect.height + "px"

            draw()
        }

        resizeCanvas()

        canvas.addEventListener("mousedown", handleMouseDown)
        canvas.addEventListener("mousemove", handleMouseMove)
        canvas.addEventListener("mouseup", handleMouseUp)
        canvas.addEventListener("touchstart", handleTouchStart, {
            passive: false,
        })
        canvas.addEventListener("touchmove", handleTouchMove, {
            passive: false,
        })
        canvas.addEventListener("touchend", handleTouchEnd, { passive: false })
        canvas.addEventListener("mouseleave", () => {
            setHoverElementId(null)
        })
        canvas.addEventListener("wheel", handleWheel, { passive: false })

        container.addEventListener("keydown", handleKeyDown)
        container.focus()

        window.addEventListener("resize", resizeCanvas)

        return () => {
            canvas.removeEventListener("mousedown", handleMouseDown)
            canvas.removeEventListener("mousemove", handleMouseMove)
            canvas.removeEventListener("mouseup", handleMouseUp)
            canvas.removeEventListener("touchstart", handleTouchStart)
            canvas.removeEventListener("touchmove", handleTouchMove)
            canvas.removeEventListener("touchend", handleTouchEnd)
            canvas.removeEventListener("mouseleave", () => {
                setHoverElementId(null)
            })
            canvas.removeEventListener("wheel", handleWheel)
            container.removeEventListener("keydown", handleKeyDown)
            window.removeEventListener("resize", resizeCanvas)

            if (mouseInteractionTimeoutRef.current) {
                clearTimeout(mouseInteractionTimeoutRef.current)
            }
        }
    }, [
        handleMouseDown,
        handleMouseMove,
        handleMouseUp,
        handleTouchStart,
        handleTouchMove,
        handleTouchEnd,
        handleKeyDown,
        draw,
        handleWheel,
    ])

    // Redraw when elements change
    useEffect(() => {
        draw()
    }, [draw])

    return (
        <motion.div
            ref={containerRef}
            onClick={handleContainerClick}
            style={{
                ...style,
                width: "100%",
                height: "100%",
                minHeight: "400px",
                position: "relative",
                overflow: "hidden",
                outline: "none",
                cursor: "crosshair",
            }}
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ duration: 0.3 }}
            tabIndex={0}
        >
            <canvas
                ref={canvasRef}
                style={{
                    display: "block",
                    width: "100%",
                    height: "100%",
                    touchAction: "none",
                }}
            />

            {/* Instructions overlay */}
            {elements.length === 0 && (
                <div
                    style={{
                        position: "absolute",
                        top: "50%",
                        left: "50%",
                        transform: "translate(-50%, -50%)",
                        textAlign: "center",
                        pointerEvents: "none",
                        color: "#666",
                        fontSize: "16px",
                    }}
                >
                    <div>
                        Press numbers (1-9,0) to create circles or letters (a-z)
                        for text
                    </div>
                    <div style={{ fontSize: "14px", marginTop: "8px" }}>
                        Arrow keys to select  Space to toggle move  Enter for
                        gravity  ESC to clear
                    </div>
                </div>
            )}

            {/* Controls help */}
            <div
                style={{
                    position: "absolute",
                    top: "10px",
                    left: "10px",
                    background: "rgba(0,0,0,0.7)",
                    color: "white",
                    padding: "10px",
                    borderRadius: "5px",
                    fontSize: "12px",
                    pointerEvents: "none",
                    opacity: elements.length > 0 ? 1 : 0,
                    transition: "opacity 0.3s",
                }}
            >
                <div> Controls:</div>
                <div>
                    1-9,0 = Circles  A-Z = Letters   Select/Move  Space =
                    Toggle Move
                </div>
                <div>
                    Enter = Gravity  ESC = Clear  Click & Drag = Create/Move 
                    Pinch/Wheel = Resize
                </div>
                {selectedElementIndex >= 0 && keyboardMode && (
                    <div> Selected: Element {selectedElementIndex + 1}</div>
                )}
                {moveableElementIndex >= 0 && (
                    <div> Moving: Element {moveableElementIndex + 1}</div>
                )}
                {physicsActive && (
                    <div>
                         Gravity: {gravityDirection.toUpperCase()} (use arrow
                        keys to change)
                    </div>
                )}
            </div>
        </motion.div>
    )
}

// Property Controls
addPropertyControls(InteractiveCanvas, {
    backgroundColor: {
        type: ControlType.Color,
        title: "Background",
        defaultValue: "#f0f0f0",
    },
    physicsBackgroundColor: {
        type: ControlType.Color,
        title: "Physics Background",
        defaultValue: "#e8f4f8",
    },
    circleColor: {
        type: ControlType.Color,
        title: "Circle Color",
        defaultValue: "#3b82f6",
    },
    textColor: {
        type: ControlType.Color,
        title: "Text Color",
        defaultValue: "#2563eb",
    },
    selectedColor: {
        type: ControlType.Color,
        title: "Selected/Hover Color",
        defaultValue: "#ff00ff",
    },
    moveableColor: {
        type: ControlType.Color,
        title: "Moveable Color",
        defaultValue: "#ff0000",
    },
    strokeColor: {
        type: ControlType.Color,
        title: "Default Stroke Color",
        defaultValue: "#000000",
    },
    strokeWidth: {
        type: ControlType.Number,
        title: "Stroke Width",
        min: 1,
        max: 10,
        step: 1,
        unit: "px",
        defaultValue: 2,
    },
    overlapColor2: {
        type: ControlType.Color,
        title: "2-Element Overlap Color",
        defaultValue: "#ff6b35",
    },
    overlapColor3: {
        type: ControlType.Color,
        title: "3-Element Overlap Color",
        defaultValue: "#ff3535",
    },
    overlapColor4: {
        type: ControlType.Color,
        title: "4+ Element Overlap Color",
        defaultValue: "#ff0000",
    },
    fontSize: {
        type: ControlType.Number,
        title: "Font Size",
        min: 16,
        max: 72,
        step: 4,
        unit: "px",
        defaultValue: 32,
    },
    movementSpeed: {
        type: ControlType.Number,
        title: "Movement Speed",
        min: 5,
        max: 50,
        step: 5,
        unit: "px",
        defaultValue: 15,
    },
    initialRadius: {
        type: ControlType.Number,
        title: "Initial Radius",
        min: 10,
        max: 200,
        step: 5,
        unit: "px",
        defaultValue: 40,
    },
    minRadius: {
        type: ControlType.Number,
        title: "Min Radius",
        min: 5,
        max: 100,
        step: 5,
        unit: "px",
        defaultValue: 20,
    },
    maxRadius: {
        type: ControlType.Number,
        title: "Max Radius",
        min: 50,
        max: 300,
        step: 10,
        unit: "px",
        defaultValue: 100,
    },
    gravity: {
        type: ControlType.Number,
        title: "Gravity",
        min: 0.1,
        max: 2,
        step: 0.1,
        defaultValue: 0.5,
    },
    friction: {
        type: ControlType.Number,
        title: "Friction",
        min: 0.9,
        max: 1,
        step: 0.01,
        defaultValue: 0.98,
    },
    bounciness: {
        type: ControlType.Number,
        title: "Bounciness",
        min: 0,
        max: 1,
        step: 0.1,
        defaultValue: 0.7,
    },
})
