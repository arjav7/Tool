"use client"

import { useEffect, useRef, useState, useCallback } from "react"
import { addPropertyControls, ControlType } from "framer"
import { motion } from "framer-motion"

// Updated Element interface to include rectangles and their properties
interface Element {
    id: string
    x: number
    y: number
    radius: number // For circles, and as a general collision/interaction radius for other types
    color: string
    state: "default" | "selected" | "moveable"
    type: "circle" | "text" | "rectangle" // Added "rectangle"
    text?: string
    fontSize?: number
    // Rectangle specific properties
    width?: number
    height?: number
    // Physics properties
    vx: number
    vy: number
    mass: number
    // Add rotation properties for rectangles
    angle?: number
    angularVelocity?: number
}

/**
 * @framerDisableUnlink
 * @framerSupportedLayoutWidth any
 * @framerSupportedLayoutHeight any
 * @framerIntrinsicWidth 800
 * @framerIntrinsicHeight 600
 */
export default function InteractiveCanvas(props) {
    const {
        backgroundColor = "#f0f0f0",
        physicsBackgroundColor = "#e8f4f8",
        circleColor = "#3b82f6",
        textColor = "#2563eb",
        rectangleColor = "#10b981",
        hoverColor = "#00ff00",
        selectedColor = "#ff00ff",
        moveableColor = "#ff0000",
        strokeColor = "#000000",
        strokeWidth = 2,
        selectedStrokeWidth = 3,
        moveableStrokeWidth = 4,
        overlapColor2 = "#ff6b35",
        overlapColor3 = "#ff3535",
        overlapColor4 = "#ff0000",
        minRadius = 20,
        maxRadius = 100,
        initialRadius = 40,
        fontSize = 32,
        movementSpeed = 15,
        gravity = 0.5,
        friction = 0.98,
        bounciness = 0.7,
        style,
        showInstructions = true,
        grainEnabled = false,
        grainBlendMode = "overlay",
        grainSize = 2,
        grainScale = 1,
        grainMovementSpeed = 1,
        enableScreenshot = true,
        screenshotIcon = "/camera-icon.svg",
        screenshotWidth = 1920,
        canvasPadding = 10,
    } = props

    const containerRef = useRef<HTMLDivElement>(null)
    const canvasRef = useRef<HTMLCanvasElement>(null)
    const grainCanvasRef = useRef<HTMLCanvasElement | null>(null)
    const grainOffsetRef = useRef({ x: 0, y: 0 })

    const animationFrameRef = useRef<number>()
    const mouseInteractionTimeoutRef = useRef<NodeJS.Timeout>()

    const [elements, setElements] = useState<Element[]>([])
    const [selectedElementIndex, setSelectedElementIndex] = useState<number>(-1)
    const [moveableElementIndex, setMoveableElementIndex] = useState<number>(-1)
    const [hoverElementId, setHoverElementId] = useState<string | null>(null)
    const [keyboardMode, setKeyboardMode] = useState(false)
    const [dragOffset, setDragOffset] = useState<{ x: number; y: number }>({
        x: 0,
        y: 0,
    })
    const [physicsActive, setPhysicsActive] = useState(false)
    const [isPhysicsPaused, setIsPhysicsPaused] = useState(false)

    const [isCreatingElement, setIsCreatingElement] = useState(false)
    const [creationStart, setCreationStart] = useState<{
        x: number
        y: number
    } | null>(null)
    const creatingElementId = useRef<string | null>(null)
    const [gravityDirection, setGravityDirection] = useState<
        "down" | "up" | "left" | "right"
    >("down")

    const [isPinching, setIsPinching] = useState(false)
    const [pinchStartDistance, setPinchStartDistance] = useState(0)
    const [pinchStartRadius, setPinchStartRadius] = useState(0)
    const [pinchElementIndex, setPinchElementIndex] = useState(-1)

    const [isClearing, setIsClearing] = useState(false)
    const [wasPhysicsActiveBeforeClearing, setWasPhysicsActiveBeforeClearing] =
        useState(false)
    const [lastUsedRadius, setLastUsedRadius] = useState(initialRadius)
    const [isDraggingSelected, setIsDraggingSelected] = useState(false)

    const generateId = () => Math.random().toString(36).substr(2, 9)
    const distance = (x1: number, y1: number, x2: number, y2: number) => {
        return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
    }
    const getTouchDistance = (touch1: Touch, touch2: Touch) => {
        const dx = touch2.clientX - touch1.clientX
        const dy = touch2.clientY - touch1.clientY
        return Math.sqrt(dx * dx + dy * dy)
    }
    const getTouchCenter = (touch1: Touch, touch2: Touch) => {
        const rect = canvasRef.current?.getBoundingClientRect()
        if (!rect) return { x: 0, y: 0 }
        return {
            x: (touch1.clientX + touch2.clientX) / 2 - rect.left,
            y: (touch1.clientY + touch2.clientY) / 2 - rect.top,
        }
    }

    const getTextDimensions = useCallback(
        (text: string, currentFontSize: number) => {
            const tempCanvas = document.createElement("canvas")
            const ctx = tempCanvas.getContext("2d")
            if (!ctx) return { width: 0, height: 0 }
            ctx.font = `${currentFontSize}px Arial`
            const metrics = ctx.measureText(text)
            return { width: metrics.width, height: currentFontSize }
        },
        []
    )

    const calculateCenterOfMass = useCallback(() => {
        if (elements.length === 0) {
            const canvas = canvasRef.current
            if (!canvas) return { x: 400, y: 300 }
            const rect = canvas.getBoundingClientRect()
            return { x: rect.width / 2, y: rect.height / 2 }
        }
        let totalMass = 0,
            weightedX = 0,
            weightedY = 0
        elements.forEach((element) => {
            const mass = element.mass || element.radius / 10
            totalMass += mass
            weightedX += element.x * mass
            weightedY += element.y * mass
        })
        return { x: weightedX / totalMass, y: weightedY / totalMass }
    }, [elements])

    const circlesOverlap = useCallback((circle1: Element, circle2: Element) => {
        if (circle1.type !== "circle" || circle2.type !== "circle") return false
        return (
            distance(circle1.x, circle1.y, circle2.x, circle2.y) <
            circle1.radius + circle2.radius
        )
    }, [])

    const checkRectOverlap = useCallback((r1: Element, r2: Element) => {
        if (
            r1.type !== "rectangle" ||
            r2.type !== "rectangle" ||
            !r1.width ||
            !r1.height ||
            !r2.width ||
            !r2.height
        )
            return false
        return (
            r1.x - r1.width / 2 < r2.x + r2.width / 2 &&
            r1.x + r1.width / 2 > r2.x - r2.width / 2 &&
            r1.y - r1.height / 2 < r2.y + r2.height / 2 &&
            r1.y + r1.height / 2 > r2.y - r2.height / 2
        )
    }, [])

    // NEW: Check circle-rectangle overlap
    const checkCircleRectOverlap = useCallback(
        (circle: Element, rect: Element) => {
            if (
                circle.type !== "circle" ||
                rect.type !== "rectangle" ||
                !rect.width ||
                !rect.height
            )
                return false

            // Find the closest point on the rectangle to the circle center
            const closestX = Math.max(
                rect.x - rect.width / 2,
                Math.min(circle.x, rect.x + rect.width / 2)
            )
            const closestY = Math.max(
                rect.y - rect.height / 2,
                Math.min(circle.y, rect.y + rect.height / 2)
            )

            // Check if the distance is less than the circle's radius
            return (
                distance(circle.x, circle.y, closestX, closestY) < circle.radius
            )
        },
        []
    )

    // Enhanced rectangle overlap check that accounts for rotation
    const checkRotatedRectOverlap = useCallback(
        (r1: Element, r2: Element) => {
            if (
                r1.type !== "rectangle" ||
                r2.type !== "rectangle" ||
                !r1.width ||
                !r1.height ||
                !r2.width ||
                !r2.height
            )
                return false

            // If neither rectangle is rotated, use simple AABB check
            if (
                (!r1.angle || Math.abs(r1.angle) < 0.01) &&
                (!r2.angle || Math.abs(r2.angle) < 0.01)
            ) {
                return checkRectOverlap(r1, r2)
            }

            // For rotated rectangles, use separating axis theorem (SAT)
            const getRotatedCorners = (rect: Element) => {
                const cos = Math.cos(rect.angle || 0)
                const sin = Math.sin(rect.angle || 0)
                const hw = rect.width! / 2
                const hh = rect.height! / 2

                const corners = [
                    { x: -hw, y: -hh },
                    { x: hw, y: -hh },
                    { x: hw, y: hh },
                    { x: -hw, y: hh },
                ]

                return corners.map((corner) => ({
                    x: rect.x + corner.x * cos - corner.y * sin,
                    y: rect.y + corner.x * sin + corner.y * cos,
                }))
            }

            const corners1 = getRotatedCorners(r1)
            const corners2 = getRotatedCorners(r2)

            // Get axes to test (perpendicular to each edge)
            const getAxes = (corners: Array<{ x: number; y: number }>) => {
                const axes = []
                for (let i = 0; i < corners.length; i++) {
                    const current = corners[i]
                    const next = corners[(i + 1) % corners.length]
                    const edge = {
                        x: next.x - current.x,
                        y: next.y - current.y,
                    }
                    // Perpendicular axis
                    axes.push({ x: -edge.y, y: edge.x })
                }
                return axes
            }

            const axes = [...getAxes(corners1), ...getAxes(corners2)]

            // Test each axis
            for (const axis of axes) {
                const length = Math.sqrt(axis.x * axis.x + axis.y * axis.y)
                if (length === 0) continue

                const normalizedAxis = {
                    x: axis.x / length,
                    y: axis.y / length,
                }

                // Project both rectangles onto this axis
                const project = (corners: Array<{ x: number; y: number }>) => {
                    let min = Number.POSITIVE_INFINITY
                    let max = Number.NEGATIVE_INFINITY
                    for (const corner of corners) {
                        const dot =
                            corner.x * normalizedAxis.x +
                            corner.y * normalizedAxis.y
                        min = Math.min(min, dot)
                        max = Math.max(max, dot)
                    }
                    return { min, max }
                }

                const proj1 = project(corners1)
                const proj2 = project(corners2)

                // Check for separation
                if (proj1.max < proj2.min || proj2.max < proj1.min) {
                    return false // Separating axis found
                }
            }

            return true // No separating axis found, rectangles overlap
        },
        [checkRectOverlap]
    )

    // Enhanced circle-rectangle overlap check that accounts for rotation
    const checkCircleRotatedRectOverlap = useCallback(
        (circle: Element, rect: Element) => {
            if (
                circle.type !== "circle" ||
                rect.type !== "rectangle" ||
                !rect.width ||
                !rect.height
            )
                return false

            // If rectangle is not rotated, use simple check
            if (!rect.angle || Math.abs(rect.angle) < 0.01) {
                return checkCircleRectOverlap(circle, rect)
            }

            // Transform circle center to rectangle's local coordinate system
            const cos = Math.cos(-rect.angle)
            const sin = Math.sin(-rect.angle)
            const dx = circle.x - rect.x
            const dy = circle.y - rect.y

            const localX = dx * cos - dy * sin
            const localY = dx * sin + dy * cos

            // Now check against axis-aligned rectangle
            const closestX = Math.max(
                -rect.width / 2,
                Math.min(localX, rect.width / 2)
            )
            const closestY = Math.max(
                -rect.height / 2,
                Math.min(localY, rect.height / 2)
            )

            const distanceSquared =
                (localX - closestX) ** 2 + (localY - closestY) ** 2
            return distanceSquared < circle.radius ** 2
        },
        [checkCircleRectOverlap]
    )

    const isPointInRotatedRect = useCallback(
        (x: number, y: number, rect: Element) => {
            if (rect.type !== "rectangle" || !rect.width || !rect.height)
                return false

            if (!rect.angle || Math.abs(rect.angle) < 0.01) {
                // Simple axis-aligned check
                return (
                    x >= rect.x - rect.width / 2 &&
                    x <= rect.x + rect.width / 2 &&
                    y >= rect.y - rect.height / 2 &&
                    y <= rect.y + rect.height / 2
                )
            }

            // Transform point to rectangle's local space
            const cos = Math.cos(-rect.angle)
            const sin = Math.sin(-rect.angle)
            const dx = x - rect.x
            const dy = y - rect.y
            const localX = dx * cos - dy * sin
            const localY = dx * sin + dy * cos

            return (
                Math.abs(localX) <= rect.width / 2 &&
                Math.abs(localY) <= rect.height / 2
            )
        },
        []
    )

    const getOverlapColor = useCallback(
        (elementCount: number) => {
            if (elementCount === 2) return overlapColor2 // 2 elements overlapping
            if (elementCount === 3) return overlapColor3 // 3 elements overlapping
            return overlapColor4 // 4+ elements overlapping
        },
        [overlapColor2, overlapColor3, overlapColor4]
    )

    const countCharacterOverlaps = useCallback(
        (
            charX: number,
            charY: number,
            charWidth: number,
            charHeight: number,
            allElements: Element[],
            excludeId: string
        ): number => {
            let overlapCount = 0
            allElements.forEach((otherElement) => {
                if (otherElement.id === excludeId) return

                if (otherElement.type === "circle") {
                    const closestX = Math.max(
                        charX - charWidth / 2,
                        Math.min(otherElement.x, charX + charWidth / 2)
                    )
                    const closestY = Math.max(
                        charY - charHeight / 2,
                        Math.min(otherElement.y, charY + charHeight / 2)
                    )
                    if (
                        distance(
                            otherElement.x,
                            otherElement.y,
                            closestX,
                            closestY
                        ) < otherElement.radius
                    ) {
                        overlapCount++
                    }
                } else if (otherElement.type === "rectangle") {
                    const rectHalfWidth = otherElement.width! / 2
                    const rectHalfHeight = otherElement.height! / 2
                    const charHalfWidth = charWidth / 2
                    const charHalfHeight = charHeight / 2

                    if (
                        charX - charHalfWidth <
                            otherElement.x + rectHalfWidth &&
                        charX + charHalfWidth >
                            otherElement.x - rectHalfWidth &&
                        charY - charHalfHeight <
                            otherElement.y + rectHalfHeight &&
                        charY + charHalfHeight > otherElement.y - rectHalfHeight
                    ) {
                        overlapCount++
                    }
                } else if (otherElement.type === "text" && otherElement.text) {
                    const otherTextDims = getTextDimensions(
                        otherElement.text,
                        otherElement.fontSize || fontSize
                    )
                    const otherRect = {
                        left: otherElement.x - otherTextDims.width / 2,
                        right: otherElement.x + otherTextDims.width / 2,
                        top: otherElement.y - otherTextDims.height / 2,
                        bottom: otherElement.y + otherTextDims.height / 2,
                    }
                    const charRect = {
                        left: charX - charWidth / 2,
                        right: charX + charWidth / 2,
                        top: charY - charHeight / 2,
                        bottom: charY + charHeight / 2,
                    }
                    if (
                        !(
                            charRect.right < otherRect.left ||
                            otherRect.right < charRect.left ||
                            charRect.bottom < otherRect.top ||
                            otherRect.bottom < charRect.bottom
                        )
                    ) {
                        overlapCount++
                    }
                }
            })
            return overlapCount
        },
        [getTextDimensions, fontSize]
    )

    const findElementAt = useCallback(
        (x: number, y: number): { element: Element; index: number } | null => {
            for (let i = elements.length - 1; i >= 0; i--) {
                const element = elements[i]
                if (element.type === "circle") {
                    if (distance(x, y, element.x, element.y) <= element.radius)
                        return { element, index: i }
                } else if (element.type === "text" && element.text) {
                    const dims = getTextDimensions(
                        element.text,
                        element.fontSize || fontSize
                    )
                    if (
                        x >= element.x - dims.width / 2 &&
                        x <= element.x + dims.width / 2 &&
                        y >= element.y - dims.height / 2 &&
                        y <= element.y + dims.height / 2
                    )
                        return { element, index: i }
                } else if (element.type === "rectangle") {
                    if (
                        x >= element.x - element.width! / 2 &&
                        x <= element.x + element.width! / 2 &&
                        y >= element.y - element.height! / 2 &&
                        y <= element.y + element.height! / 2
                    )
                        return { element, index: i }
                }
            }
            return null
        },
        [elements, getTextDimensions, fontSize]
    )

    const findMostEmptyArea = useCallback(
        (newElementRadius: number = initialRadius) => {
            const canvas = canvasRef.current
            if (!canvas) return { x: 400, y: 300 }
            const rect = canvas.getBoundingClientRect()
            const effectiveWidth = rect.width - 2 * canvasPadding
            const effectiveHeight = rect.height - 2 * canvasPadding
            const offsetX = canvasPadding
            const offsetY = canvasPadding
            const canvasCenter = {
                x: offsetX + effectiveWidth / 2,
                y: offsetY + effectiveHeight / 2,
            }
            const currentCenterOfMass = calculateCenterOfMass()
            const baseGridSize = Math.max(30, newElementRadius * 1.2)
            const gridSize =
                elements.length > 20 ? baseGridSize * 0.7 : baseGridSize
            const cols = Math.floor(effectiveWidth / gridSize)
            const rows = Math.floor(effectiveHeight / gridSize)
            let bestScore = Number.POSITIVE_INFINITY
            let bestX = offsetX + effectiveWidth / 2
            let bestY = offsetY + effectiveHeight / 2
            const searchPasses = elements.length > 15 ? 2 : 1

            for (let pass = 0; pass < searchPasses; pass++) {
                const margin =
                    pass === 0 ? newElementRadius + 15 : newElementRadius + 5
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const centerX = col * gridSize + gridSize / 2 + offsetX
                        const centerY = row * gridSize + gridSize / 2 + offsetY
                        if (
                            centerX < offsetX + margin ||
                            centerX > offsetX + effectiveWidth - margin ||
                            centerY < offsetY + margin ||
                            centerY > offsetY + effectiveHeight - margin
                        )
                            continue
                        let overlapPenalty = 0,
                            minDistanceToAnyElement = Number.POSITIVE_INFINITY
                        elements.forEach((element) => {
                            const dist = distance(
                                centerX,
                                centerY,
                                element.x,
                                element.y
                            )
                            minDistanceToAnyElement = Math.min(
                                minDistanceToAnyElement,
                                dist
                            )
                            const minAllowedDist =
                                element.radius +
                                newElementRadius +
                                (pass === 0 ? 20 : 10)
                            if (dist < minAllowedDist)
                                overlapPenalty +=
                                    Math.pow(minAllowedDist - dist, 2) *
                                    (pass === 0 ? 100 : 50)
                        })
                        if (pass === 0 && overlapPenalty > 0) continue
                        const newMass = newElementRadius / 10
                        const totalMass =
                            elements.reduce(
                                (sum, el) => sum + (el.mass || el.radius / 10),
                                0
                            ) + newMass
                        let balanceBonus = 0
                        if (totalMass > 0) {
                            const currentTotalMass = totalMass - newMass
                            const newCenterOfMass = {
                                x:
                                    currentTotalMass > 0
                                        ? (currentCenterOfMass.x *
                                              currentTotalMass +
                                              centerX * newMass) /
                                          totalMass
                                        : centerX,
                                y:
                                    currentTotalMass > 0
                                        ? (currentCenterOfMass.y *
                                              currentTotalMass +
                                              centerY * newMass) /
                                          totalMass
                                        : centerY,
                            }
                            const currentDistFromCenter = distance(
                                currentCenterOfMass.x,
                                currentCenterOfMass.y,
                                canvasCenter.x,
                                canvasCenter.y
                            )
                            const newDistFromCenter = distance(
                                newCenterOfMass.x,
                                newCenterOfMass.y,
                                canvasCenter.x,
                                canvasCenter.y
                            )
                            balanceBonus = Math.max(
                                0,
                                (currentDistFromCenter - newDistFromCenter) * 2
                            )
                        }
                        const spreadBonus = Math.min(
                            minDistanceToAnyElement * 0.1,
                            50
                        )
                        const totalScore =
                            overlapPenalty -
                            balanceBonus -
                            spreadBonus +
                            Math.random() * 5
                        if (totalScore < bestScore) {
                            bestScore = totalScore
                            bestX = centerX
                            bestY = centerY
                        }
                    }
                }
                if (bestScore < 1000) break
            }
            return { x: bestX, y: bestY }
        },
        [elements, initialRadius, calculateCenterOfMass, canvasPadding]
    )

    const getCanvasCoordinates = (e: MouseEvent | TouchEvent) => {
        const rect = canvasRef.current?.getBoundingClientRect()
        if (!rect) return { x: 0, y: 0 }
        let clientX, clientY
        if (e instanceof MouseEvent) {
            clientX = e.clientX
            clientY = e.clientY
        } else {
            clientX = e.touches[0]?.clientX || e.changedTouches[0]?.clientX || 0
            clientY = e.touches[0]?.clientY || e.changedTouches[0]?.clientY || 0
        }
        return { x: clientX - rect.left, y: clientY - rect.top }
    }

    const getSelectedElement = useCallback(
        () =>
            selectedElementIndex >= 0 && selectedElementIndex < elements.length
                ? elements[selectedElementIndex]
                : null,
        [elements, selectedElementIndex]
    )
    const getMoveableElement = useCallback(
        () =>
            moveableElementIndex >= 0 && moveableElementIndex < elements.length
                ? elements[moveableElementIndex]
                : null,
        [elements, moveableElementIndex]
    )

    const findNearestElementInDirection = useCallback(
        (direction: "left" | "right" | "up" | "down") => {
            const currentElement = getSelectedElement()
            if (elements.length <= 1) return -1
            if (!currentElement) return 0
            const candidates: Array<{
                index: number
                distance: number
                alignmentScore: number
            }> = []
            elements.forEach((element, index) => {
                if (element.id === currentElement.id) return
                const dx = element.x - currentElement.x,
                    dy = element.y - currentElement.y
                const dist = Math.sqrt(dx * dx + dy * dy)
                if (dist < 5) return
                let isInDirection = false,
                    alignmentScore = 0
                switch (direction) {
                    case "right":
                        isInDirection = dx > 0
                        alignmentScore = Math.abs(dy)
                        break
                    case "left":
                        isInDirection = dx < 0
                        alignmentScore = Math.abs(dy)
                        break
                    case "down":
                        isInDirection = dy > 0
                        alignmentScore = Math.abs(dx)
                        break
                    case "up":
                        isInDirection = dy < 0
                        alignmentScore = Math.abs(dx)
                        break
                }
                if (isInDirection)
                    candidates.push({ index, distance: dist, alignmentScore })
            })
            if (candidates.length === 0) return -1
            candidates.sort((a, b) =>
                Math.abs(a.alignmentScore - b.alignmentScore) > 20
                    ? a.alignmentScore - b.alignmentScore
                    : a.distance - b.distance
            )
            return candidates[0].index
        },
        [elements, getSelectedElement]
    )

    const handleMouseInteraction = useCallback(() => {
        if (keyboardMode) {
            setKeyboardMode(false)
            if (mouseInteractionTimeoutRef.current)
                clearTimeout(mouseInteractionTimeoutRef.current)
            mouseInteractionTimeoutRef.current = setTimeout(
                () => setSelectedElementIndex(-1),
                100
            )
        }
    }, [keyboardMode])

    const handleWheel = useCallback(
        (e: WheelEvent) => {
            e.preventDefault()
            const { x, y } = getCanvasCoordinates(e as any)
            const result = findElementAt(x, y)
            if (!result) return

            const { element, index } = result
            const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1
            setElements((prev) =>
                prev.map((el, idx) => {
                    if (idx !== index) return el
                    if (el.type === "circle") {
                        const newRadius = Math.max(
                            minRadius,
                            Math.min(maxRadius, el.radius * scaleFactor)
                        )
                        setLastUsedRadius(newRadius)
                        return {
                            ...el,
                            radius: newRadius,
                            mass: newRadius / 10,
                        }
                    } else if (el.type === "text") {
                        const newFontSize = Math.max(
                            16,
                            Math.min(
                                72,
                                (el.fontSize || fontSize) * scaleFactor
                            )
                        )
                        const newRadius = Math.max(newFontSize / 2, 20)
                        return {
                            ...el,
                            fontSize: newFontSize,
                            radius: newRadius,
                            mass: newRadius / 10,
                        }
                    } else if (el.type === "rectangle") {
                        const newWidth = Math.max(
                            10,
                            (el.width || 50) * scaleFactor
                        )
                        const newHeight = Math.max(
                            10,
                            (el.height || 50) * scaleFactor
                        )
                        const newRadius =
                            Math.sqrt(
                                newWidth * newWidth + newHeight * newHeight
                            ) / 2
                        return {
                            ...el,
                            width: newWidth,
                            height: newHeight,
                            radius: newRadius,
                            mass: newRadius / 10,
                        }
                    }
                    return el
                })
            )
            setMoveableElementIndex(index)
            setSelectedElementIndex(-1)
            setPhysicsActive(false)
        },
        [findElementAt, minRadius, maxRadius, fontSize, lastUsedRadius]
    )

    const updatePhysics = useCallback(() => {
        const canvas = canvasRef.current
        if (!canvas || !physicsActive || isPhysicsPaused) return

        setElements((prevElements) => {
            const newElements = [...prevElements]
            let hasMovement = false
            const rect = canvas.getBoundingClientRect()
            const logicalWidth = rect.width,
                logicalHeight = rect.height

            for (let i = 0; i < newElements.length; i++) {
                const el = newElements[i]
                if (el.state === "moveable") continue

                // Apply gravity
                switch (gravityDirection) {
                    case "down":
                        el.vy += gravity
                        break
                    case "up":
                        el.vy -= gravity
                        break
                    case "left":
                        el.vx -= gravity
                        break
                    case "right":
                        el.vx += gravity
                        break
                }

                // Apply friction
                el.vx *= friction
                el.vy *= friction

                // Add rotation physics for rectangles
                if (el.type === "rectangle") {
                    if (!el.angle) el.angle = 0
                    if (!el.angularVelocity) el.angularVelocity = 0

                    // Add some random rotation when falling
                    if (Math.abs(el.vy) > 1) {
                        el.angularVelocity += (Math.random() - 0.5) * 0.02
                    }

                    // Apply angular friction
                    el.angularVelocity *= 0.99
                    el.angle += el.angularVelocity

                    // Limit angular velocity
                    el.angularVelocity = Math.max(
                        -0.2,
                        Math.min(0.2, el.angularVelocity)
                    )
                }

                // Update position
                el.x += el.vx
                el.y += el.vy

                const halfW =
                    el.type === "rectangle" ? el.width! / 2 : el.radius
                const halfH =
                    el.type === "rectangle" ? el.height! / 2 : el.radius

                if (el.x - halfW < canvasPadding) {
                    el.x = canvasPadding + halfW
                    el.vx *= -bounciness
                }
                if (el.x + halfW > logicalWidth - canvasPadding) {
                    el.x = logicalWidth - canvasPadding - halfW
                    el.vx *= -bounciness
                }
                if (el.y - halfH < canvasPadding) {
                    el.y = canvasPadding + halfH
                    el.vy *= -bounciness
                }
                if (el.y + halfH > logicalHeight - canvasPadding) {
                    if (isClearing) continue
                    el.y = logicalHeight - canvasPadding - halfH
                    el.vy *= -bounciness
                    if (Math.abs(el.vy) < 0.5) el.vy = 0
                }
                if (Math.abs(el.vx) > 0.1 || Math.abs(el.vy) > 0.1)
                    hasMovement = true
            }

            for (let i = 0; i < newElements.length; i++) {
                for (let j = i + 1; j < newElements.length; j++) {
                    const el1 = newElements[i],
                        el2 = newElements[j]
                    if (el1.state === "moveable" || el2.state === "moveable")
                        continue
                    const dx = el2.x - el1.x,
                        dy = el2.y - el1.y
                    const dist = Math.sqrt(dx * dx + dy * dy)
                    const minDist = el1.radius + el2.radius
                    if (dist < minDist) {
                        hasMovement = true
                        const nx = dx / dist,
                            ny = dy / dist
                        const overlap = minDist - dist
                        const sepX = (overlap * nx) / 2,
                            sepY = (overlap * ny) / 2
                        el1.x -= sepX
                        el1.y -= sepY
                        el2.x += sepX
                        el2.y += sepY
                        const dvx = el2.vx - el1.vx,
                            dvy = el2.vy - el1.vy
                        const dvn = dvx * nx + dvy * ny
                        if (dvn > 0) continue
                        const impulse = (2 * dvn) / (el1.mass + el2.mass)
                        el1.vx += impulse * el2.mass * nx * bounciness
                        el1.vy += impulse * el2.mass * ny * bounciness
                        el2.vx -= impulse * el1.mass * nx * bounciness
                        el2.vy -= impulse * el1.mass * ny * bounciness
                    }
                }
            }
            if (!hasMovement && !isClearing)
                setTimeout(() => setPhysicsActive(false), 100)
            return newElements
        })
    }, [
        physicsActive,
        isPhysicsPaused,
        gravity,
        friction,
        bounciness,
        isClearing,
        gravityDirection,
        canvasPadding,
    ])

    useEffect(() => {
        if (physicsActive) {
            const animate = () => {
                updatePhysics()
                animationFrameRef.current = requestAnimationFrame(animate)
            }
            animationFrameRef.current = requestAnimationFrame(animate)
        } else if (animationFrameRef.current)
            cancelAnimationFrame(animationFrameRef.current)
        return () => {
            if (animationFrameRef.current)
                cancelAnimationFrame(animationFrameRef.current)
        }
    }, [physicsActive, updatePhysics])

    useEffect(() => {
        if (isClearing && elements.length > 0) {
            const canvas = canvasRef.current
            if (!canvas) return
            const rect = canvas.getBoundingClientRect()
            if (elements.every((el) => el.y - el.radius > rect.height)) {
                setElements([])
                setIsClearing(false)
                setSelectedElementIndex(-1)
                setMoveableElementIndex(-1)
                setHoverElementId(null)
                if (!wasPhysicsActiveBeforeClearing) setPhysicsActive(false)
            }
        }
    }, [elements, isClearing, wasPhysicsActiveBeforeClearing])

    const splitWordsIntoCharacters = useCallback(() => {
        setElements((prev) => {
            const newElements: Element[] = []
            prev.forEach((el) => {
                if (el.type === "text" && el.text && el.text.length > 1) {
                    const chars = el.text.split("")
                    const charSpacing = (el.fontSize || fontSize) * 0.6
                    const startX = el.x - ((chars.length - 1) * charSpacing) / 2
                    chars.forEach((char, index) => {
                        newElements.push({
                            ...el,
                            id: generateId(),
                            x: startX + index * charSpacing,
                            text: char,
                            vx: (Math.random() - 0.5) * 2,
                            vy: Math.random() * -2,
                            mass: (el.fontSize || fontSize) / 20,
                        })
                    })
                } else {
                    newElements.push({
                        ...el,
                        vx: (Math.random() - 0.5) * 2,
                        vy: Math.random() * -2,
                        mass: el.radius / 10,
                    })
                }
            })
            return newElements
        })
    }, [fontSize])

    const handleKeyDown = useCallback(
        (e: KeyboardEvent) => {
            const canvas = canvasRef.current
            if (!canvas) return
            setKeyboardMode(true)
            if (mouseInteractionTimeoutRef.current)
                clearTimeout(mouseInteractionTimeoutRef.current)

            console.log(
                `Key: ${e.key}, Code: ${e.code}, Shift: ${e.shiftKey}, Ctrl: ${e.ctrlKey}, Meta: ${e.metaKey}`
            )

            const moveableElement = getMoveableElement()
            const selectedElement = getSelectedElement()
            const rect = canvas.getBoundingClientRect()

            const moveSelectedOrMoveable = (dx: number, dy: number) => {
                const targetIndex =
                    moveableElementIndex !== -1
                        ? moveableElementIndex
                        : selectedElementIndex
                if (targetIndex !== -1) {
                    setElements((prev) =>
                        prev.map((el, idx) => {
                            if (idx === targetIndex) {
                                const newX = el.x + dx
                                const newY = el.y + dy
                                const halfW =
                                    el.type === "rectangle"
                                        ? el.width! / 2
                                        : el.radius
                                const halfH =
                                    el.type === "rectangle"
                                        ? el.height! / 2
                                        : el.radius
                                return {
                                    ...el,
                                    x: Math.max(
                                        canvasPadding + halfW,
                                        Math.min(
                                            rect.width - canvasPadding - halfW,
                                            newX
                                        )
                                    ),
                                    y: Math.max(
                                        canvasPadding + halfH,
                                        Math.min(
                                            rect.height - canvasPadding - halfH,
                                            newY
                                        )
                                    ),
                                }
                            }
                            return el
                        })
                    )
                }
            }

            switch (e.key) {
                case "ArrowUp":
                    e.preventDefault()
                    physicsActive
                        ? setGravityDirection("up")
                        : moveSelectedOrMoveable(0, -movementSpeed) ||
                          setSelectedElementIndex(
                              findNearestElementInDirection("up")
                          )
                    break
                case "ArrowDown":
                    e.preventDefault()
                    physicsActive
                        ? setGravityDirection("down")
                        : moveSelectedOrMoveable(0, movementSpeed) ||
                          setSelectedElementIndex(
                              findNearestElementInDirection("down")
                          )
                    break
                case "ArrowLeft":
                    e.preventDefault()
                    physicsActive
                        ? setGravityDirection("left")
                        : moveSelectedOrMoveable(-movementSpeed, 0) ||
                          setSelectedElementIndex(
                              findNearestElementInDirection("left")
                          )
                    break
                case "ArrowRight":
                    e.preventDefault()
                    physicsActive
                        ? setGravityDirection("right")
                        : moveSelectedOrMoveable(movementSpeed, 0) ||
                          setSelectedElementIndex(
                              findNearestElementInDirection("right")
                          )
                    break
                case " ":
                    e.preventDefault()
                    if (physicsActive) setIsPhysicsPaused(true)
                    else if (moveableElement) setMoveableElementIndex(-1)
                    else if (selectedElement) {
                        setMoveableElementIndex(selectedElementIndex)
                        setSelectedElementIndex(-1)
                    }
                    break
                case "Enter":
                case "Return":
                    e.preventDefault()
                    if (elements.length > 0) {
                        if (physicsActive) setPhysicsActive(false)
                        else {
                            splitWordsIntoCharacters()
                            setPhysicsActive(true)
                        }
                    }
                    break
                case "Escape":
                    e.preventDefault()
                    if (elements.length > 0) {
                        setIsClearing(true)
                        setWasPhysicsActiveBeforeClearing(physicsActive)
                        if (!physicsActive) {
                            setElements((prev) =>
                                prev.map((el) => ({
                                    ...el,
                                    vx: (Math.random() - 0.5) * 2,
                                    vy: Math.random() * -2,
                                    mass: el.radius / 10,
                                }))
                            )
                            setPhysicsActive(true)
                        }
                        setSelectedElementIndex(-1)
                        setMoveableElementIndex(-1)
                    }
                    break
                case "Delete":
                case "Backspace": {
                    e.preventDefault()
                    const targetIndex =
                        moveableElementIndex !== -1
                            ? moveableElementIndex
                            : selectedElementIndex
                    if (
                        moveableElement &&
                        moveableElement.type === "text" &&
                        moveableElement.text &&
                        e.key === "Backspace"
                    ) {
                        if (moveableElement.text.length > 1) {
                            setElements((prev) =>
                                prev.map((el, idx) =>
                                    idx === moveableElementIndex
                                        ? { ...el, text: el.text!.slice(0, -1) }
                                        : el
                                )
                            )
                        } else if (targetIndex !== -1) {
                            setElements((prev) =>
                                prev.filter((_, idx) => idx !== targetIndex)
                            )
                            setMoveableElementIndex(-1)
                            setSelectedElementIndex(-1)
                        }
                    } else if (targetIndex !== -1) {
                        setElements((prev) =>
                            prev.filter((_, idx) => idx !== targetIndex)
                        )
                        setMoveableElementIndex(-1)
                        setSelectedElementIndex(-1)
                    }
                    break
                }
                default: {
                    const char = e.key
                    if (char.length !== 1 || e.ctrlKey || e.metaKey) break

                    const targetElement =
                        moveableElement || (keyboardMode && selectedElement)
                    const canvas = canvasRef.current
                    if (!canvas) break
                    const canvasW = canvas.width
                    const canvasH = canvas.height

                    if (/^[0-9]$/.test(char)) {
                        e.preventDefault()
                        const n = char === "0" ? 10 : Number(char)

                        console.log(
                            `Key pressed: ${char}, Shift: ${e.shiftKey}, Number: ${n}`
                        ) // Debug log

                        if (e.shiftKey && /^[0-9]$/.test(char)) {
                            e.preventDefault()
                            const n = char === "0" ? 10 : Number(char)

                            console.log(`Creating rectangle with Shift+${char}`)

                            const baseSize =
                                minRadius +
                                (n - 1) * ((maxRadius - minRadius) / 9)
                            const aspectRatio = 0.7 + Math.random() * 0.6
                            const w = baseSize * aspectRatio
                            const h = baseSize / aspectRatio
                            const r = Math.hypot(w, h) / 2
                            const pos = findMostEmptyArea(r)

                            const newRect: Element = {
                                id: generateId(),
                                x: pos.x,
                                y: pos.y,
                                radius: r,
                                color: rectangleColor,
                                type: "rectangle",
                                width: w,
                                height: h,
                                state: "default",
                                vx: 0,
                                vy: 0,
                                mass: r / 10,
                                angle: 0,
                                angularVelocity: 0,
                            }

                            setElements((p) => [...p, newRect])
                            setSelectedElementIndex(-1)
                            setMoveableElementIndex(-1)
                            return
                        }
                        // JUST NUMBER (NO SHIFT) - existing circle/resize logic
                        if (targetElement) {
                            if (targetElement.type === "circle") {
                                const r = Math.max(
                                    minRadius,
                                    Math.min(
                                        maxRadius,
                                        minRadius +
                                            (n - 1) *
                                                ((maxRadius - minRadius) / 9)
                                    )
                                )
                                setElements((p) =>
                                    p.map((el) =>
                                        el.id === targetElement.id
                                            ? {
                                                  ...el,
                                                  radius: r,
                                                  mass: r / 10,
                                              }
                                            : el
                                    )
                                )
                                setLastUsedRadius(r)
                            } else if (targetElement.type === "text") {
                                const newFontSizeVal = Math.max(
                                    16,
                                    Math.min(72, 16 + (n - 1) * 6)
                                )
                                const newTextRadius = Math.max(
                                    newFontSizeVal / 2,
                                    20
                                )
                                setElements((p) =>
                                    p.map((el) =>
                                        el.id === targetElement.id
                                            ? {
                                                  ...el,
                                                  fontSize: newFontSizeVal,
                                                  radius: newTextRadius,
                                                  mass: newTextRadius / 10,
                                              }
                                            : el
                                    )
                                )
                            } else if (targetElement.type === "rectangle") {
                                const scaleFactor = 1 + (n - 5) * 0.1
                                const w = Math.max(
                                    10,
                                    Math.min(
                                        canvasW - 2 * canvasPadding,
                                        (targetElement.width || 50) *
                                            scaleFactor
                                    )
                                )
                                const h = Math.max(
                                    10,
                                    Math.min(
                                        canvasH - 2 * canvasPadding,
                                        (targetElement.height || 50) *
                                            scaleFactor
                                    )
                                )
                                const r = Math.hypot(w, h) / 2
                                setElements((p) =>
                                    p.map((el) =>
                                        el.id === targetElement.id
                                            ? {
                                                  ...el,
                                                  width: w,
                                                  height: h,
                                                  radius: r,
                                                  mass: r / 10,
                                              }
                                            : el
                                    )
                                )
                            }
                        } else {
                            // Create NEW circle
                            const r = Math.max(
                                minRadius,
                                Math.min(
                                    maxRadius,
                                    minRadius +
                                        (n - 1) * ((maxRadius - minRadius) / 9)
                                )
                            )
                            setLastUsedRadius(r)
                            const pos = findMostEmptyArea(r)
                            const circ: Element = {
                                id: generateId(),
                                x: pos.x,
                                y: pos.y,
                                radius: r,
                                color: circleColor,
                                type: "circle",
                                state: "default",
                                vx: 0,
                                vy: 0,
                                mass: r / 10,
                            }
                            setElements((p) => [...p, circ])
                            setSelectedElementIndex(-1)
                            setMoveableElementIndex(-1)
                        }
                        break
                    }

                    if (moveableElement && moveableElement.type === "text") {
                        e.preventDefault()
                        setElements((p) =>
                            p.map((el, i) =>
                                i === moveableElementIndex
                                    ? { ...el, text: (el.text || "") + char }
                                    : el
                            )
                        )
                    } else if (/^[a-zA-Z]$/.test(char)) {
                        e.preventDefault()
                        const rad = Math.max(fontSize / 2, 20)
                        const pos = findMostEmptyArea(rad)
                        const txt: Element = {
                            id: generateId(),
                            x: pos.x,
                            y: pos.y,
                            radius: rad,
                            color: textColor,
                            type: "text",
                            text: char,
                            fontSize: fontSize,
                            state: "moveable",
                            vx: 0,
                            vy: 0,
                            mass: rad / 10,
                        }
                        setElements((prevElements) => {
                            const newElements = [...prevElements, txt]
                            setMoveableElementIndex(newElements.length - 1)
                            return newElements
                        })
                        setSelectedElementIndex(-1)
                    }
                    break
                }
            }
        },
        [
            elements,
            selectedElementIndex,
            moveableElementIndex,
            movementSpeed,
            initialRadius,
            circleColor,
            textColor,
            rectangleColor,
            minRadius,
            maxRadius,
            physicsActive,
            getSelectedElement,
            getMoveableElement,
            findNearestElementInDirection,
            findMostEmptyArea,
            lastUsedRadius,
            fontSize,
            splitWordsIntoCharacters,
            keyboardMode,
            isPhysicsPaused,
            canvasPadding,
        ]
    )

    const handleKeyUp = useCallback(
        (e: KeyboardEvent) => {
            if (e.key === " " && physicsActive && isPhysicsPaused) {
                e.preventDefault()
                setIsPhysicsPaused(false)
            }
        },
        [physicsActive, isPhysicsPaused]
    )

    useEffect(() => {
        setElements((prev) =>
            prev.map((element, index) => {
                let state: Element["state"] = "default"
                if (index === moveableElementIndex) state = "moveable"
                else if (index === selectedElementIndex && keyboardMode)
                    state = "selected"
                else if (element.id === hoverElementId && !keyboardMode)
                    state = "selected"
                return { ...element, state }
            })
        )
    }, [
        selectedElementIndex,
        moveableElementIndex,
        hoverElementId,
        keyboardMode,
    ])

    // Centralized drawScene function for reuse in screenshot
    const drawScene = useCallback(
        (
            ctx: CanvasRenderingContext2D,
            renderWidth: number,
            renderHeight: number,
            scaleFactor = 1
        ) => {
            ctx.save()
            ctx.scale(scaleFactor, scaleFactor)

            const scaledStroke = (w: number) =>
                Math.max(1, w * (scaleFactor > 1 ? 1 / scaleFactor : 1))

            const currentPhysicsActive = physicsActive && !isPhysicsPaused
            ctx.fillStyle = currentPhysicsActive
                ? physicsBackgroundColor
                : backgroundColor
            ctx.fillRect(
                0,
                0,
                renderWidth / scaleFactor,
                renderHeight / scaleFactor
            )

            // 1. Draw CIRCLES
            elements.forEach((element) => {
                if (element.type === "circle") {
                    ctx.save()
                    ctx.translate(element.x, element.y)
                    let strokeColorToUse = strokeColor
                    let lineWidth = scaledStroke(strokeWidth)
                    if (element.state === "selected") {
                        strokeColorToUse = selectedColor
                        lineWidth = scaledStroke(selectedStrokeWidth)
                    }
                    if (element.state === "moveable") {
                        strokeColorToUse = moveableColor
                        lineWidth = scaledStroke(moveableStrokeWidth)
                    }
                    ctx.strokeStyle = strokeColorToUse
                    ctx.lineWidth = lineWidth
                    ctx.fillStyle = element.color
                    ctx.beginPath()
                    ctx.arc(0, 0, element.radius, 0, 2 * Math.PI)
                    ctx.fill()
                    ctx.stroke()
                    if (
                        element.state === "selected" ||
                        element.state === "moveable"
                    ) {
                        ctx.beginPath()
                        const indicatorRadius =
                            element.radius +
                            (element.state === "selected" ? 5 : 8)
                        ctx.arc(0, 0, indicatorRadius, 0, 2 * Math.PI)
                        ctx.strokeStyle =
                            element.state === "selected"
                                ? selectedColor
                                : moveableColor
                        ctx.lineWidth = scaledStroke(
                            element.state === "selected" ? 1 : 2
                        )
                        ctx.setLineDash(
                            element.state === "selected" ? [5, 5] : [3, 3]
                        )
                        ctx.stroke()
                        ctx.setLineDash([])
                    }
                    ctx.restore()
                }
            })

            // 2. Draw RECTANGLES
            elements.forEach((element) => {
                if (
                    element.type === "rectangle" &&
                    element.width &&
                    element.height
                ) {
                    ctx.save()
                    ctx.translate(element.x, element.y)

                    // Apply rotation
                    if (element.angle) {
                        ctx.rotate(element.angle)
                    }

                    let strokeColorToUse = strokeColor
                    let lineWidth = scaledStroke(strokeWidth)
                    if (element.state === "selected") {
                        strokeColorToUse = selectedColor
                        lineWidth = scaledStroke(selectedStrokeWidth)
                    }
                    if (element.state === "moveable") {
                        strokeColorToUse = moveableColor
                        lineWidth = scaledStroke(moveableStrokeWidth)
                    }
                    ctx.strokeStyle = strokeColorToUse
                    ctx.lineWidth = lineWidth
                    ctx.fillStyle = element.color
                    ctx.fillRect(
                        -element.width / 2,
                        -element.height / 2,
                        element.width,
                        element.height
                    )
                    ctx.strokeRect(
                        -element.width / 2,
                        -element.height / 2,
                        element.width,
                        element.height
                    )
                    if (
                        element.state === "selected" ||
                        element.state === "moveable"
                    ) {
                        const padding = element.state === "selected" ? 5 : 8
                        ctx.strokeStyle =
                            element.state === "selected"
                                ? selectedColor
                                : moveableColor
                        ctx.lineWidth = scaledStroke(
                            element.state === "selected" ? 1 : 2
                        )
                        ctx.setLineDash(
                            element.state === "selected" ? [5, 5] : [3, 3]
                        )
                        ctx.strokeRect(
                            -element.width / 2 - padding,
                            -element.height / 2 - padding,
                            element.width + padding * 2,
                            element.height + padding * 2
                        )
                        ctx.setLineDash([])
                    }
                    ctx.restore()
                }
            })

            // 3. Draw CIRCLE OVERLAPS
            const circleElements = elements.filter((el) => el.type === "circle")
            if (circleElements.length >= 2) {
                for (let i = 0; i < circleElements.length; i++) {
                    for (let j = i + 1; j < circleElements.length; j++) {
                        const c1 = circleElements[i]
                        const c2 = circleElements[j]
                        if (!circlesOverlap(c1, c2)) continue
                        ctx.save()
                        ctx.beginPath()
                        ctx.arc(c1.x, c1.y, c1.radius, 0, 2 * Math.PI)
                        ctx.clip()
                        ctx.beginPath()
                        ctx.arc(c2.x, c2.y, c2.radius, 0, 2 * Math.PI)
                        ctx.fillStyle = getOverlapColor(2)
                        ctx.fill()
                        ctx.restore()
                    }
                }
            }
            if (circleElements.length >= 3) {
                for (let i = 0; i < circleElements.length; i++) {
                    for (let j = i + 1; j < circleElements.length; j++) {
                        for (let k = j + 1; k < circleElements.length; k++) {
                            const c1 = circleElements[i],
                                c2 = circleElements[j],
                                c3 = circleElements[k]
                            if (
                                !circlesOverlap(c1, c2) ||
                                !circlesOverlap(c1, c3) ||
                                !circlesOverlap(c2, c3)
                            )
                                continue
                            ctx.save()
                            ctx.beginPath()
                            ctx.arc(c1.x, c1.y, c1.radius, 0, 2 * Math.PI)
                            ctx.clip()
                            ctx.beginPath()
                            ctx.arc(c2.x, c2.y, c2.radius, 0, 2 * Math.PI)
                            ctx.clip()
                            ctx.beginPath()
                            ctx.arc(c3.x, c3.y, c3.radius, 0, 2 * Math.PI)
                            ctx.fillStyle = getOverlapColor(3)
                            ctx.fill()
                            ctx.restore()
                        }
                    }
                }
            }
            if (circleElements.length >= 4) {
                for (let i = 0; i < circleElements.length; i++) {
                    for (let j = i + 1; j < circleElements.length; j++) {
                        for (let k = j + 1; k < circleElements.length; k++) {
                            for (
                                let l = k + 1;
                                l < circleElements.length;
                                l++
                            ) {
                                const c1 = circleElements[i],
                                    c2 = circleElements[j],
                                    c3 = circleElements[k],
                                    c4 = circleElements[l]
                                if (
                                    !circlesOverlap(c1, c2) ||
                                    !circlesOverlap(c1, c3) ||
                                    !circlesOverlap(c1, c4) ||
                                    !circlesOverlap(c2, c3) ||
                                    !circlesOverlap(c2, c4) ||
                                    !circlesOverlap(c3, c4)
                                )
                                    continue
                                ctx.save()
                                ctx.beginPath()
                                ctx.arc(c1.x, c1.y, c1.radius, 0, 2 * Math.PI)
                                ctx.clip()
                                ctx.beginPath()
                                ctx.arc(c2.x, c2.y, c2.radius, 0, 2 * Math.PI)
                                ctx.clip()
                                ctx.beginPath()
                                ctx.arc(c3.x, c3.y, c3.radius, 0, 2 * Math.PI)
                                ctx.clip()
                                ctx.beginPath()
                                ctx.arc(c4.x, c4.y, c4.radius, 0, 2 * Math.PI)
                                ctx.fillStyle = getOverlapColor(4)
                                ctx.fill()
                                ctx.restore()
                            }
                        }
                    }
                }
            }

            // 4. Draw RECTANGLE OVERLAPS using progressive clipping (like circles)
            const rectElements = elements.filter(
                (el) => el.type === "rectangle"
            )

            // 2-rectangle overlaps
            if (rectElements.length >= 2) {
                for (let i = 0; i < rectElements.length; i++) {
                    for (let j = i + 1; j < rectElements.length; j++) {
                        const r1 = rectElements[i]
                        const r2 = rectElements[j]
                        if (!checkRotatedRectOverlap(r1, r2)) continue

                        ctx.save()

                        // Create clipping path for first rectangle
                        ctx.beginPath()
                        ctx.save()
                        ctx.translate(r1.x, r1.y)
                        if (r1.angle) {
                            ctx.rotate(r1.angle)
                        }
                        ctx.rect(
                            -r1.width! / 2,
                            -r1.height! / 2,
                            r1.width!,
                            r1.height!
                        )
                        ctx.restore()
                        ctx.clip()

                        // Draw second rectangle within the clipping path
                        ctx.save()
                        ctx.translate(r2.x, r2.y)
                        if (r2.angle) {
                            ctx.rotate(r2.angle)
                        }
                        ctx.fillStyle = getOverlapColor(2)
                        ctx.fillRect(
                            -r2.width! / 2,
                            -r2.height! / 2,
                            r2.width!,
                            r2.height!
                        )
                        ctx.restore()

                        ctx.restore()
                    }
                }
            }

            // 3-rectangle overlaps
            if (rectElements.length >= 3) {
                for (let i = 0; i < rectElements.length; i++) {
                    for (let j = i + 1; j < rectElements.length; j++) {
                        for (let k = j + 1; k < rectElements.length; k++) {
                            const r1 = rectElements[i],
                                r2 = rectElements[j],
                                r3 = rectElements[k]
                            if (
                                !checkRotatedRectOverlap(r1, r2) ||
                                !checkRotatedRectOverlap(r1, r3) ||
                                !checkRotatedRectOverlap(r2, r3)
                            )
                                continue

                            ctx.save()

                            // Create clipping path for first rectangle
                            ctx.beginPath()
                            ctx.save()
                            ctx.translate(r1.x, r1.y)
                            if (r1.angle) {
                                ctx.rotate(r1.angle)
                            }
                            ctx.rect(
                                -r1.width! / 2,
                                -r1.height! / 2,
                                r1.width!,
                                r1.height!
                            )
                            ctx.restore()
                            ctx.clip()

                            // Create clipping path for second rectangle
                            ctx.beginPath()
                            ctx.save()
                            ctx.translate(r2.x, r2.y)
                            if (r2.angle) {
                                ctx.rotate(r2.angle)
                            }
                            ctx.rect(
                                -r2.width! / 2,
                                -r2.height! / 2,
                                r2.width!,
                                r2.height!
                            )
                            ctx.restore()
                            ctx.clip()

                            // Draw third rectangle within both clipping paths
                            ctx.save()
                            ctx.translate(r3.x, r3.y)
                            if (r3.angle) {
                                ctx.rotate(r3.angle)
                            }
                            ctx.fillStyle = getOverlapColor(3)
                            ctx.fillRect(
                                -r3.width! / 2,
                                -r3.height! / 2,
                                r3.width!,
                                r3.height!
                            )
                            ctx.restore()

                            ctx.restore()
                        }
                    }
                }
            }

            // 4+ rectangle overlaps
            if (rectElements.length >= 4) {
                for (let i = 0; i < rectElements.length; i++) {
                    for (let j = i + 1; j < rectElements.length; j++) {
                        for (let k = j + 1; k < rectElements.length; k++) {
                            for (let l = k + 1; l < rectElements.length; l++) {
                                const r1 = rectElements[i],
                                    r2 = rectElements[j],
                                    r3 = rectElements[k],
                                    r4 = rectElements[l]
                                if (
                                    !checkRotatedRectOverlap(r1, r2) ||
                                    !checkRotatedRectOverlap(r1, r3) ||
                                    !checkRotatedRectOverlap(r1, r4) ||
                                    !checkRotatedRectOverlap(r2, r3) ||
                                    !checkRotatedRectOverlap(r2, r4) ||
                                    !checkRotatedRectOverlap(r3, r4)
                                )
                                    continue

                                ctx.save()

                                // Create clipping path for first rectangle
                                ctx.beginPath()
                                ctx.save()
                                ctx.translate(r1.x, r1.y)
                                if (r1.angle) {
                                    ctx.rotate(r1.angle)
                                }
                                ctx.rect(
                                    -r1.width! / 2,
                                    -r1.height! / 2,
                                    r1.width!,
                                    r1.height!
                                )
                                ctx.restore()
                                ctx.clip()

                                // Create clipping path for second rectangle
                                ctx.beginPath()
                                ctx.save()
                                ctx.translate(r2.x, r2.y)
                                if (r2.angle) {
                                    ctx.rotate(r2.angle)
                                }
                                ctx.rect(
                                    -r2.width! / 2,
                                    -r2.height! / 2,
                                    r2.width!,
                                    r2.height!
                                )
                                ctx.restore()
                                ctx.clip()

                                // Create clipping path for third rectangle
                                ctx.beginPath()
                                ctx.save()
                                ctx.translate(r3.x, r3.y)
                                if (r3.angle) {
                                    ctx.rotate(r3.angle)
                                }
                                ctx.rect(
                                    -r3.width! / 2,
                                    -r3.height! / 2,
                                    r3.width!,
                                    r3.height!
                                )
                                ctx.restore()
                                ctx.clip()

                                // Draw fourth rectangle within all clipping paths
                                ctx.save()
                                ctx.translate(r4.x, r4.y)
                                if (r4.angle) {
                                    ctx.rotate(r4.angle)
                                }
                                ctx.fillStyle = getOverlapColor(4)
                                ctx.fillRect(
                                    -r4.width! / 2,
                                    -r4.height! / 2,
                                    r4.width!,
                                    r4.height!
                                )
                                ctx.restore()

                                ctx.restore()
                            }
                        }
                    }
                }
            }

            // 5. Draw MIXED CIRCLE-RECTANGLE OVERLAPS
            // First draw 2-element overlaps (circle + rectangle OR rectangle + circle)
            for (let i = 0; i < elements.length; i++) {
                for (let j = i + 1; j < elements.length; j++) {
                    const el1 = elements[i]
                    const el2 = elements[j]

                    if (
                        (el1.type === "circle" && el2.type === "rectangle") ||
                        (el1.type === "rectangle" && el2.type === "circle")
                    ) {
                        const circle = el1.type === "circle" ? el1 : el2
                        const rect = el1.type === "rectangle" ? el1 : el2

                        if (checkCircleRotatedRectOverlap(circle, rect)) {
                            ctx.save()

                            // Create clipping path from circle
                            ctx.beginPath()
                            ctx.arc(
                                circle.x,
                                circle.y,
                                circle.radius,
                                0,
                                2 * Math.PI
                            )
                            ctx.clip()

                            // Draw rectangle with 2-element overlap color
                            ctx.save()
                            ctx.translate(rect.x, rect.y)
                            if (rect.angle) {
                                ctx.rotate(rect.angle)
                            }
                            ctx.fillStyle = getOverlapColor(2)
                            ctx.fillRect(
                                -rect.width! / 2,
                                -rect.height! / 2,
                                rect.width!,
                                rect.height!
                            )
                            ctx.restore()

                            ctx.restore()
                        }
                    }
                }
            }

            // Then draw 3+ element overlaps for CIRCLES + RECTANGLES (multiple circles + rectangle)
            const circleElementsFiltered = elements.filter(
                (el) => el.type === "circle"
            )
            const rectElementsFiltered = elements.filter(
                (el) => el.type === "rectangle"
            )

            // 3-element overlaps: 2 circles + 1 rectangle
            if (
                circleElementsFiltered.length >= 2 &&
                rectElementsFiltered.length >= 1
            ) {
                for (let i = 0; i < circleElementsFiltered.length; i++) {
                    for (
                        let j = i + 1;
                        j < circleElementsFiltered.length;
                        j++
                    ) {
                        for (let k = 0; k < rectElementsFiltered.length; k++) {
                            const c1 = circleElementsFiltered[i]
                            const c2 = circleElementsFiltered[j]
                            const rect = rectElementsFiltered[k]

                            // Check if all three elements overlap
                            if (
                                circlesOverlap(c1, c2) &&
                                checkCircleRotatedRectOverlap(c1, rect) &&
                                checkCircleRotatedRectOverlap(c2, rect)
                            ) {
                                ctx.save()

                                // Clip to first circle
                                ctx.beginPath()
                                ctx.arc(c1.x, c1.y, c1.radius, 0, 2 * Math.PI)
                                ctx.clip()

                                // Clip to second circle
                                ctx.beginPath()
                                ctx.arc(c2.x, c2.y, c2.radius, 0, 2 * Math.PI)
                                ctx.clip()

                                // Draw rectangle with 3-element overlap color
                                ctx.save()
                                ctx.translate(rect.x, rect.y)
                                if (rect.angle) {
                                    ctx.rotate(rect.angle)
                                }
                                ctx.fillStyle = getOverlapColor(3)
                                ctx.fillRect(
                                    -rect.width! / 2,
                                    -rect.height! / 2,
                                    rect.width!,
                                    rect.height!
                                )
                                ctx.restore()

                                ctx.restore()
                            }
                        }
                    }
                }
            }

            // 4+ element overlaps: 3+ circles + 1 rectangle
            if (
                circleElementsFiltered.length >= 3 &&
                rectElementsFiltered.length >= 1
            ) {
                for (let i = 0; i < circleElementsFiltered.length; i++) {
                    for (
                        let j = i + 1;
                        j < circleElementsFiltered.length;
                        j++
                    ) {
                        for (
                            let k = j + 1;
                            k < circleElementsFiltered.length;
                            k++
                        ) {
                            for (
                                let l = 0;
                                l < rectElementsFiltered.length;
                                l++
                            ) {
                                const c1 = circleElementsFiltered[i]
                                const c2 = circleElementsFiltered[j]
                                const c3 = circleElementsFiltered[k]
                                const rect = rectElementsFiltered[l]

                                // Check if all four elements overlap
                                if (
                                    circlesOverlap(c1, c2) &&
                                    circlesOverlap(c1, c3) &&
                                    circlesOverlap(c2, c3) &&
                                    checkCircleRotatedRectOverlap(c1, rect) &&
                                    checkCircleRotatedRectOverlap(c2, rect) &&
                                    checkCircleRotatedRectOverlap(c3, rect)
                                ) {
                                    ctx.save()

                                    // Clip to first circle
                                    ctx.beginPath()
                                    ctx.arc(
                                        c1.x,
                                        c1.y,
                                        c1.radius,
                                        0,
                                        2 * Math.PI
                                    )
                                    ctx.clip()

                                    // Clip to second circle
                                    ctx.beginPath()
                                    ctx.arc(
                                        c2.x,
                                        c2.y,
                                        c2.radius,
                                        0,
                                        2 * Math.PI
                                    )
                                    ctx.clip()

                                    // Clip to third circle
                                    ctx.beginPath()
                                    ctx.arc(
                                        c3.x,
                                        c3.y,
                                        c3.radius,
                                        0,
                                        2 * Math.PI
                                    )
                                    ctx.clip()

                                    // Draw rectangle with 4+ element overlap color
                                    ctx.save()
                                    ctx.translate(rect.x, rect.y)
                                    if (rect.angle) {
                                        ctx.rotate(rect.angle)
                                    }
                                    ctx.fillStyle = getOverlapColor(4)
                                    ctx.fillRect(
                                        -rect.width! / 2,
                                        -rect.height! / 2,
                                        rect.width!,
                                        rect.height!
                                    )
                                    ctx.restore()

                                    ctx.restore()
                                }
                            }
                        }
                    }
                }
            }

            // 6. Draw MIXED RECTANGLE-CIRCLE OVERLAPS (multiple rectangles + circles)
            // 3-element overlaps: 2 rectangles + 1 circle
            if (
                rectElementsFiltered.length >= 2 &&
                circleElementsFiltered.length >= 1
            ) {
                for (let i = 0; i < rectElementsFiltered.length; i++) {
                    for (let j = i + 1; j < rectElementsFiltered.length; j++) {
                        for (
                            let k = 0;
                            k < circleElementsFiltered.length;
                            k++
                        ) {
                            const r1 = rectElementsFiltered[i]
                            const r2 = rectElementsFiltered[j]
                            const circle = circleElementsFiltered[k]

                            // Check if all three elements overlap
                            if (
                                checkRotatedRectOverlap(r1, r2) &&
                                checkCircleRotatedRectOverlap(circle, r1) &&
                                checkCircleRotatedRectOverlap(circle, r2)
                            ) {
                                ctx.save()

                                // Clip to first rectangle
                                ctx.beginPath()
                                ctx.save()
                                ctx.translate(r1.x, r1.y)
                                if (r1.angle) {
                                    ctx.rotate(r1.angle)
                                }
                                ctx.rect(
                                    -r1.width! / 2,
                                    -r1.height! / 2,
                                    r1.width!,
                                    r1.height!
                                )
                                ctx.restore()
                                ctx.clip()

                                // Clip to second rectangle
                                ctx.beginPath()
                                ctx.save()
                                ctx.translate(r2.x, r2.y)
                                if (r2.angle) {
                                    ctx.rotate(r2.angle)
                                }
                                ctx.rect(
                                    -r2.width! / 2,
                                    -r2.height! / 2,
                                    r2.width!,
                                    r2.height!
                                )
                                ctx.restore()
                                ctx.clip()

                                // Draw circle with 3-element overlap color
                                ctx.beginPath()
                                ctx.arc(
                                    circle.x,
                                    circle.y,
                                    circle.radius,
                                    0,
                                    2 * Math.PI
                                )
                                ctx.fillStyle = getOverlapColor(3)
                                ctx.fill()

                                ctx.restore()
                            }
                        }
                    }
                }
            }

            // 4+ element overlaps: 3+ rectangles + 1 circle
            if (
                rectElementsFiltered.length >= 3 &&
                circleElementsFiltered.length >= 1
            ) {
                for (let i = 0; i < rectElementsFiltered.length; i++) {
                    for (let j = i + 1; j < rectElementsFiltered.length; j++) {
                        for (
                            let k = j + 1;
                            k < rectElementsFiltered.length;
                            k++
                        ) {
                            for (
                                let l = 0;
                                l < circleElementsFiltered.length;
                                l++
                            ) {
                                const r1 = rectElementsFiltered[i]
                                const r2 = rectElementsFiltered[j]
                                const r3 = rectElementsFiltered[k]
                                const circle = circleElementsFiltered[l]

                                // Check if all four elements overlap
                                if (
                                    checkRotatedRectOverlap(r1, r2) &&
                                    checkRotatedRectOverlap(r1, r3) &&
                                    checkRotatedRectOverlap(r2, r3) &&
                                    checkCircleRotatedRectOverlap(circle, r1) &&
                                    checkCircleRotatedRectOverlap(circle, r2) &&
                                    checkCircleRotatedRectOverlap(circle, r3)
                                ) {
                                    ctx.save()

                                    // Clip to first rectangle
                                    ctx.beginPath()
                                    ctx.save()
                                    ctx.translate(r1.x, r1.y)
                                    if (r1.angle) {
                                        ctx.rotate(r1.angle)
                                    }
                                    ctx.rect(
                                        -r1.width! / 2,
                                        -r1.height! / 2,
                                        r1.width!,
                                        r1.height!
                                    )
                                    ctx.restore()
                                    ctx.clip()

                                    // Clip to second rectangle
                                    ctx.beginPath()
                                    ctx.save()
                                    ctx.translate(r2.x, r2.y)
                                    if (r2.angle) {
                                        ctx.rotate(r2.angle)
                                    }
                                    ctx.rect(
                                        -r2.width! / 2,
                                        -r2.height! / 2,
                                        r2.width!,
                                        r2.height!
                                    )
                                    ctx.restore()
                                    ctx.clip()

                                    // Clip to third rectangle
                                    ctx.beginPath()
                                    ctx.save()
                                    ctx.translate(r3.x, r3.y)
                                    if (r3.angle) {
                                        ctx.rotate(r3.angle)
                                    }
                                    ctx.rect(
                                        -r3.width! / 2,
                                        -r3.height! / 2,
                                        r3.width!,
                                        r3.height!
                                    )
                                    ctx.restore()
                                    ctx.clip()

                                    // Draw circle with 4+ element overlap color
                                    ctx.beginPath()
                                    ctx.arc(
                                        circle.x,
                                        circle.y,
                                        circle.radius,
                                        0,
                                        2 * Math.PI
                                    )
                                    ctx.fillStyle = getOverlapColor(4)
                                    ctx.fill()

                                    ctx.restore()
                                }
                            }
                        }
                    }
                }
            }

            // 7. Draw TEXT
            elements.forEach((element) => {
                if (element.type === "text" && element.text) {
                    ctx.save()
                    ctx.translate(element.x, element.y)
                    let strokeColorToUse = strokeColor
                    let lineWidth = scaledStroke(strokeWidth)
                    if (element.state === "selected") {
                        strokeColorToUse = selectedColor
                        lineWidth = scaledStroke(selectedStrokeWidth)
                    }
                    if (element.state === "moveable") {
                        strokeColorToUse = moveableColor
                        lineWidth = scaledStroke(moveableStrokeWidth)
                    }
                    ctx.strokeStyle = strokeColorToUse
                    ctx.lineWidth = lineWidth
                    ctx.fillStyle = element.color
                    ctx.font = `${element.fontSize || fontSize}px Arial`
                    ctx.textAlign = "center"
                    ctx.textBaseline = "middle"
                    const chars = element.text.split("")
                    const charSpacing = (element.fontSize || fontSize) * 0.6
                    const textWidth = chars.reduce(
                        (sum, char) => sum + ctx.measureText(char).width * 0.6,
                        0
                    )
                    const startX =
                        -textWidth / 2 +
                        (ctx.measureText(chars[0] || "").width * 0.6) / 2
                    chars.forEach((char, index) => {
                        const charRenderX = startX + index * charSpacing
                        const charWidth = ctx.measureText(char).width
                        const charHeight = element.fontSize || fontSize
                        const overlapDegree = countCharacterOverlaps(
                            element.x + charRenderX,
                            element.y,
                            charWidth,
                            charHeight,
                            elements,
                            element.id
                        )
                        ctx.fillStyle =
                            overlapDegree > 0
                                ? getOverlapColor(overlapDegree + 1)
                                : element.color
                        ctx.fillText(char, charRenderX, 0)
                    })
                    if (
                        element.state === "selected" ||
                        element.state === "moveable"
                    ) {
                        const dims = getTextDimensions(
                            element.text,
                            element.fontSize || fontSize
                        )
                        const padding = element.state === "selected" ? 5 : 8
                        ctx.strokeStyle =
                            element.state === "selected"
                                ? selectedColor
                                : moveableColor
                        ctx.lineWidth = scaledStroke(
                            element.state === "selected" ? 1 : 2
                        )
                        ctx.setLineDash(
                            element.state === "selected" ? [5, 5] : [3, 3]
                        )
                        ctx.strokeRect(
                            -dims.width / 2 - padding,
                            -dims.height / 2 - padding,
                            dims.width + padding * 2,
                            dims.height + padding * 2
                        )
                        ctx.setLineDash([])
                    }
                    ctx.restore()
                }
            })

            // 8. Draw GRAIN (if enabled)
            if (grainEnabled && grainCanvasRef.current && ctx) {
                ctx.save()
                ctx.globalCompositeOperation =
                    grainBlendMode as GlobalCompositeOperation
                const pattern = ctx.createPattern(
                    grainCanvasRef.current,
                    "repeat"
                )
                if (pattern) {
                    ctx.fillStyle = pattern
                    ctx.translate(
                        grainOffsetRef.current.x,
                        grainOffsetRef.current.y
                    )
                    ctx.fillRect(
                        -grainOffsetRef.current.x,
                        -grainOffsetRef.current.y,
                        renderWidth / scaleFactor,
                        renderHeight / scaleFactor
                    )
                }
                ctx.restore()
            }

            ctx.restore()
        },
        [
            elements,
            backgroundColor,
            physicsBackgroundColor,
            strokeColor,
            strokeWidth,
            selectedColor,
            moveableColor,
            physicsActive,
            isPhysicsPaused,
            fontSize,
            getTextDimensions,
            countCharacterOverlaps,
            circlesOverlap,
            checkRectOverlap,
            checkCircleRectOverlap,
            checkRotatedRectOverlap,
            checkCircleRotatedRectOverlap,
            getOverlapColor,
            selectedStrokeWidth,
            moveableStrokeWidth,
            grainEnabled,
            grainBlendMode,
            isPointInRotatedRect,
        ]
    )

    // Helper function for combinations (add this before the drawScene function)
    function getCombinations<T>(arr: T[], size: number): T[][] {
        if (size === 1) return arr.map((item) => [item])
        if (size === arr.length) return [arr]
        if (size > arr.length) return []

        const result: T[][] = []
        for (let i = 0; i <= arr.length - size; i++) {
            const head = arr[i]
            const tailCombos = getCombinations(arr.slice(i + 1), size - 1)
            tailCombos.forEach((combo) => result.push([head, ...combo]))
        }
        return result
    }

    const draw = useCallback(() => {
        const canvas = canvasRef.current
        if (!canvas) return
        const ctx = canvas.getContext("2d")
        if (!ctx) return
        const rect = canvas.getBoundingClientRect()
        drawScene(ctx, rect.width, rect.height)
    }, [drawScene])

    // Screenshot function
    const handleScreenshotClick = useCallback(() => {
        const mainCanvas = canvasRef.current
        if (!mainCanvas) return

        const offscreenCanvas = document.createElement("canvas")
        const aspectRatio = mainCanvas.height / mainCanvas.width
        offscreenCanvas.width = screenshotWidth
        offscreenCanvas.height = screenshotWidth * aspectRatio

        const offscreenCtx = offscreenCanvas.getContext("2d")
        if (!offscreenCtx) return

        const scale = screenshotWidth / mainCanvas.width
        drawScene(
            offscreenCtx,
            offscreenCanvas.width,
            offscreenCanvas.height,
            scale
        )

        const link = document.createElement("a")
        link.download = "interactive-canvas.png"
        link.href = offscreenCanvas.toDataURL("image/png")
        link.click()
    }, [screenshotWidth, drawScene])

    const handleMouseDown = useCallback(
        (e: MouseEvent) => {
            e.preventDefault()
            handleMouseInteraction()
            const { x, y } = getCanvasCoordinates(e)
            const result = findElementAt(x, y)
            if (result) {
                const { element, index } = result
                setSelectedElementIndex(index)
                setMoveableElementIndex(-1)
                setIsDraggingSelected(false)
                setPhysicsActive(false)
                setDragOffset({ x: x - element.x, y: y - element.y })
            } else {
                setMoveableElementIndex(-1)
                setSelectedElementIndex(-1)
                setIsDraggingSelected(false)
                const newElementId = generateId()
                let newElement: Element
                if (e.shiftKey) {
                    newElement = {
                        id: newElementId,
                        x,
                        y,
                        radius: 10,
                        width: 20,
                        height: 20,
                        color: rectangleColor,
                        type: "rectangle",
                        state: "default",
                        vx: 0,
                        vy: 0,
                        mass: 2,
                    }
                } else {
                    newElement = {
                        id: newElementId,
                        x,
                        y,
                        radius: 5,
                        color: circleColor,
                        type: "circle",
                        state: "default",
                        vx: 0,
                        vy: 0,
                        mass: 1,
                    }
                }
                setElements((prev) => [...prev, newElement])
                setIsCreatingElement(true)
                setCreationStart({ x, y })
                creatingElementId.current = newElementId
            }
        },
        [findElementAt, handleMouseInteraction, circleColor, rectangleColor]
    )

    const handleMouseMove = useCallback(
        (e: MouseEvent) => {
            const { x, y } = getCanvasCoordinates(e)
            if (
                isCreatingElement &&
                creationStart &&
                creatingElementId.current
            ) {
                const dragDistance = distance(
                    creationStart.x,
                    creationStart.y,
                    x,
                    y
                )
                setElements((prev) =>
                    prev.map((el) => {
                        if (el.id === creatingElementId.current) {
                            if (el.type === "rectangle") {
                                const newSize = Math.max(10, dragDistance)
                                return {
                                    ...el,
                                    width: newSize,
                                    height: newSize,
                                    radius: Math.hypot(newSize, newSize) / 2,
                                    mass: (newSize * newSize) / 100,
                                }
                            } else {
                                const newRadius = Math.max(
                                    minRadius,
                                    Math.min(maxRadius, dragDistance)
                                )
                                return {
                                    ...el,
                                    radius: newRadius,
                                    mass: newRadius / 10,
                                }
                            }
                        }
                        return el
                    })
                )
            } else if (
                e.buttons === 1 &&
                selectedElementIndex !== -1 &&
                !isDraggingSelected
            ) {
                setMoveableElementIndex(selectedElementIndex)
                setSelectedElementIndex(-1)
                setIsDraggingSelected(true)
            } else if (
                moveableElementIndex !== -1 &&
                e.buttons === 1 &&
                isDraggingSelected
            ) {
                const canvas = canvasRef.current
                if (!canvas) return
                const rect = canvas.getBoundingClientRect()
                const moveableElement = elements[moveableElementIndex]
                if (moveableElement) {
                    const halfW =
                        moveableElement.type === "rectangle"
                            ? moveableElement.width! / 2
                            : moveableElement.radius
                    const halfH =
                        moveableElement.type === "rectangle"
                            ? moveableElement.height! / 2
                            : moveableElement.radius
                    const newX = Math.max(
                        halfW + canvasPadding,
                        Math.min(
                            rect.width - canvasPadding - halfW,
                            x - dragOffset.x
                        )
                    )
                    const newY = Math.max(
                        halfH + canvasPadding,
                        Math.min(
                            rect.height - canvasPadding - halfH,
                            y - dragOffset.y
                        )
                    )
                    setElements((prev) =>
                        prev.map((el, idx) =>
                            idx === moveableElementIndex
                                ? { ...el, x: newX, y: newY }
                                : el
                        )
                    )
                }
            } else {
                handleMouseInteraction()
                const result = findElementAt(x, y)
                setHoverElementId(result?.element.id || null)
            }
        },
        [
            elements,
            selectedElementIndex,
            moveableElementIndex,
            dragOffset,
            findElementAt,
            handleMouseInteraction,
            isCreatingElement,
            creationStart,
            minRadius,
            maxRadius,
            isDraggingSelected,
            canvasPadding,
        ]
    )

    const handleMouseUp = useCallback(() => {
        if (isCreatingElement && creatingElementId.current) {
            setIsCreatingElement(false)
            setCreationStart(null)
            creatingElementId.current = null
        }
        if (isDraggingSelected && moveableElementIndex !== -1) {
            setSelectedElementIndex(moveableElementIndex)
            setMoveableElementIndex(-1)
        }
        setIsDraggingSelected(false)
    }, [isCreatingElement, moveableElementIndex, isDraggingSelected])

    const handleTouchStart = useCallback(
        (e: TouchEvent) => {
            e.preventDefault()
            handleMouseInteraction()
            if (e.touches.length === 2) {
                const touch1 = e.touches[0],
                    touch2 = e.touches[1]
                const center = getTouchCenter(touch1, touch2)
                const result = findElementAt(center.x, center.y)
                if (result) {
                    const { element, index } = result
                    setIsPinching(true)
                    setPinchStartDistance(getTouchDistance(touch1, touch2))
                    setPinchStartRadius(element.radius)
                    setPinchElementIndex(index)
                    setMoveableElementIndex(index)
                    setSelectedElementIndex(-1)
                    setIsDraggingSelected(false)
                    setPhysicsActive(false)
                }
            } else if (e.touches.length === 1) {
                const { x, y } = getCanvasCoordinates(e)
                const result = findElementAt(x, y)
                if (result) {
                    const { element, index } = result
                    setSelectedElementIndex(index)
                    setMoveableElementIndex(-1)
                    setIsDraggingSelected(false)
                    setPhysicsActive(false)
                    setDragOffset({ x: x - element.x, y: y - element.y })
                } else {
                    setMoveableElementIndex(-1)
                    setSelectedElementIndex(-1)
                    setIsDraggingSelected(false)
                    const newElementId = generateId()
                    const newElement: Element = {
                        id: newElementId,
                        x,
                        y,
                        radius: 5,
                        color: circleColor,
                        type: "circle",
                        state: "default",
                        vx: 0,
                        vy: 0,
                        mass: 1,
                    }
                    setElements((prev) => [...prev, newElement])
                    setIsCreatingElement(true)
                    setCreationStart({ x, y })
                    creatingElementId.current = newElementId
                }
            }
        },
        [findElementAt, handleMouseInteraction, circleColor]
    )

    const handleTouchMove = useCallback(
        (e: TouchEvent) => {
            e.preventDefault()
            if (
                isPinching &&
                e.touches.length === 2 &&
                pinchElementIndex >= 0
            ) {
                const touch1 = e.touches[0],
                    touch2 = e.touches[1]
                const currentDistance = getTouchDistance(touch1, touch2)
                const scale = currentDistance / pinchStartDistance
                const element = elements[pinchElementIndex]
                if (element.type === "circle") {
                    const newRadius = Math.max(
                        minRadius,
                        Math.min(maxRadius, pinchStartRadius * scale)
                    )
                    setLastUsedRadius(newRadius)
                    setElements((prev) =>
                        prev.map((el, idx) =>
                            idx === pinchElementIndex
                                ? {
                                      ...el,
                                      radius: newRadius,
                                      mass: newRadius / 10,
                                  }
                                : el
                        )
                    )
                } else if (element.type === "text") {
                    const newFontSizeVal = Math.max(
                        16,
                        Math.min(72, (element.fontSize || fontSize) * scale)
                    )
                    const newRadius = Math.max(newFontSizeVal / 2, 20)
                    setElements((prev) =>
                        prev.map((el, idx) =>
                            idx === pinchElementIndex
                                ? {
                                      ...el,
                                      fontSize: newFontSizeVal,
                                      radius: newRadius,
                                      mass: newRadius / 10,
                                  }
                                : el
                        )
                    )
                } else if (element.type === "rectangle") {
                    const newWidth = Math.max(10, (element.width || 50) * scale)
                    const newHeight = Math.max(
                        10,
                        (element.height || 50) * scale
                    )
                    const newRadius =
                        Math.sqrt(newWidth * newWidth + newHeight * newHeight) /
                        2
                    setElements((prev) =>
                        prev.map((el, idx) =>
                            idx === pinchElementIndex
                                ? {
                                      ...el,
                                      width: newWidth,
                                      height: newHeight,
                                      radius: newRadius,
                                      mass: newRadius / 10,
                                  }
                                : el
                        )
                    )
                }
            } else if (e.touches.length === 1) {
                const { x, y } = getCanvasCoordinates(e)
                if (
                    isCreatingElement &&
                    creationStart &&
                    creatingElementId.current
                ) {
                    const dragDistance = distance(
                        creationStart.x,
                        creationStart.y,
                        x,
                        y
                    )
                    const newRadius = Math.max(
                        minRadius,
                        Math.min(maxRadius, dragDistance)
                    )
                    setElements((prev) =>
                        prev.map((el) =>
                            el.id === creatingElementId.current
                                ? {
                                      ...el,
                                      radius: newRadius,
                                      mass: newRadius / 10,
                                  }
                                : el
                        )
                    )
                } else if (selectedElementIndex !== -1 && !isDraggingSelected) {
                    setMoveableElementIndex(selectedElementIndex)
                    setSelectedElementIndex(-1)
                    setIsDraggingSelected(true)
                } else if (moveableElementIndex !== -1 && isDraggingSelected) {
                    const canvas = canvasRef.current
                    if (!canvas) return
                    const rect = canvas.getBoundingClientRect()
                    const moveableElement = elements[moveableElementIndex]
                    if (moveableElement) {
                        const halfW =
                            moveableElement.type === "rectangle"
                                ? moveableElement.width! / 2
                                : moveableElement.radius
                        const halfH =
                            moveableElement.type === "rectangle"
                                ? moveableElement.height! / 2
                                : moveableElement.radius
                        const newX = Math.max(
                            halfW + canvasPadding,
                            Math.min(
                                rect.width - canvasPadding - halfW,
                                x - dragOffset.x
                            )
                        )
                        const newY = Math.max(
                            halfH + canvasPadding,
                            Math.min(
                                rect.height - halfH - canvasPadding,
                                y - dragOffset.y
                            )
                        )
                        setElements((prev) =>
                            prev.map((el, idx) =>
                                idx === moveableElementIndex
                                    ? { ...el, x: newX, y: newY }
                                    : el
                            )
                        )
                    }
                }
            }
        },
        [
            elements,
            isPinching,
            pinchElementIndex,
            pinchStartDistance,
            pinchStartRadius,
            minRadius,
            maxRadius,
            isCreatingElement,
            creationStart,
            moveableElementIndex,
            selectedElementIndex,
            dragOffset,
            lastUsedRadius,
            fontSize,
            isDraggingSelected,
            canvasPadding,
        ]
    )

    const handleTouchEnd = useCallback(
        (e: TouchEvent) => {
            e.preventDefault()
            if (isPinching) {
                setIsPinching(false)
                setPinchStartDistance(0)
                setPinchStartRadius(0)
                if (pinchElementIndex !== -1)
                    setSelectedElementIndex(pinchElementIndex)
                setPinchElementIndex(-1)
            }
            if (
                isCreatingElement &&
                creatingElementId.current &&
                e.touches.length === 0
            ) {
                setIsCreatingElement(false)
                setCreationStart(null)
                creatingElementId.current = null
            }
            if (isDraggingSelected && moveableElementIndex !== -1) {
                setSelectedElementIndex(moveableElementIndex)
                setMoveableElementIndex(-1)
            }
            setIsDraggingSelected(false)
        },
        [
            isPinching,
            isCreatingElement,
            moveableElementIndex,
            isDraggingSelected,
            pinchElementIndex,
        ]
    )

    const handleContainerClick = useCallback(
        () => containerRef.current?.focus(),
        []
    )

    useEffect(() => {
        const canvas = canvasRef.current,
            container = containerRef.current
        if (!canvas || !container) return
        const resizeCanvas = () => {
            const rect = container.getBoundingClientRect()
            canvas.width = rect.width
            canvas.height = rect.height
            draw()
        }
        resizeCanvas()
        canvas.addEventListener("mousedown", handleMouseDown)
        canvas.addEventListener("mousemove", handleMouseMove)
        window.addEventListener("mouseup", handleMouseUp)
        canvas.addEventListener("touchstart", handleTouchStart, {
            passive: false,
        })
        canvas.addEventListener("touchmove", handleTouchMove, {
            passive: false,
        })
        canvas.addEventListener("touchend", handleTouchEnd, { passive: false })
        canvas.addEventListener("mouseleave", () => setHoverElementId(null))
        canvas.addEventListener("wheel", handleWheel, { passive: false })
        container.addEventListener("keydown", handleKeyDown)
        container.addEventListener("keyup", handleKeyUp)
        container.focus()
        window.addEventListener("resize", resizeCanvas)
        return () => {
            canvas.removeEventListener("mousedown", handleMouseDown)
            canvas.removeEventListener("mousemove", handleMouseMove)
            window.removeEventListener("mouseup", handleMouseUp)
            canvas.removeEventListener("touchstart", handleTouchStart)
            canvas.removeEventListener("touchmove", handleTouchMove)
            canvas.removeEventListener("touchend", handleTouchEnd)
            canvas.removeEventListener("mouseleave", () =>
                setHoverElementId(null)
            )
            canvas.removeEventListener("wheel", handleWheel)
            container.removeEventListener("keydown", handleKeyDown)
            container.removeEventListener("keyup", handleKeyUp)
            window.removeEventListener("resize", resizeCanvas)
            if (mouseInteractionTimeoutRef.current)
                clearTimeout(mouseInteractionTimeoutRef.current)
        }
    }, [
        handleMouseDown,
        handleMouseMove,
        handleMouseUp,
        handleTouchStart,
        handleTouchMove,
        handleTouchEnd,
        handleKeyDown,
        handleKeyUp,
        draw,
        handleWheel,
    ])

    useEffect(() => {
        if (grainEnabled) {
            const tempGrainCanvas = document.createElement("canvas")
            const size = Math.max(64, 128 * grainScale) // Use grainScale for canvas size
            tempGrainCanvas.width = size
            tempGrainCanvas.height = size
            const grainCtx = tempGrainCanvas.getContext("2d")
            if (grainCtx) {
                const imageData = grainCtx.createImageData(size, size)
                const data = imageData.data
                for (let i = 0; i < data.length; i += 4) {
                    const value = (Math.random() * 255) | 0
                    data[i] = value
                    data[i + 1] = value
                    data[i + 2] = value
                    data[i + 3] = grainSize * 25.5
                }
                grainCtx.putImageData(imageData, 0, 0)
                grainCanvasRef.current = tempGrainCanvas
            }
        } else {
            grainCanvasRef.current = null
        }
        draw()
    }, [grainEnabled, grainSize, draw])

    useEffect(() => {
        let grainAnimationId: number
        if (grainEnabled && grainCanvasRef.current) {
            let time = 0
            const animateGrain = () => {
                if (grainCanvasRef.current) {
                    // FIXED: Much more subtle, natural grain movement
                    time += 0.005 * grainMovementSpeed // Much slower time increment

                    // Use multiple octaves of noise for more natural movement
                    const baseMovement = grainMovementSpeed * 0.2
                    grainOffsetRef.current.x =
                        Math.sin(time * 0.7) * baseMovement +
                        Math.sin(time * 1.3) * baseMovement * 0.5 +
                        Math.sin(time * 2.1) * baseMovement * 0.25

                    grainOffsetRef.current.y =
                        Math.cos(time * 0.9) * baseMovement +
                        Math.cos(time * 1.7) * baseMovement * 0.5 +
                        Math.cos(time * 2.3) * baseMovement * 0.25
                }
                draw()
                grainAnimationId = requestAnimationFrame(animateGrain)
            }
            grainAnimationId = requestAnimationFrame(animateGrain)
        }
        return () => {
            if (grainAnimationId) cancelAnimationFrame(grainAnimationId)
        }
    }, [grainEnabled, grainMovementSpeed, draw])

    useEffect(draw, [elements, draw])

    return (
        <motion.div
            ref={containerRef}
            onClick={handleContainerClick}
            style={{
                ...style,
                width: "100%",
                height: "100%",
                minHeight: "400px",
                position: "relative",
                overflow: "hidden",
                outline: "none",
                cursor: "crosshair",
            }}
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ duration: 0.3 }}
            tabIndex={0}
        >
            <canvas
                ref={canvasRef}
                style={{
                    display: "block",
                    width: "100%",
                    height: "100%",
                    touchAction: "none",
                }}
            />
            {showInstructions && (
                <>
                    {elements.length === 0 && (
                        <div
                            style={{
                                position: "absolute",
                                top: "50%",
                                left: "50%",
                                transform: "translate(-50%, -50%)",
                                textAlign: "center",
                                pointerEvents: "none",
                                color: "#666",
                                fontSize: "16px",
                            }}
                        >
                            <div>
                                Press letters, numbers (0-9), or Shift+numbers
                                for shapes
                            </div>
                            <div style={{ fontSize: "14px", marginTop: "8px" }}>
                                Arrow keys to select  Space to move/pause 
                                Enter for gravity  ESC/Delete to clear/remove
                            </div>
                        </div>
                    )}
                    <div
                        style={{
                            position: "absolute",
                            top: "10px",
                            left: "10px",
                            background: "rgba(0,0,0,0.7)",
                            color: "white",
                            padding: "10px",
                            borderRadius: "5px",
                            fontSize: "12px",
                            pointerEvents: "none",
                            opacity: elements.length > 0 ? 1 : 0,
                            transition: "opacity 0.3s",
                        }}
                    >
                        <div> Controls:</div>
                        <div>A-Z: Text  0-9: Circles  Shift+0-9: Rects</div>
                        <div>
                            Arrows: Select/Move  Space: Toggle Move / Pause
                            Gravity
                        </div>
                        <div>
                            Enter: Gravity  ESC: Clear All  Del/Backspace:
                            Remove Selected
                        </div>
                        {selectedElementIndex >= 0 && keyboardMode && (
                            <div>
                                 Selected: Element {selectedElementIndex + 1}
                            </div>
                        )}
                        {moveableElementIndex >= 0 && (
                            <div>
                                 Moving: Element {moveableElementIndex + 1}
                            </div>
                        )}
                        {physicsActive && (
                            <div>
                                 Gravity: {gravityDirection.toUpperCase()}{" "}
                                {isPhysicsPaused ? "(PAUSED)" : ""}
                            </div>
                        )}
                    </div>
                </>
            )}
            {enableScreenshot && (
                <button
                    onClick={handleScreenshotClick}
                    title="Download Screenshot"
                    style={{
                        position: "absolute",
                        top: "10px",
                        right: "10px",
                        background: "rgba(0,0,0,0.7)",
                        color: "white",
                        border: "none",
                        borderRadius: "5px",
                        padding: "8px",
                        cursor: "pointer",
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                    }}
                >
                    <img
                        src={screenshotIcon || "/placeholder.svg"}
                        alt="Screenshot"
                        style={{ width: "20px", height: "20px" }}
                    />
                </button>
            )}
        </motion.div>
    )
}

addPropertyControls(InteractiveCanvas, {
    backgroundColor: {
        type: ControlType.Color,
        title: "Background",
        defaultValue: "#f0f0f0",
    },
    physicsBackgroundColor: {
        type: ControlType.Color,
        title: "Physics BG",
        defaultValue: "#e8f4f8",
    },
    circleColor: {
        type: ControlType.Color,
        title: "Circle Color",
        defaultValue: "#3b82f6",
    },
    textColor: {
        type: ControlType.Color,
        title: "Text Color",
        defaultValue: "#2563eb",
    },
    rectangleColor: {
        type: ControlType.Color,
        title: "Rectangle Color",
        defaultValue: "#10b981",
    },
    selectedColor: {
        type: ControlType.Color,
        title: "Selected/Hover",
        defaultValue: "#ff00ff",
    },
    moveableColor: {
        type: ControlType.Color,
        title: "Moveable",
        defaultValue: "#ff0000",
    },
    strokeColor: {
        type: ControlType.Color,
        title: "Stroke",
        defaultValue: "#000000",
    },
    strokeWidth: {
        type: ControlType.Number,
        title: "Stroke Width",
        min: 1,
        max: 10,
        defaultValue: 2,
    },
    strokeWidth: {
        type: ControlType.Number,
        title: "Stroke Width",
        min: 1,
        max: 10,
        defaultValue: 2,
    },
    selectedStrokeWidth: {
        type: ControlType.Number,
        title: "Selected Stroke",
        min: 1,
        max: 10,
        defaultValue: 3,
    },
    moveableStrokeWidth: {
        type: ControlType.Number,
        title: "Moveable Stroke",
        min: 1,
        max: 10,
        defaultValue: 4,
    },
    overlapColor2: {
        type: ControlType.Color,
        title: "2-Overlap Color",
        defaultValue: "#ff6b35",
    },
    overlapColor3: {
        type: ControlType.Color,
        title: "3-Overlap Color",
        defaultValue: "#ff3535",
    },
    overlapColor4: {
        type: ControlType.Color,
        title: "4+ Overlap Color",
        defaultValue: "#ff0000",
    },
    minRadius: {
        type: ControlType.Number,
        title: "Min Radius",
        min: 5,
        max: 50,
        defaultValue: 20,
    },
    maxRadius: {
        type: ControlType.Number,
        title: "Max Radius",
        min: 50,
        max: 200,
        defaultValue: 100,
    },
    initialRadius: {
        type: ControlType.Number,
        title: "Initial Radius",
        min: 10,
        max: 150,
        defaultValue: 40,
    },
    fontSize: {
        type: ControlType.Number,
        title: "Font Size",
        min: 8,
        max: 96,
        defaultValue: 32,
    },
    movementSpeed: {
        type: ControlType.Number,
        title: "Move Speed",
        min: 1,
        max: 50,
        defaultValue: 15,
    },
    gravity: {
        type: ControlType.Number,
        title: "Gravity",
        min: 0,
        max: 5,
        step: 0.1,
        defaultValue: 0.5,
    },
    friction: {
        type: ControlType.Number,
        title: "Friction",
        min: 0.8,
        max: 1,
        step: 0.01,
        defaultValue: 0.98,
    },
    bounciness: {
        type: ControlType.Number,
        title: "Bounciness",
        min: 0,
        max: 1,
        step: 0.05,
        defaultValue: 0.7,
    },
    showInstructions: {
        type: ControlType.Boolean,
        title: "Show Instructions",
        defaultValue: true,
    },
    grainEnabled: {
        type: ControlType.Boolean,
        title: "Grain Enabled",
        defaultValue: false,
    },
    grainBlendMode: {
        type: ControlType.Enum,
        title: "Grain Blend",
        options: [
            "normal",
            "multiply",
            "screen",
            "overlay",
            "darken",
            "lighten",
            "color-dodge",
            "color-burn",
            "hard-light",
            "soft-light",
            "difference",
            "exclusion",
            "hue",
            "saturation",
            "color",
            "luminosity",
        ],
        defaultValue: "overlay",
    },
    grainSize: {
        type: ControlType.Number,
        title: "Grain Size",
        min: 0.1,
        max: 10,
        step: 0.1,
        defaultValue: 2,
    },
    grainScale: {
        type: ControlType.Number,
        title: "Grain Scale",
        min: 0.5,
        max: 4,
        step: 0.25,
        defaultValue: 1,
    },
    grainMovementSpeed: {
        type: ControlType.Number,
        title: "Grain Speed",
        min: 0,
        max: 5,
        step: 0.1,
        defaultValue: 1,
    },
    enableScreenshot: {
        type: ControlType.Boolean,
        title: "Screenshot",
        defaultValue: true,
    },
    screenshotIcon: {
        type: ControlType.String,
        title: "Screenshot Icon",
        defaultValue: "/camera-icon.svg",
    },
    screenshotWidth: {
        type: ControlType.Number,
        title: "Screenshot Width",
        min: 500,
        max: 5000,
        defaultValue: 1920,
    },
    canvasPadding: {
        type: ControlType.Number,
        title: "Canvas Padding",
        min: 0,
        max: 50,
        defaultValue: 10,
    },
})
