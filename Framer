"use client"

import { useEffect, useRef, useState, useCallback } from "react"
import { addPropertyControls, ControlType } from "framer"
import { motion } from "framer-motion"

// Updated Element interface to include rectangles and their properties
interface Element {
  id: string
  x: number
  y: number
  radius: number // For circles, and as a general collision/interaction radius for other types
  color: string
  state: "default" | "selected" | "moveable"
  type: "circle" | "text" | "rectangle" // Added "rectangle"
  text?: string
  fontSize?: number
  // Rectangle specific properties
  width?: number
  height?: number
  // Physics properties
  vx: number
  vy: number
  mass: number
}

/**
 * @framerDisableUnlink
 * @framerSupportedLayoutWidth any
 * @framerSupportedLayoutHeight any
 * @framerIntrinsicWidth 800
 * @framerIntrinsicHeight 600
 */
export default function InteractiveCanvas(props) {
  const {
    backgroundColor = "#f0f0f0",
    physicsBackgroundColor = "#e8f4f8",
    circleColor = "#3b82f6",
    textColor = "#2563eb",
    rectangleColor = "#10b981",
    hoverColor = "#00ff00",
    selectedColor = "#ff00ff",
    moveableColor = "#ff0000",
    strokeColor = "#000000",
    strokeWidth = 2,
    selectedStrokeWidth = 3,
    moveableStrokeWidth = 4,
    overlapColor2 = "#ff6b35",
    overlapColor3 = "#ff3535",
    overlapColor4 = "#ff0000",
    minRadius = 20,
    maxRadius = 100,
    initialRadius = 40,
    fontSize = 32,
    movementSpeed = 15,
    gravity = 0.5,
    friction = 0.98,
    bounciness = 0.7,
    style,
    showInstructions = true,
    grainEnabled = false,
    grainBlendMode = "overlay",
    grainSize = 2,
    grainMovementSpeed = 1,
    enableScreenshot = true,
    screenshotIcon = "/camera-icon.svg",
    screenshotWidth = 1920,
    canvasPadding = 10, // New prop for padding
  } = props

  const containerRef = useRef<HTMLDivElement>(null)
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const grainCanvasRef = useRef<HTMLCanvasElement | null>(null) // For grain effect
  const grainOffsetRef = useRef({ x: 0, y: 0 }) // For moving grain

  const animationFrameRef = useRef<number>()
  const mouseInteractionTimeoutRef = useRef<NodeJS.Timeout>()

  const [elements, setElements] = useState<Element[]>([])
  const [selectedElementIndex, setSelectedElementIndex] = useState<number>(-1)
  const [moveableElementIndex, setMoveableElementIndex] = useState<number>(-1)
  const [hoverElementId, setHoverElementId] = useState<string | null>(null)
  const [keyboardMode, setKeyboardMode] = useState(false)
  const [dragOffset, setDragOffset] = useState<{ x: number; y: number }>({
    x: 0,
    y: 0,
  })
  const [physicsActive, setPhysicsActive] = useState(false)
  const [isPhysicsPaused, setIsPhysicsPaused] = useState(false) // For space key pause

  const [isCreatingElement, setIsCreatingElement] = useState(false)
  const [creationStart, setCreationStart] = useState<{
    x: number
    y: number
  } | null>(null)
  const creatingElementId = useRef<string | null>(null)
  const [gravityDirection, setGravityDirection] = useState<"down" | "up" | "left" | "right">("down")

  const [isPinching, setIsPinching] = useState(false)
  const [pinchStartDistance, setPinchStartDistance] = useState(0)
  const [pinchStartRadius, setPinchStartRadius] = useState(0)
  const [pinchElementIndex, setPinchElementIndex] = useState(-1)

  const [isClearing, setIsClearing] = useState(false)
  const [wasPhysicsActiveBeforeClearing, setWasPhysicsActiveBeforeClearing] = useState(false)
  const [lastUsedRadius, setLastUsedRadius] = useState(initialRadius)

  const generateId = () => Math.random().toString(36).substr(2, 9)
  const distance = (x1: number, y1: number, x2: number, y2: number) => {
    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
  }
  const getTouchDistance = (touch1: Touch, touch2: Touch) => {
    const dx = touch2.clientX - touch1.clientX
    const dy = touch2.clientY - touch1.clientY
    return Math.sqrt(dx * dx + dy * dy)
  }
  const getTouchCenter = (touch1: Touch, touch2: Touch) => {
    const rect = canvasRef.current?.getBoundingClientRect()
    if (!rect) return { x: 0, y: 0 }
    return {
      x: (touch1.clientX + touch2.clientX) / 2 - rect.left,
      y: (touch1.clientY + touch2.clientY) / 2 - rect.top,
    }
  }

  const getTextDimensions = useCallback((text: string, currentFontSize: number) => {
    // Use a temporary canvas for measurement to avoid affecting the main canvas state
    const tempCanvas = document.createElement("canvas")
    const ctx = tempCanvas.getContext("2d")
    if (!ctx) return { width: 0, height: 0 }
    ctx.font = `${currentFontSize}px Arial`
    const metrics = ctx.measureText(text)
    return { width: metrics.width, height: currentFontSize }
  }, []) // Removed canvasRef from dependencies

  const calculateCenterOfMass = useCallback(() => {
    if (elements.length === 0) {
      const canvas = canvasRef.current
      if (!canvas) return { x: 400, y: 300 }
      const rect = canvas.getBoundingClientRect()
      return { x: rect.width / 2, y: rect.height / 2 }
    }
    let totalMass = 0,
      weightedX = 0,
      weightedY = 0
    elements.forEach((element) => {
      const mass = element.mass || element.radius / 10
      totalMass += mass
      weightedX += element.x * mass
      weightedY += element.y * mass
    })
    return { x: weightedX / totalMass, y: weightedY / totalMass }
  }, [elements])

  const circlesOverlap = useCallback((circle1: Element, circle2: Element) => {
    if (circle1.type !== "circle" || circle2.type !== "circle") return false
    return distance(circle1.x, circle1.y, circle2.x, circle2.y) < circle1.radius + circle2.radius
  }, [])

  const getOverlapColor = useCallback(
    (overlapCount: number) => {
      if (overlapCount === 1) return overlapColor2
      if (overlapCount === 2) return overlapColor3
      return overlapColor4
    },
    [overlapColor2, overlapColor3, overlapColor4],
  )

  const countCharacterOverlaps = useCallback(
    (
      charX: number,
      charY: number,
      charWidth: number,
      charHeight: number,
      allElements: Element[],
      excludeId: string,
    ): number => {
      let overlapCount = 0
      allElements.forEach((otherElement) => {
        if (otherElement.id === excludeId) return

        if (otherElement.type === "circle") {
          const closestX = Math.max(charX - charWidth / 2, Math.min(otherElement.x, charX + charWidth / 2))
          const closestY = Math.max(charY - charHeight / 2, Math.min(otherElement.y, charY + charHeight / 2))
          if (distance(otherElement.x, otherElement.y, closestX, closestY) < otherElement.radius) {
            overlapCount++
          }
        } else if (otherElement.type === "rectangle") {
          const rectHalfWidth = otherElement.width! / 2
          const rectHalfHeight = otherElement.height! / 2
          const charHalfWidth = charWidth / 2
          const charHalfHeight = charHeight / 2

          if (
            charX - charHalfWidth < otherElement.x + rectHalfWidth &&
            charX + charHalfWidth > otherElement.x - rectHalfWidth &&
            charY - charHalfHeight < otherElement.y + rectHalfHeight &&
            charY + charHalfHeight > otherElement.y - rectHalfHeight
          ) {
            overlapCount++
          }
        } else if (otherElement.type === "text" && otherElement.text) {
          const otherTextDims = getTextDimensions(otherElement.text, otherElement.fontSize || fontSize)
          const otherRect = {
            left: otherElement.x - otherTextDims.width / 2,
            right: otherElement.x + otherTextDims.width / 2,
            top: otherElement.y - otherTextDims.height / 2,
            bottom: otherElement.y + otherTextDims.height / 2,
          }
          const charRect = {
            left: charX - charWidth / 2,
            right: charX + charWidth / 2,
            top: charY - charHeight / 2,
            bottom: charY + charHeight / 2,
          }
          if (
            !(
              charRect.right < otherRect.left ||
              otherRect.right < charRect.left ||
              charRect.bottom < otherRect.top ||
              otherRect.bottom < charRect.top
            )
          ) {
            overlapCount++
          }
        }
      })
      return overlapCount
    },
    [getTextDimensions, fontSize],
  )

  const findElementAt = useCallback(
    (x: number, y: number): { element: Element; index: number } | null => {
      for (let i = elements.length - 1; i >= 0; i--) {
        const element = elements[i]
        if (element.type === "circle") {
          if (distance(x, y, element.x, element.y) <= element.radius) return { element, index: i }
        } else if (element.type === "text" && element.text) {
          const dims = getTextDimensions(element.text, element.fontSize || fontSize)
          if (
            x >= element.x - dims.width / 2 &&
            x <= element.x + dims.width / 2 &&
            y >= element.y - dims.height / 2 &&
            y <= element.y + dims.height / 2
          )
            return { element, index: i }
        } else if (element.type === "rectangle") {
          if (
            x >= element.x - element.width! / 2 &&
            x <= element.x + element.width! / 2 &&
            y >= element.y - element.height! / 2 &&
            y <= element.y + element.height! / 2
          )
            return { element, index: i }
        }
      }
      return null
    },
    [elements, getTextDimensions, fontSize],
  )

  const findMostEmptyArea = useCallback(
    (newElementRadius: number = initialRadius) => {
      const canvas = canvasRef.current
      if (!canvas) return { x: 400, y: 300 }
      const rect = canvas.getBoundingClientRect()
      const effectiveWidth = rect.width - 2 * canvasPadding
      const effectiveHeight = rect.height - 2 * canvasPadding
      const offsetX = canvasPadding
      const offsetY = canvasPadding
      const canvasCenter = { x: offsetX + effectiveWidth / 2, y: offsetY + effectiveHeight / 2 } // Center of padded area
      const currentCenterOfMass = calculateCenterOfMass()
      const baseGridSize = Math.max(30, newElementRadius * 1.2)
      const gridSize = elements.length > 20 ? baseGridSize * 0.7 : baseGridSize
      const cols = Math.floor(effectiveWidth / gridSize)
      const rows = Math.floor(effectiveHeight / gridSize)
      let bestScore = Number.POSITIVE_INFINITY
      let bestX = offsetX + effectiveWidth / 2
      let bestY = offsetY + effectiveHeight / 2
      const searchPasses = elements.length > 15 ? 2 : 1

      for (let pass = 0; pass < searchPasses; pass++) {
        const margin = pass === 0 ? newElementRadius + 15 : newElementRadius + 5
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            const centerX = col * gridSize + gridSize / 2 + offsetX
            const centerY = row * gridSize + gridSize / 2 + offsetY
            if (
              centerX < offsetX + margin ||
              centerX > offsetX + effectiveWidth - margin ||
              centerY < offsetY + margin ||
              centerY > offsetY + effectiveHeight - margin
            )
              continue
            let overlapPenalty = 0,
              minDistanceToAnyElement = Number.POSITIVE_INFINITY
            elements.forEach((element) => {
              const dist = distance(centerX, centerY, element.x, element.y)
              minDistanceToAnyElement = Math.min(minDistanceToAnyElement, dist)
              const minAllowedDist = element.radius + newElementRadius + (pass === 0 ? 20 : 10)
              if (dist < minAllowedDist) overlapPenalty += Math.pow(minAllowedDist - dist, 2) * (pass === 0 ? 100 : 50)
            })
            if (pass === 0 && overlapPenalty > 0) continue
            const newMass = newElementRadius / 10
            const totalMass = elements.reduce((sum, el) => sum + (el.mass || el.radius / 10), 0) + newMass
            let balanceBonus = 0
            if (totalMass > 0) {
              const currentTotalMass = totalMass - newMass
              const newCenterOfMass = {
                x:
                  currentTotalMass > 0
                    ? (currentCenterOfMass.x * currentTotalMass + centerX * newMass) / totalMass
                    : centerX,
                y:
                  currentTotalMass > 0
                    ? (currentCenterOfMass.y * currentTotalMass + centerY * newMass) / totalMass
                    : centerY,
              }
              const currentDistFromCenter = distance(
                currentCenterOfMass.x,
                currentCenterOfMass.y,
                canvasCenter.x,
                canvasCenter.y,
              )
              const newDistFromCenter = distance(newCenterOfMass.x, newCenterOfMass.y, canvasCenter.x, canvasCenter.y)
              balanceBonus = Math.max(0, (currentDistFromCenter - newDistFromCenter) * 2)
            }
            const spreadBonus = Math.min(minDistanceToAnyElement * 0.1, 50)
            const totalScore = overlapPenalty - balanceBonus - spreadBonus + Math.random() * 5
            if (totalScore < bestScore) {
              bestScore = totalScore
              bestX = centerX
              bestY = centerY
            }
          }
        }
        if (bestScore < 1000) break
      }
      return { x: bestX, y: bestY }
    },
    [elements, initialRadius, calculateCenterOfMass, canvasPadding],
  )

  const getCanvasCoordinates = (e: MouseEvent | TouchEvent) => {
    const rect = canvasRef.current?.getBoundingClientRect()
    if (!rect) return { x: 0, y: 0 }
    let clientX, clientY
    if (e instanceof MouseEvent) {
      clientX = e.clientX
      clientY = e.clientY
    } else {
      clientX = e.touches[0]?.clientX || e.changedTouches[0]?.clientX || 0
      clientY = e.touches[0]?.clientY || e.changedTouches[0]?.clientY || 0
    }
    return { x: clientX - rect.left, y: clientY - rect.top }
  }

  const getSelectedElement = useCallback(
    () => (selectedElementIndex >= 0 && selectedElementIndex < elements.length ? elements[selectedElementIndex] : null),
    [elements, selectedElementIndex],
  )
  const getMoveableElement = useCallback(
    () => (moveableElementIndex >= 0 && moveableElementIndex < elements.length ? elements[moveableElementIndex] : null),
    [elements, moveableElementIndex],
  )

  const findNearestElementInDirection = useCallback(
    (direction: "left" | "right" | "up" | "down") => {
      const currentElement = getSelectedElement()
      if (elements.length <= 1) return -1
      if (!currentElement) return 0
      const candidates: Array<{ index: number; distance: number; alignmentScore: number }> = []
      elements.forEach((element, index) => {
        if (element.id === currentElement.id) return
        const dx = element.x - currentElement.x,
          dy = element.y - currentElement.y
        const dist = Math.sqrt(dx * dx + dy * dy)
        if (dist < 5) return
        let isInDirection = false,
          alignmentScore = 0
        switch (direction) {
          case "right":
            isInDirection = dx > 0
            alignmentScore = Math.abs(dy)
            break
          case "left":
            isInDirection = dx < 0
            alignmentScore = Math.abs(dy)
            break
          case "down":
            isInDirection = dy > 0
            alignmentScore = Math.abs(dx)
            break
          case "up":
            isInDirection = dy < 0
            alignmentScore = Math.abs(dx)
            break
        }
        if (isInDirection) candidates.push({ index, distance: dist, alignmentScore })
      })
      if (candidates.length === 0) return -1
      candidates.sort((a, b) =>
        Math.abs(a.alignmentScore - b.alignmentScore) > 20
          ? a.alignmentScore - b.alignmentScore
          : a.distance - b.distance,
      )
      return candidates[0].index
    },
    [elements, getSelectedElement],
  )

  const handleMouseInteraction = useCallback(() => {
    if (keyboardMode) {
      setKeyboardMode(false)
      if (mouseInteractionTimeoutRef.current) clearTimeout(mouseInteractionTimeoutRef.current)
      mouseInteractionTimeoutRef.current = setTimeout(() => setSelectedElementIndex(-1), 100)
    }
  }, [keyboardMode])

  const handleWheel = useCallback(
    (e: WheelEvent) => {
      e.preventDefault()
      const { x, y } = getCanvasCoordinates(e as any)
      const result = findElementAt(x, y)
      if (!result) return

      const { element, index } = result
      const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1
      setElements((prev) =>
        prev.map((el, idx) => {
          if (idx !== index) return el
          if (el.type === "circle") {
            const newRadius = Math.max(minRadius, Math.min(maxRadius, el.radius * scaleFactor))
            setLastUsedRadius(newRadius)
            return { ...el, radius: newRadius, mass: newRadius / 10 }
          } else if (el.type === "text") {
            const newFontSize = Math.max(16, Math.min(72, (el.fontSize || fontSize) * scaleFactor))
            const newRadius = Math.max(newFontSize / 2, 20)
            return { ...el, fontSize: newFontSize, radius: newRadius, mass: newRadius / 10 }
          } else if (el.type === "rectangle") {
            const newWidth = Math.max(10, (el.width || 50) * scaleFactor)
            const newHeight = Math.max(10, (el.height || 50) * scaleFactor)
            // Recalculate radius for collision based on new dimensions
            const newRadius = Math.sqrt(newWidth * newWidth + newHeight * newHeight) / 2
            return { ...el, width: newWidth, height: newHeight, radius: newRadius, mass: newRadius / 10 }
          }
          return el
        }),
      )
      setMoveableElementIndex(index)
      setSelectedElementIndex(-1)
      setPhysicsActive(false)
    },
    [findElementAt, minRadius, maxRadius, fontSize, lastUsedRadius],
  )

  const updatePhysics = useCallback(() => {
    const canvas = canvasRef.current
    if (!canvas || !physicsActive || isPhysicsPaused) return // Check isPhysicsPaused

    setElements((prevElements) => {
      const newElements = [...prevElements]
      let hasMovement = false
      const rect = canvas.getBoundingClientRect()
      const logicalWidth = rect.width,
        logicalHeight = rect.height

      for (let i = 0; i < newElements.length; i++) {
        const el = newElements[i]
        if (el.state === "moveable") continue
        switch (gravityDirection) {
          case "down":
            el.vy += gravity
            break
          case "up":
            el.vy -= gravity
            break
          case "left":
            el.vx -= gravity
            break
          case "right":
            el.vx += gravity
            break
        }
        el.vx *= friction
        el.vy *= friction
        el.x += el.vx
        el.y += el.vy

        // Boundary checks for all types, using radius as a general boundary
        const halfW = el.type === "rectangle" ? el.width! / 2 : el.radius
        const halfH = el.type === "rectangle" ? el.height! / 2 : el.radius

        if (el.x - halfW < canvasPadding) {
          el.x = canvasPadding + halfW
          el.vx *= -bounciness
        }
        if (el.x + halfW > logicalWidth - canvasPadding) {
          el.x = logicalWidth - canvasPadding - halfW
          el.vx *= -bounciness
        }
        if (el.y - halfH < canvasPadding) {
          el.y = canvasPadding + halfH
          el.vy *= -bounciness
        }
        if (el.y + halfH > logicalHeight - canvasPadding) {
          if (isClearing) continue // Allow elements to fall off if clearing
          el.y = logicalHeight - canvasPadding - halfH
          el.vy *= -bounciness
          if (Math.abs(el.vy) < 0.5) el.vy = 0
        }
        if (Math.abs(el.vx) > 0.1 || Math.abs(el.vy) > 0.1) hasMovement = true
      }

      for (let i = 0; i < newElements.length; i++) {
        for (let j = i + 1; j < newElements.length; j++) {
          const el1 = newElements[i],
            el2 = newElements[j]
          if (el1.state === "moveable" || el2.state === "moveable") continue
          const dx = el2.x - el1.x,
            dy = el2.y - el1.y
          const dist = Math.sqrt(dx * dx + dy * dy)
          // Using radius for collision detection for all types for now
          const minDist = el1.radius + el2.radius
          if (dist < minDist) {
            hasMovement = true
            const nx = dx / dist,
              ny = dy / dist
            const overlap = minDist - dist
            const sepX = (overlap * nx) / 2,
              sepY = (overlap * ny) / 2
            el1.x -= sepX
            el1.y -= sepY
            el2.x += sepX
            el2.y += sepY
            const dvx = el2.vx - el1.vx,
              dvy = el2.vy - el1.vy
            const dvn = dvx * nx + dvy * ny
            if (dvn > 0) continue
            const impulse = (2 * dvn) / (el1.mass + el2.mass)
            el1.vx += impulse * el2.mass * nx * bounciness
            el1.vy += impulse * el2.mass * ny * bounciness
            el2.vx -= impulse * el1.mass * nx * bounciness
            el2.vy -= impulse * el1.mass * ny * bounciness
          }
        }
      }
      if (!hasMovement && !isClearing) setTimeout(() => setPhysicsActive(false), 100) // Don't stop if clearing
      return newElements
    })
  }, [physicsActive, isPhysicsPaused, gravity, friction, bounciness, isClearing, gravityDirection, canvasPadding])

  useEffect(() => {
    if (physicsActive) {
      const animate = () => {
        updatePhysics()
        animationFrameRef.current = requestAnimationFrame(animate)
      }
      animationFrameRef.current = requestAnimationFrame(animate)
    } else if (animationFrameRef.current) cancelAnimationFrame(animationFrameRef.current)
    return () => {
      if (animationFrameRef.current) cancelAnimationFrame(animationFrameRef.current)
    }
  }, [physicsActive, updatePhysics])

  useEffect(() => {
    if (isClearing && elements.length > 0) {
      const canvas = canvasRef.current
      if (!canvas) return
      const rect = canvas.getBoundingClientRect()
      if (elements.every((el) => el.y - el.radius > rect.height)) {
        setElements([])
        setIsClearing(false)
        setSelectedElementIndex(-1)
        setMoveableElementIndex(-1)
        setHoverElementId(null)
        if (!wasPhysicsActiveBeforeClearing) setPhysicsActive(false)
      }
    }
  }, [elements, isClearing, wasPhysicsActiveBeforeClearing])

  const splitWordsIntoCharacters = useCallback(() => {
    setElements((prev) => {
      const newElements: Element[] = []
      prev.forEach((el) => {
        if (el.type === "text" && el.text && el.text.length > 1) {
          const chars = el.text.split("")
          const charSpacing = (el.fontSize || fontSize) * 0.6
          const startX = el.x - ((chars.length - 1) * charSpacing) / 2
          chars.forEach((char, index) => {
            newElements.push({
              ...el,
              id: generateId(),
              x: startX + index * charSpacing,
              text: char,
              vx: (Math.random() - 0.5) * 2,
              vy: Math.random() * -2,
              mass: (el.fontSize || fontSize) / 20,
            })
          })
        } else {
          newElements.push({ ...el, vx: (Math.random() - 0.5) * 2, vy: Math.random() * -2, mass: el.radius / 10 })
        }
      })
      return newElements
    })
  }, [fontSize])

  const handleKeyDown = useCallback(
    (e: KeyboardEvent) => {
      const canvas = canvasRef.current
      if (!canvas) return
      setKeyboardMode(true)
      if (mouseInteractionTimeoutRef.current) clearTimeout(mouseInteractionTimeoutRef.current)

      const moveableElement = getMoveableElement()
      const selectedElement = getSelectedElement()
      const rect = canvas.getBoundingClientRect()

      const moveSelectedOrMoveable = (dx: number, dy: number) => {
        const targetIndex = moveableElementIndex !== -1 ? moveableElementIndex : selectedElementIndex
        if (targetIndex !== -1) {
          setElements((prev) =>
            prev.map((el, idx) => {
              if (idx === targetIndex) {
                const newX = el.x + dx
                const newY = el.y + dy
                // Basic boundary check for movement
                const halfW = el.type === "rectangle" ? el.width! / 2 : el.radius
                const halfH = el.type === "rectangle" ? el.height! / 2 : el.radius
                return {
                  ...el,
                  x: Math.max(canvasPadding + halfW, Math.min(rect.width - canvasPadding - halfW, newX)),
                  y: Math.max(canvasPadding + halfH, Math.min(rect.height - canvasPadding - halfH, newY)),
                }
              }
              return el
            }),
          )
        }
      }

      switch (e.key) {
        case "ArrowUp":
          e.preventDefault()
          physicsActive
            ? setGravityDirection("up")
            : moveSelectedOrMoveable(0, -movementSpeed) || setSelectedElementIndex(findNearestElementInDirection("up"))
          break
        case "ArrowDown":
          e.preventDefault()
          physicsActive
            ? setGravityDirection("down")
            : moveSelectedOrMoveable(0, movementSpeed) || setSelectedElementIndex(findNearestElementInDirection("down"))
          break
        case "ArrowLeft":
          e.preventDefault()
          physicsActive
            ? setGravityDirection("left")
            : moveSelectedOrMoveable(-movementSpeed, 0) ||
              setSelectedElementIndex(findNearestElementInDirection("left"))
          break
        case "ArrowRight":
          e.preventDefault()
          physicsActive
            ? setGravityDirection("right")
            : moveSelectedOrMoveable(movementSpeed, 0) ||
              setSelectedElementIndex(findNearestElementInDirection("right"))
          break
        case " ":
          e.preventDefault()
          if (physicsActive)
            setIsPhysicsPaused(true) // Pause physics
          else if (moveableElement) setMoveableElementIndex(-1)
          else if (selectedElement) {
            setMoveableElementIndex(selectedElementIndex)
            setSelectedElementIndex(-1)
          }
          break
        case "Enter":
        case "Return":
          e.preventDefault()
          if (elements.length > 0) {
            if (physicsActive) setPhysicsActive(false)
            else {
              splitWordsIntoCharacters()
              setPhysicsActive(true)
            }
          }
          break
        case "Escape":
          e.preventDefault()
          if (elements.length > 0) {
            setIsClearing(true)
            setWasPhysicsActiveBeforeClearing(physicsActive)
            if (!physicsActive) {
              setElements((prev) =>
                prev.map((el) => ({
                  ...el,
                  vx: (Math.random() - 0.5) * 2,
                  vy: Math.random() * -2,
                  mass: el.radius / 10,
                })),
              )
              setPhysicsActive(true)
            }
            setSelectedElementIndex(-1)
            setMoveableElementIndex(-1)
          }
          break
        case "Delete":
        case "Backspace": {
          e.preventDefault()
          const targetIndex = moveableElementIndex !== -1 ? moveableElementIndex : selectedElementIndex
          if (moveableElement && moveableElement.type === "text" && moveableElement.text && e.key === "Backspace") {
            if (moveableElement.text.length > 1) {
              setElements((prev) =>
                prev.map((el, idx) => (idx === moveableElementIndex ? { ...el, text: el.text!.slice(0, -1) } : el)),
              )
            } else if (targetIndex !== -1) {
              // Remove element if text becomes empty
              setElements((prev) => prev.filter((_, idx) => idx !== targetIndex))
              setMoveableElementIndex(-1)
              setSelectedElementIndex(-1)
            }
          } else if (targetIndex !== -1) {
            // Delete for non-text or if not Backspace on text
            setElements((prev) => prev.filter((_, idx) => idx !== targetIndex))
            setMoveableElementIndex(-1)
            setSelectedElementIndex(-1)
          }
          break
        }
        default: {
          // ─────────────────────────────────────────────────────────────
          //  Unified text / number handling (char is always defined here)
          // ─────────────────────────────────────────────────────────────
          const char = e.key

          // Ignore non-printable keys or keys used with modifiers
          if (char.length !== 1 || e.ctrlKey || e.metaKey) break

          const targetElement = moveableElement || (keyboardMode && selectedElement)
          const canvas = canvasRef.current
          if (!canvas) break
          const canvasW = canvas.width
          const canvasH = canvas.height

          // 1. NUMBER KEYS 0-9  ─────────────────────────────────────────
          if (/^[0-9]$/.test(char)) {
            e.preventDefault()
            const n = char === "0" ? 10 : Number(char)

            if (e.shiftKey) {
              /* create rectangle */
              const baseArea = Math.PI * Math.pow(minRadius + (n - 1) * ((maxRadius - minRadius) / 9), 2)
              const ratio = Math.random() * 1.5 + 0.5
              const w = Math.sqrt(baseArea * ratio)
              const h = Math.sqrt(baseArea / ratio)
              const r = Math.hypot(w, h) / 2
              const pos = findMostEmptyArea(r)
              const rect: Element = {
                id: generateId(),
                x: pos.x,
                y: pos.y,
                radius: r,
                color: rectangleColor,
                type: "rectangle",
                width: w,
                height: h,
                state: "default",
                vx: 0,
                vy: 0,
                mass: r / 10,
              }
              setElements((p) => [...p, rect])
              setSelectedElementIndex(-1)
              setMoveableElementIndex(-1)
            } else if (targetElement && targetElement.type === "rectangle") {
              /* resize existing */
              const scale = 1 + (n - 5) * 0.1
              const w = Math.max(10, Math.min(canvasW - 2 * canvasPadding, (targetElement.width || 50) * scale))
              const h = Math.max(10, Math.min(canvasH - 2 * canvasPadding, (targetElement.height || 50) * scale))
              const r = Math.hypot(w, h) / 2
              setElements((p) =>
                p.map((el) =>
                  el.id === targetElement.id ? { ...el, width: w, height: h, radius: r, mass: r / 10 } : el,
                ),
              )
            } else {
              /* new circle */
              const r = Math.max(minRadius, Math.min(maxRadius, minRadius + (n - 1) * ((maxRadius - minRadius) / 9)))
              setLastUsedRadius(r)
              const pos = findMostEmptyArea(r)
              const circ: Element = {
                id: generateId(),
                x: pos.x,
                y: pos.y,
                radius: r,
                color: circleColor,
                type: "circle",
                state: "default",
                vx: 0,
                vy: 0,
                mass: r / 10,
              }
              setElements((p) => [...p, circ])
              setSelectedElementIndex(-1)
              setMoveableElementIndex(-1)
            }
            break
          }

          // 2. TEXT INPUT  ───────────────────────────────────────────────
          if (moveableElement && moveableElement.type === "text") {
            e.preventDefault()
            setElements((p) =>
              p.map((el, i) => (i === moveableElementIndex ? { ...el, text: (el.text || "") + char } : el)),
            )
          } else if (/^[a-zA-Z]$/.test(char)) {
            e.preventDefault()
            const rad = Math.max(fontSize / 2, 20)
            const pos = findMostEmptyArea(rad)
            const txt: Element = {
              id: generateId(),
              x: pos.x,
              y: pos.y,
              radius: rad,
              color: textColor,
              type: "text",
              text: char,
              fontSize: fontSize,
              state: "moveable",
              vx: 0,
              vy: 0,
              mass: rad / 10,
            }
            setElements((p) => [...p, txt])
            setMoveableElementIndex(elements.length) // new index
            setSelectedElementIndex(-1)
          }
          break
        }
      }
    },
    [
      elements,
      selectedElementIndex,
      moveableElementIndex,
      movementSpeed,
      initialRadius,
      circleColor,
      textColor,
      rectangleColor,
      minRadius,
      maxRadius,
      physicsActive,
      getSelectedElement,
      getMoveableElement,
      findNearestElementInDirection,
      findMostEmptyArea,
      lastUsedRadius,
      fontSize,
      splitWordsIntoCharacters,
      keyboardMode,
      isPhysicsPaused,
      canvasPadding,
    ],
  )

  // Add keyup listener for space to unpause physics
  const handleKeyUp = useCallback(
    (e: KeyboardEvent) => {
      if (e.key === " " && physicsActive && isPhysicsPaused) {
        e.preventDefault()
        setIsPhysicsPaused(false) // Unpause physics
      }
    },
    [physicsActive, isPhysicsPaused],
  )

  useEffect(() => {
    setElements((prev) =>
      prev.map((element, index) => {
        let state: Element["state"] = "default"
        if (index === moveableElementIndex) state = "moveable"
        else if (index === selectedElementIndex && keyboardMode) state = "selected"
        else if (element.id === hoverElementId && !keyboardMode) state = "selected" // Hover acts as selected in mouse mode
        return { ...element, state }
      }),
    )
  }, [selectedElementIndex, moveableElementIndex, hoverElementId, keyboardMode])

  // Centralized drawScene function for reuse in screenshot
  const drawScene = useCallback(
    (ctx: CanvasRenderingContext2D, renderWidth: number, renderHeight: number, scaleFactor = 1) => {
      ctx.save()
      ctx.scale(scaleFactor, scaleFactor) // Apply scaling for high-res screenshots

      const currentPhysicsActive = physicsActive && !isPhysicsPaused // Consider pause state
      ctx.fillStyle = currentPhysicsActive ? physicsBackgroundColor : backgroundColor
      ctx.fillRect(0, 0, renderWidth / scaleFactor, renderHeight / scaleFactor)

      // 1. Draw CIRCLES
      elements.forEach((element) => {
        if (element.type === "circle") {
          ctx.save() // Save context for each element
          ctx.translate(element.x, element.y) // Translate to element's origin for easier drawing

          let strokeColorToUse = strokeColor
          const scaledStroke = (width: number) => width * scaleFactor
          let lineWidth = scaledStroke(strokeWidth)
          if (element.state === "selected") {
            strokeColorToUse = selectedColor
            lineWidth = scaledStroke(selectedStrokeWidth)
          }
          if (element.state === "moveable") {
            strokeColorToUse = moveableColor
            lineWidth = scaledStroke(moveableStrokeWidth)
          }

          ctx.strokeStyle = strokeColorToUse
          ctx.lineWidth = lineWidth
          ctx.fillStyle = element.color

          ctx.beginPath()
          ctx.arc(0, 0, element.radius, 0, 2 * Math.PI)
          ctx.fill()
          ctx.stroke()
          if (element.state === "selected" || element.state === "moveable") {
            ctx.beginPath()
            const indicatorRadius = element.radius + (element.state === "selected" ? 5 : 8)
            ctx.arc(0, 0, indicatorRadius, 0, 2 * Math.PI)
            ctx.strokeStyle = element.state === "selected" ? selectedColor : moveableColor
            ctx.lineWidth = scaledStroke(element.state === "selected" ? 1 : 2)
            ctx.setLineDash(element.state === "selected" ? [5, 5] : [3, 3])
            ctx.stroke()
            ctx.setLineDash([])
          }
          ctx.restore() // Restore context for next element
        }
      })

      // 2. Draw RECTANGLES
      elements.forEach((element) => {
        if (element.type === "rectangle" && element.width && element.height) {
          ctx.save() // Save context for each element
          ctx.translate(element.x, element.y) // Translate to element's origin for easier drawing

          let strokeColorToUse = strokeColor
          let lineWidth = scaledStroke(strokeWidth)
          if (element.state === "selected") {
            strokeColorToUse = selectedColor
            lineWidth = scaledStroke(selectedStrokeWidth)
          }
          if (element.state === "moveable") {
            strokeColorToUse = moveableColor
            lineWidth = scaledStroke(moveableStrokeWidth)
          }

          ctx.strokeStyle = strokeColorToUse
          ctx.lineWidth = lineWidth
          ctx.fillStyle = element.color

          ctx.fillRect(-element.width / 2, -element.height / 2, element.width, element.height)
          ctx.strokeRect(-element.width / 2, -element.height / 2, element.width, element.height)
          if (element.state === "selected" || element.state === "moveable") {
            const padding = element.state === "selected" ? 5 : 8
            ctx.strokeStyle = element.state === "selected" ? selectedColor : moveableColor
            ctx.lineWidth = scaledStroke(element.state === "selected" ? 1 : 2)
            ctx.setLineDash(element.state === "selected" ? [5, 5] : [3, 3])
            ctx.strokeRect(
              -element.width / 2 - padding,
              -element.height / 2 - padding,
              element.width + padding * 2,
              element.height + padding * 2,
            )
            ctx.setLineDash([])
          }
          ctx.restore() // Restore context for next element
        }
      })

      // 3. Draw CIRCLE OVERLAPS (2-way, 3-way, 4-way as detailed above)
      const circleElements = elements.filter((el) => el.type === "circle")
      if (circleElements.length >= 2) {
        for (let i = 0; i < circleElements.length; i++) {
          for (let j = i + 1; j < circleElements.length; j++) {
            const c1 = circleElements[i]
            const c2 = circleElements[j]
            if (!circlesOverlap(c1, c2)) continue

            ctx.save()
            ctx.beginPath()
            ctx.arc(c1.x, c1.y, c1.radius, 0, 2 * Math.PI)
            ctx.clip()
            ctx.beginPath()
            ctx.arc(c2.x, c2.y, c2.radius, 0, 2 * Math.PI)
            ctx.fillStyle = getOverlapColor(1) // 2 circles involved -> 1st level of overlap
            ctx.fill()
            ctx.restore()
          }
        }
      }
      if (circleElements.length >= 3) {
        for (let i = 0; i < circleElements.length; i++) {
          for (let j = i + 1; j < circleElements.length; j++) {
            for (let k = j + 1; k < circleElements.length; k++) {
              const c1 = circleElements[i]
              const c2 = circleElements[j]
              const c3 = circleElements[k]

              // Check for pairwise overlaps to approximate a 3-way intersection area
              if (!circlesOverlap(c1, c2) || !circlesOverlap(c1, c3) || !circlesOverlap(c2, c3)) continue

              // A simple check: if the center of one circle is inside the other two, it's likely a deep overlap.
              // For more accurate 3-way intersection, complex geometry is needed.
              // This simplified approach will color areas where three circles are very close.

              // Draw intersection of c1, c2, then clip c3 by that.
              ctx.save()
              ctx.beginPath() // Path for c1
              ctx.arc(c1.x, c1.y, c1.radius, 0, 2 * Math.PI)
              ctx.clip()
              ctx.beginPath() // Path for c2
              ctx.arc(c2.x, c2.y, c2.radius, 0, 2 * Math.PI)
              ctx.clip() // Now clipped to c1 AND c2
              ctx.beginPath() // Path for c3
              ctx.arc(c3.x, c3.y, c3.radius, 0, 2 * Math.PI)
              ctx.fillStyle = getOverlapColor(2) // 3 circles involved -> 2nd level of overlap
              ctx.fill()
              ctx.restore()
            }
          }
        }
      }
      if (circleElements.length >= 4) {
        for (let i = 0; i < circleElements.length; i++) {
          for (let j = i + 1; j < circleElements.length; j++) {
            for (let k = j + 1; k < circleElements.length; k++) {
              for (let l = k + 1; l < circleElements.length; l++) {
                const c1 = circleElements[i]
                const c2 = circleElements[j]
                const c3 = circleElements[k]
                const c4 = circleElements[l]

                if (
                  !circlesOverlap(c1, c2) ||
                  !circlesOverlap(c1, c3) ||
                  !circlesOverlap(c1, c4) ||
                  !circlesOverlap(c2, c3) ||
                  !circlesOverlap(c2, c4) ||
                  !circlesOverlap(c3, c4)
                )
                  continue

                ctx.save()
                ctx.beginPath()
                ctx.arc(c1.x, c1.y, c1.radius, 0, 2 * Math.PI)
                ctx.clip()
                ctx.beginPath()
                ctx.arc(c2.x, c2.y, c2.radius, 0, 2 * Math.PI)
                ctx.clip()
                ctx.beginPath()
                ctx.arc(c3.x, c3.y, c3.radius, 0, 2 * Math.PI)
                ctx.clip()
                ctx.beginPath()
                ctx.arc(c4.x, c4.y, c4.radius, 0, 2 * Math.PI)
                ctx.fillStyle = getOverlapColor(3) // 4+ circles involved -> 3rd level of overlap
                ctx.fill()
                ctx.restore()
              }
            }
          }
        }
      }

      // 4. Draw TEXT
      elements.forEach((element) => {
        if (element.type === "text" && element.text) {
          ctx.save() // Save context for each element
          ctx.translate(element.x, element.y) // Translate to element's origin for easier drawing

          let strokeColorToUse = strokeColor
          let lineWidth = scaledStroke(strokeWidth)
          if (element.state === "selected") {
            strokeColorToUse = selectedColor
            lineWidth = scaledStroke(selectedStrokeWidth)
          }
          if (element.state === "moveable") {
            strokeColorToUse = moveableColor
            lineWidth = scaledStroke(moveableStrokeWidth)
          }

          ctx.strokeStyle = strokeColorToUse
          ctx.lineWidth = lineWidth
          ctx.fillStyle = element.color

          ctx.font = `${element.fontSize || fontSize}px Arial` // Use element's font size
          ctx.textAlign = "center"
          ctx.textBaseline = "middle"

          const chars = element.text.split("")
          const charSpacing = (element.fontSize || fontSize) * 0.6
          const textWidth = chars.reduce((sum, char) => sum + ctx.measureText(char).width * 0.6, 0) // Approximate width
          const startX = -textWidth / 2 + (ctx.measureText(chars[0] || "").width * 0.6) / 2 // Centering text block

          chars.forEach((char, index) => {
            const charRenderX = startX + index * charSpacing
            const charWidth = ctx.measureText(char).width
            const charHeight = element.fontSize || fontSize
            const overlapDegree = countCharacterOverlaps(
              element.x + charRenderX,
              element.y,
              charWidth,
              charHeight,
              elements,
              element.id,
            )
            ctx.fillStyle = overlapDegree > 0 ? getOverlapColor(overlapDegree) : element.color
            ctx.fillText(char, charRenderX, 0) // Draw relative to element's translated origin
          })

          if (element.state === "selected" || element.state === "moveable") {
            const dims = getTextDimensions(element.text, element.fontSize || fontSize)
            const padding = element.state === "selected" ? 5 : 8
            ctx.strokeStyle = element.state === "selected" ? selectedColor : moveableColor
            ctx.lineWidth = scaledStroke(element.state === "selected" ? 1 : 2)
            ctx.setLineDash(element.state === "selected" ? [5, 5] : [3, 3])
            ctx.strokeRect(
              -dims.width / 2 - padding,
              -dims.height / 2 - padding,
              dims.width + padding * 2,
              dims.height + padding * 2,
            )
            ctx.setLineDash([])
          }
          ctx.restore() // Restore context for next element
        }
      })

      // 5. Draw GRAIN (if enabled)
      if (grainEnabled && grainCanvasRef.current && ctx) {
        // ensure ctx is defined
        grainOffsetRef.current.x = (grainOffsetRef.current.x + grainMovementSpeed) % grainCanvasRef.current.width
        grainOffsetRef.current.y = (grainOffsetRef.current.y + grainMovementSpeed / 2) % grainCanvasRef.current.height
        ctx.save()
        ctx.globalCompositeOperation = grainBlendMode as GlobalCompositeOperation
        const pattern = ctx.createPattern(grainCanvasRef.current, "repeat")
        if (pattern) {
          ctx.fillStyle = pattern
          ctx.translate(grainOffsetRef.current.x, grainOffsetRef.current.y)
          ctx.fillRect(
            -grainOffsetRef.current.x,
            -grainOffsetRef.current.y,
            renderWidth / scaleFactor, // Use renderWidth/Height passed to drawScene
            renderHeight / scaleFactor,
          )
        }
        ctx.restore()
      }

      ctx.restore() // Restore initial scaling
    },
    [
      elements,
      backgroundColor,
      physicsBackgroundColor,
      strokeColor,
      strokeWidth,
      selectedColor,
      moveableColor,
      physicsActive,
      isPhysicsPaused,
      fontSize,
      getTextDimensions,
      countCharacterOverlaps,
      circlesOverlap,
      getOverlapColor,
      selectedStrokeWidth,
      moveableStrokeWidth,
      distance, // distance was missing
      grainEnabled,
      grainBlendMode,
      grainMovementSpeed, // Grain props
    ],
  )

  const draw = useCallback(() => {
    const canvas = canvasRef.current
    if (!canvas) return
    const ctx = canvas.getContext("2d")
    if (!ctx) return
    const rect = canvas.getBoundingClientRect()
    drawScene(ctx, rect.width, rect.height) // Use drawScene
  }, [drawScene])

  // Screenshot function
  const handleScreenshotClick = useCallback(() => {
    const mainCanvas = canvasRef.current
    if (!mainCanvas) return

    const offscreenCanvas = document.createElement("canvas")
    const aspectRatio = mainCanvas.height / mainCanvas.width
    offscreenCanvas.width = screenshotWidth
    offscreenCanvas.height = screenshotWidth * aspectRatio

    const offscreenCtx = offscreenCanvas.getContext("2d")
    if (!offscreenCtx) return

    const scale = screenshotWidth / mainCanvas.width
    drawScene(offscreenCtx, offscreenCanvas.width, offscreenCanvas.height, scale) // Use drawScene with scale

    const link = document.createElement("a")
    link.download = "interactive-canvas.png"
    link.href = offscreenCanvas.toDataURL("image/png")
    link.click()
  }, [screenshotWidth, drawScene])

  const handleMouseDown = useCallback(
    (e: MouseEvent) => {
      e.preventDefault()
      handleMouseInteraction()
      const { x, y } = getCanvasCoordinates(e)
      const result = findElementAt(x, y)
      if (result) {
        const { element, index } = result
        setMoveableElementIndex(index)
        setSelectedElementIndex(-1)
        setPhysicsActive(false)
        setDragOffset({ x: x - element.x, y: y - element.y })
      } else {
        setMoveableElementIndex(-1)
        setSelectedElementIndex(-1)
        const newElementId = generateId()
        const newElement: Element = {
          id: newElementId,
          x,
          y,
          radius: 5,
          color: circleColor,
          type: "circle",
          state: "default",
          vx: 0,
          vy: 0,
          mass: 1,
        }
        setElements((prev) => [...prev, newElement])
        setIsCreatingElement(true)
        setCreationStart({ x, y })
        creatingElementId.current = newElementId
      }
    },
    [findElementAt, handleMouseInteraction, circleColor],
  )

  const handleMouseMove = useCallback(
    (e: MouseEvent) => {
      const { x, y } = getCanvasCoordinates(e)
      if (isCreatingElement && creationStart && creatingElementId.current) {
        const dragDistance = distance(creationStart.x, creationStart.y, x, y)
        const newRadius = Math.max(minRadius, Math.min(maxRadius, dragDistance))
        setElements((prev) =>
          prev.map((el) =>
            el.id === creatingElementId.current ? { ...el, radius: newRadius, mass: newRadius / 10 } : el,
          ),
        )
      } else if (moveableElementIndex >= 0 && e.buttons === 1) {
        const canvas = canvasRef.current
        if (!canvas) return
        const rect = canvas.getBoundingClientRect()
        const moveableElement = elements[moveableElementIndex]
        if (moveableElement) {
          const halfW = moveableElement.type === "rectangle" ? moveableElement.width! / 2 : moveableElement.radius
          const halfH = moveableElement.type === "rectangle" ? moveableElement.height! / 2 : moveableElement.radius
          const newX = Math.max(halfW, Math.min(rect.width - halfW, x - dragOffset.x))
          const newY = Math.max(halfH, Math.min(rect.height - halfH, y - dragOffset.y))
          setElements((prev) =>
            prev.map((el, idx) => (idx === moveableElementIndex ? { ...el, x: newX, y: newY } : el)),
          )
        }
      } else {
        handleMouseInteraction()
        const result = findElementAt(x, y)
        setHoverElementId(result?.element.id || null)
      }
    },
    [
      moveableElementIndex,
      dragOffset,
      findElementAt,
      handleMouseInteraction,
      isCreatingElement,
      creationStart,
      minRadius,
      maxRadius,
      elements,
    ],
  )

  const handleMouseUp = useCallback(() => {
    if (isCreatingElement && creatingElementId.current) {
      setIsCreatingElement(false)
      setCreationStart(null)
      creatingElementId.current = null
    }
    // if (moveableElementIndex >= 0) setMoveableElementIndex(-1) // Keep moveable if dragging ended
  }, [isCreatingElement, moveableElementIndex]) // Removed moveableElementIndex to keep it moveable

  const handleTouchStart = useCallback(
    (e: TouchEvent) => {
      e.preventDefault()
      handleMouseInteraction()
      if (e.touches.length === 2) {
        const touch1 = e.touches[0],
          touch2 = e.touches[1]
        const center = getTouchCenter(touch1, touch2)
        const result = findElementAt(center.x, center.y)
        if (result) {
          const { element, index } = result
          setIsPinching(true)
          setPinchStartDistance(getTouchDistance(touch1, touch2))
          setPinchStartRadius(element.radius)
          setPinchElementIndex(index)
          setMoveableElementIndex(index)
          setSelectedElementIndex(-1)
          setPhysicsActive(false)
        }
      } else if (e.touches.length === 1) {
        const { x, y } = getCanvasCoordinates(e)
        const result = findElementAt(x, y)
        if (result) {
          const { element, index } = result
          setMoveableElementIndex(index)
          setSelectedElementIndex(-1)
          setPhysicsActive(false)
          setDragOffset({ x: x - element.x, y: y - element.y })
        } else {
          setMoveableElementIndex(-1)
          setSelectedElementIndex(-1)
          const newElementId = generateId()
          const newElement: Element = {
            id: newElementId,
            x,
            y,
            radius: 5,
            color: circleColor,
            type: "circle",
            state: "default",
            vx: 0,
            vy: 0,
            mass: 1,
          }
          setElements((prev) => [...prev, newElement])
          setIsCreatingElement(true)
          setCreationStart({ x, y })
          creatingElementId.current = newElementId
        }
      }
    },
    [findElementAt, handleMouseInteraction, circleColor],
  )

  const handleTouchMove = useCallback(
    (e: TouchEvent) => {
      e.preventDefault()
      if (isPinching && e.touches.length === 2 && pinchElementIndex >= 0) {
        const touch1 = e.touches[0],
          touch2 = e.touches[1]
        const currentDistance = getTouchDistance(touch1, touch2)
        const scale = currentDistance / pinchStartDistance
        const element = elements[pinchElementIndex]
        if (element.type === "circle") {
          const newRadius = Math.max(minRadius, Math.min(maxRadius, pinchStartRadius * scale))
          setLastUsedRadius(newRadius)
          setElements((prev) =>
            prev.map((el, idx) =>
              idx === pinchElementIndex ? { ...el, radius: newRadius, mass: newRadius / 10 } : el,
            ),
          )
        } else if (element.type === "text") {
          const newFontSize = Math.max(16, Math.min(72, (element.fontSize || fontSize) * scale))
          const newRadius = Math.max(newFontSize / 2, 20)
          setElements((prev) =>
            prev.map((el, idx) =>
              idx === pinchElementIndex
                ? { ...el, fontSize: newFontSize, radius: newRadius, mass: newRadius / 10 }
                : el,
            ),
          )
        } else if (element.type === "rectangle") {
          const newWidth = Math.max(10, (element.width || 50) * scale)
          const newHeight = Math.max(10, (element.height || 50) * scale)
          const newRadius = Math.sqrt(newWidth * newWidth + newHeight * newHeight) / 2
          setElements((prev) =>
            prev.map((el, idx) =>
              idx === pinchElementIndex
                ? { ...el, width: newWidth, height: newHeight, radius: newRadius, mass: newRadius / 10 }
                : el,
            ),
          )
        }
      } else if (e.touches.length === 1) {
        const { x, y } = getCanvasCoordinates(e)
        if (isCreatingElement && creationStart && creatingElementId.current) {
          const dragDistance = distance(creationStart.x, creationStart.y, x, y)
          const newRadius = Math.max(minRadius, Math.min(maxRadius, dragDistance))
          setElements((prev) =>
            prev.map((el) =>
              el.id === creatingElementId.current ? { ...el, radius: newRadius, mass: newRadius / 10 } : el,
            ),
          )
        } else if (moveableElementIndex >= 0) {
          const canvas = canvasRef.current
          if (!canvas) return
          const rect = canvas.getBoundingClientRect()
          const moveableElement = elements[moveableElementIndex]
          if (moveableElement) {
            const halfW = moveableElement.type === "rectangle" ? moveableElement.width! / 2 : moveableElement.radius
            const halfH = moveableElement.type === "rectangle" ? moveableElement.height! / 2 : moveableElement.radius
            const newX = Math.max(halfW, Math.min(rect.width - halfW, x - dragOffset.x))
            const newY = Math.max(halfH, Math.min(rect.height - halfH, y - dragOffset.y))
            setElements((prev) =>
              prev.map((el, idx) => (idx === moveableElementIndex ? { ...el, x: newX, y: newY } : el)),
            )
          }
        }
      }
    },
    [
      isPinching,
      pinchElementIndex,
      pinchStartDistance,
      pinchStartRadius,
      minRadius,
      maxRadius,
      isCreatingElement,
      creationStart,
      moveableElementIndex,
      dragOffset,
      lastUsedRadius,
      fontSize,
      elements,
    ],
  )

  const handleTouchEnd = useCallback(
    (e: TouchEvent) => {
      e.preventDefault()
      if (isPinching) {
        setIsPinching(false)
        setPinchStartDistance(0)
        setPinchStartRadius(0)
        setPinchElementIndex(-1)
      }
      if (isCreatingElement && creatingElementId.current && e.touches.length === 0) {
        setIsCreatingElement(false)
        setCreationStart(null)
        creatingElementId.current = null
      }
      // Do not reset moveableElementIndex on touch end to allow further interaction
    },
    [isPinching, isCreatingElement],
  )

  const handleContainerClick = useCallback(() => containerRef.current?.focus(), [])

  useEffect(() => {
    const canvas = canvasRef.current,
      container = containerRef.current
    if (!canvas || !container) return
    const resizeCanvas = () => {
      const rect = container.getBoundingClientRect()
      canvas.width = rect.width
      canvas.height = rect.height
      // canvas.style.width = `${rect.width}px`; canvas.style.height = `${rect.height}px` // Already handled by 100%
      draw()
    }
    resizeCanvas()
    canvas.addEventListener("mousedown", handleMouseDown)
    canvas.addEventListener("mousemove", handleMouseMove)
    window.addEventListener("mouseup", handleMouseUp) // Listen on window for mouseup
    canvas.addEventListener("touchstart", handleTouchStart, { passive: false })
    canvas.addEventListener("touchmove", handleTouchMove, { passive: false })
    canvas.addEventListener("touchend", handleTouchEnd, { passive: false })
    canvas.addEventListener("mouseleave", () => setHoverElementId(null))
    canvas.addEventListener("wheel", handleWheel, { passive: false })
    container.addEventListener("keydown", handleKeyDown)
    container.addEventListener("keyup", handleKeyUp) // Added keyup
    container.focus()
    window.addEventListener("resize", resizeCanvas)
    return () => {
      canvas.removeEventListener("mousedown", handleMouseDown)
      canvas.removeEventListener("mousemove", handleMouseMove)
      window.removeEventListener("mouseup", handleMouseUp)
      canvas.removeEventListener("touchstart", handleTouchStart)
      canvas.removeEventListener("touchmove", handleTouchMove)
      canvas.removeEventListener("touchend", handleTouchEnd)
      canvas.removeEventListener("mouseleave", () => setHoverElementId(null))
      canvas.removeEventListener("wheel", handleWheel)
      container.removeEventListener("keydown", handleKeyDown)
      container.removeEventListener("keyup", handleKeyUp) // Added keyup
      window.removeEventListener("resize", resizeCanvas)
      if (mouseInteractionTimeoutRef.current) clearTimeout(mouseInteractionTimeoutRef.current)
    }
  }, [
    handleMouseDown,
    handleMouseMove,
    handleMouseUp,
    handleTouchStart,
    handleTouchMove,
    handleTouchEnd,
    handleKeyDown,
    handleKeyUp,
    draw,
    handleWheel,
  ]) // Added handleKeyUp

  // Effect for generating grain pattern
  useEffect(() => {
    if (grainEnabled) {
      const tempGrainCanvas = document.createElement("canvas")
      const size = 128 // Size of the grain pattern tile
      tempGrainCanvas.width = size
      tempGrainCanvas.height = size
      const grainCtx = tempGrainCanvas.getContext("2d")
      if (grainCtx) {
        const imageData = grainCtx.createImageData(size, size)
        const data = imageData.data
        for (let i = 0; i < data.length; i += 4) {
          const value = (Math.random() * 255) | 0
          data[i] = value // R
          data[i + 1] = value // G
          data[i + 2] = value // B
          data[i + 3] = grainSize * 25.5 // Alpha (0-255), grainSize (0-10) -> (0-255)
        }
        grainCtx.putImageData(imageData, 0, 0)
        grainCanvasRef.current = tempGrainCanvas
      }
    } else {
      grainCanvasRef.current = null // Clear if disabled
    }
    draw() // Redraw when grain settings change
  }, [grainEnabled, grainSize, draw])

  useEffect(draw, [elements, draw]) // draw depends on elements and other state, so this is fine.

  return (
    <motion.div
      ref={containerRef}
      onClick={handleContainerClick}
      style={{
        ...style,
        width: "100%",
        height: "100%",
        minHeight: "400px",
        position: "relative",
        overflow: "hidden",
        outline: "none",
        cursor: "crosshair",
      }}
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ duration: 0.3 }}
      tabIndex={0}
    >
      <canvas ref={canvasRef} style={{ display: "block", width: "100%", height: "100%", touchAction: "none" }} />

      {showInstructions && (
        <>
          {elements.length === 0 && (
            <div
              style={{
                position: "absolute",
                top: "50%",
                left: "50%",
                transform: "translate(-50%, -50%)",
                textAlign: "center",
                pointerEvents: "none",
                color: "#666",
                fontSize: "16px",
              }}
            >
              <div>Press letters, numbers (0-9), or Shift+numbers for shapes</div>
              <div style={{ fontSize: "14px", marginTop: "8px" }}>
                Arrow keys to select • Space to move/pause • Enter for gravity • ESC/Delete to clear/remove
              </div>
            </div>
          )}
          <div
            style={{
              position: "absolute",
              top: "10px",
              left: "10px",
              background: "rgba(0,0,0,0.7)",
              color: "white",
              padding: "10px",
              borderRadius: "5px",
              fontSize: "12px",
              pointerEvents: "none",
              opacity: elements.length > 0 ? 1 : 0,
              transition: "opacity 0.3s",
            }}
          >
            <div>🎮 Controls:</div>
            <div>A-Z: Text • 0-9: Circles • Shift+0-9: Rects</div>
            <div>Arrows: Select/Move • Space: Toggle Move / Pause Gravity</div>
            <div>Enter: Gravity • ESC: Clear All • Del/Backspace: Remove Selected</div>
            {selectedElementIndex >= 0 && keyboardMode && <div>📍 Selected: Element {selectedElementIndex + 1}</div>}
            {moveableElementIndex >= 0 && <div>🎯 Moving: Element {moveableElementIndex + 1}</div>}
            {physicsActive && (
              <div>
                🌍 Gravity: {gravityDirection.toUpperCase()} {isPhysicsPaused ? "(PAUSED)" : ""}
              </div>
            )}
          </div>
        </>
      )}
      {enableScreenshot && (
        <button
          onClick={handleScreenshotClick}
          title="Download Screenshot"
          style={{
            position: "absolute",
            top: "10px",
            right: "10px",
            background: "rgba(0,0,0,0.7)",
            color: "white",
            border: "none",
            borderRadius: "5px",
            padding: "8px",
            cursor: "pointer",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
          }}
        >
          <img src={screenshotIcon || "/placeholder.svg"} alt="Screenshot" style={{ width: "20px", height: "20px" }} />
        </button>
      )}
    </motion.div>
  )
}

addPropertyControls(InteractiveCanvas, {
  backgroundColor: { type: ControlType.Color, title: "Background", defaultValue: "#f0f0f0" },
  physicsBackgroundColor: { type: ControlType.Color, title: "Physics BG", defaultValue: "#e8f4f8" },
  circleColor: { type: ControlType.Color, title: "Circle Color", defaultValue: "#3b82f6" },
  textColor: { type: ControlType.Color, title: "Text Color", defaultValue: "#2563eb" },
  rectangleColor: { type: ControlType.Color, title: "Rectangle Color", defaultValue: "#10b981" }, // New
  selectedColor: { type: ControlType.Color, title: "Selected/Hover", defaultValue: "#ff00ff" },
  moveableColor: { type: ControlType.Color, title: "Moveable", defaultValue: "#ff0000" },
  strokeColor: { type: ControlType.Color, title: "Stroke", defaultValue: "#000000" },
  strokeWidth: { type: ControlType.Number, title: "Stroke Width", min: 1, max: 10, defaultValue: 2 },
  selectedStrokeWidth: { type: ControlType.Number, title: "Selected Stroke", min: 1, max: 10, defaultValue: 3 },
  moveableStrokeWidth: { type: ControlType.Number, title: "Moveable Stroke", min: 1, max: 10, defaultValue: 4 },
  overlapColor2: { type: ControlType.Color, title: "2-Overlap Color", defaultValue: "#ff6b35" },
  overlapColor3: { type: ControlType.Color, title: "3-Overlap Color", defaultValue: "#ff3535" },
  overlapColor4: { type: ControlType.Color, title: "4+ Overlap Color", defaultValue: "#ff0000" },
  fontSize: { type: ControlType.Number, title: "Font Size", min: 16, max: 72, defaultValue: 32 },
  movementSpeed: { type: ControlType.Number, title: "Move Speed", min: 5, max: 50, defaultValue: 15 },
  initialRadius: { type: ControlType.Number, title: "Initial Radius", min: 10, max: 200, defaultValue: 40 },
  minRadius: { type: ControlType.Number, title: "Min Radius", min: 5, max: 100, defaultValue: 20 },
  maxRadius: { type: ControlType.Number, title: "Max Radius", min: 50, max: 300, defaultValue: 100 },
  gravity: { type: ControlType.Number, title: "Gravity", min: 0.1, max: 2, step: 0.1, defaultValue: 0.5 },
  friction: { type: ControlType.Number, title: "Friction", min: 0.9, max: 1, step: 0.01, defaultValue: 0.98 },
  bounciness: { type: ControlType.Number, title: "Bounciness", min: 0, max: 1, step: 0.1, defaultValue: 0.7 },
  // New Framer Controls
  showInstructions: { type: ControlType.Boolean, title: "Show Instructions", defaultValue: true },
  grainEnabled: { type: ControlType.Boolean, title: "Enable Grain", defaultValue: false },
  grainBlendMode: {
    type: ControlType.Enum,
    title: "Grain Blend Mode",
    options: ["overlay", "multiply", "screen", "soft-light", "lighter", "difference", "exclusion"],
    defaultValue: "overlay",
    hidden: (props) => !props.grainEnabled,
  },
  grainSize: {
    type: ControlType.Number,
    title: "Grain Opacity",
    min: 0,
    max: 10,
    step: 0.5,
    defaultValue: 2,
    hidden: (props) => !props.grainEnabled,
  },
  grainMovementSpeed: {
    type: ControlType.Number,
    title: "Grain Speed",
    min: 0,
    max: 10,
    step: 0.1,
    defaultValue: 1,
    hidden: (props) => !props.grainEnabled,
  },
  enableScreenshot: { type: ControlType.Boolean, title: "Screenshot Button", defaultValue: true },
  screenshotIcon: {
    type: ControlType.Image,
    title: "Screenshot Icon",
    hidden: (props) => !props.enableScreenshot,
    defaultValue: "/camera-icon.svg",
  },
  screenshotWidth: {
    type: ControlType.Number,
    title: "Screenshot Width (px)",
    defaultValue: 1920,
    min: 800,
    max: 8000,
    step: 100,
    hidden: (props) => !props.enableScreenshot,
  },
  canvasPadding: {
    type: ControlType.Number,
    title: "Canvas Padding",
    defaultValue: 10,
    min: 0,
    max: 100,
  },
})
