"use client"

import { useEffect, useRef, useState, useCallback } from "react"
import { addPropertyControls, ControlType } from "framer"
import { motion } from "framer-motion"

interface Element {
  id: string
  x: number
  y: number
  radius: number
  color: string
  state: "default" | "selected" | "moveable"
  type: "circle" | "text"
  text?: string
  fontSize?: number
  // Physics properties
  vx: number
  vy: number
  mass: number
}

/**
 * @framerDisableUnlink
 * @framerSupportedLayoutWidth any
 * @framerSupportedLayoutHeight any
 * @framerIntrinsicWidth 800
 * @framerIntrinsicHeight 600
 */
export default function InteractiveCanvas(props) {
  const {
    backgroundColor = "#f0f0f0",
    physicsBackgroundColor = "#e8f4f8",
    circleColor = "#3b82f6",
    textColor = "#2563eb",
    hoverColor = "#00ff00",
    selectedColor = "#ff00ff",
    moveableColor = "#ff0000",
    strokeColor = "#000000",
    minRadius = 20,
    maxRadius = 100,
    initialRadius = 40,
    fontSize = 32,
    movementSpeed = 15,
    gravity = 0.5,
    friction = 0.98,
    bounciness = 0.7,
    style,
  } = props

  const containerRef = useRef<HTMLDivElement>(null)
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const animationFrameRef = useRef<number>()
  const mouseInteractionTimeoutRef = useRef<NodeJS.Timeout>()

  const [elements, setElements] = useState<Element[]>([])
  const [selectedElementIndex, setSelectedElementIndex] = useState<number>(-1)
  const [moveableElementIndex, setMoveableElementIndex] = useState<number>(-1)
  const [hoverElementId, setHoverElementId] = useState<string | null>(null)
  const [keyboardMode, setKeyboardMode] = useState(false)
  const [dragOffset, setDragOffset] = useState<{ x: number; y: number }>({ x: 0, y: 0 })
  const [physicsActive, setPhysicsActive] = useState(false)
  const [isCreatingElement, setIsCreatingElement] = useState(false)
  const [creationStart, setCreationStart] = useState<{ x: number; y: number } | null>(null)
  const [creatingElementId, setCreatingElementId] = useState<string | null>(null)

  // Pinch gesture state
  const [isPinching, setIsPinching] = useState(false)
  const [pinchStartDistance, setPinchStartDistance] = useState(0)
  const [pinchStartRadius, setPinchStartRadius] = useState(0)
  const [pinchElementIndex, setPinchElementIndex] = useState(-1)

  const [isClearing, setIsClearing] = useState(false)
  const [wasPhysicsActiveBeforeClearing, setWasPhysicsActiveBeforeClearing] = useState(false)
  const [lastUsedRadius, setLastUsedRadius] = useState(initialRadius)

  // Generate unique ID for elements
  const generateId = () => Math.random().toString(36).substr(2, 9)

  // Calculate distance between two points
  const distance = (x1: number, y1: number, x2: number, y2: number) => {
    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
  }

  // Calculate distance between two touch points
  const getTouchDistance = (touch1: Touch, touch2: Touch) => {
    const dx = touch2.clientX - touch1.clientX
    const dy = touch2.clientY - touch1.clientY
    return Math.sqrt(dx * dx + dy * dy)
  }

  // Get center point between two touches
  const getTouchCenter = (touch1: Touch, touch2: Touch) => {
    const rect = canvasRef.current?.getBoundingClientRect()
    if (!rect) return { x: 0, y: 0 }

    return {
      x: (touch1.clientX + touch2.clientX) / 2 - rect.left,
      y: (touch1.clientY + touch2.clientY) / 2 - rect.top,
    }
  }

  // Get text dimensions
  const getTextDimensions = useCallback((text: string, fontSize: number) => {
    const canvas = canvasRef.current
    if (!canvas) return { width: 0, height: 0 }

    const ctx = canvas.getContext("2d")
    if (!ctx) return { width: 0, height: 0 }

    ctx.font = `${fontSize}px Arial`
    const metrics = ctx.measureText(text)
    return {
      width: metrics.width,
      height: fontSize,
    }
  }, [])

  // Find element at position
  const findElementAt = useCallback(
    (x: number, y: number): { element: Element; index: number } | null => {
      for (let i = elements.length - 1; i >= 0; i--) {
        const element = elements[i]

        if (element.type === "circle") {
          if (distance(x, y, element.x, element.y) <= element.radius) {
            return { element, index: i }
          }
        } else if (element.type === "text" && element.text) {
          const dims = getTextDimensions(element.text, element.fontSize || fontSize)
          const halfWidth = dims.width / 2
          const halfHeight = dims.height / 2

          if (
            x >= element.x - halfWidth &&
            x <= element.x + halfWidth &&
            y >= element.y - halfHeight &&
            y <= element.y + halfHeight
          ) {
            return { element, index: i }
          }
        }
      }
      return null
    },
    [elements, getTextDimensions, fontSize],
  )

  // Find the most empty area on canvas
  const findMostEmptyArea = useCallback(() => {
    const canvas = canvasRef.current
    if (!canvas) return { x: canvas?.width / 2 || 400, y: canvas?.height / 2 || 300 }

    const gridSize = 50
    const cols = Math.ceil(canvas.width / gridSize)
    const rows = Math.ceil(canvas.height / gridSize)

    let bestScore = Number.POSITIVE_INFINITY
    let bestX = canvas.width / 2
    let bestY = canvas.height / 2

    // Check each grid cell
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const centerX = (col + 0.5) * gridSize
        const centerY = (row + 0.5) * gridSize

        // Skip if too close to edges
        if (
          centerX < initialRadius ||
          centerX > canvas.width - initialRadius ||
          centerY < initialRadius ||
          centerY > canvas.height - initialRadius
        ) {
          continue
        }

        // Count overlapping elements
        let score = 0
        elements.forEach((element) => {
          const dist = distance(centerX, centerY, element.x, element.y)
          if (dist < element.radius + initialRadius + 20) {
            score += element.radius + initialRadius + 20 - dist
          }
        })

        if (score < bestScore) {
          bestScore = score
          bestX = centerX
          bestY = centerY
        }
      }
    }

    return { x: bestX, y: bestY }
  }, [elements, initialRadius])

  // Get canvas coordinates from event
  const getCanvasCoordinates = (e: MouseEvent | TouchEvent) => {
    const rect = canvasRef.current?.getBoundingClientRect()
    if (!rect) return { x: 0, y: 0 }

    let clientX, clientY
    if (e instanceof MouseEvent) {
      clientX = e.clientX
      clientY = e.clientY
    } else {
      clientX = e.touches[0]?.clientX || e.changedTouches[0]?.clientX || 0
      clientY = e.touches[0]?.clientY || e.changedTouches[0]?.clientY || 0
    }

    return {
      x: clientX - rect.left,
      y: clientY - rect.top,
    }
  }

  // Get selected element
  const getSelectedElement = useCallback(() => {
    if (selectedElementIndex >= 0 && selectedElementIndex < elements.length) {
      return elements[selectedElementIndex]
    }
    return null
  }, [elements, selectedElementIndex])

  // Get moveable element
  const getMoveableElement = useCallback(() => {
    if (moveableElementIndex >= 0 && moveableElementIndex < elements.length) {
      return elements[moveableElementIndex]
    }
    return null
  }, [elements, moveableElementIndex])

  // Find nearest element in a direction
  const findNearestElementInDirection = useCallback(
    (direction: "left" | "right" | "up" | "down") => {
      const currentElement = getSelectedElement()
      if (elements.length <= 1) return -1

      if (!currentElement) {
        return 0
      }

      const candidates: Array<{
        index: number
        distance: number
        alignmentScore: number
      }> = []

      elements.forEach((element, index) => {
        if (element.id === currentElement.id) return

        const dx = element.x - currentElement.x
        const dy = element.y - currentElement.y
        const distance = Math.sqrt(dx * dx + dy * dy)

        if (distance < 5) return

        let isInDirection = false
        let alignmentScore = 0

        switch (direction) {
          case "right":
            isInDirection = dx > 0
            alignmentScore = Math.abs(dy)
            break
          case "left":
            isInDirection = dx < 0
            alignmentScore = Math.abs(dy)
            break
          case "down":
            isInDirection = dy > 0
            alignmentScore = Math.abs(dx)
            break
          case "up":
            isInDirection = dy < 0
            alignmentScore = Math.abs(dx)
            break
        }

        if (isInDirection) {
          candidates.push({
            index,
            distance,
            alignmentScore,
          })
        }
      })

      if (candidates.length === 0) return -1

      candidates.sort((a, b) => {
        const alignmentDiff = a.alignmentScore - b.alignmentScore
        if (Math.abs(alignmentDiff) > 20) {
          return alignmentDiff
        }
        return a.distance - b.distance
      })

      return candidates[0].index
    },
    [elements, getSelectedElement],
  )

  // Clear selection when switching to mouse mode
  const handleMouseInteraction = useCallback(() => {
    if (keyboardMode) {
      setKeyboardMode(false)
      if (mouseInteractionTimeoutRef.current) {
        clearTimeout(mouseInteractionTimeoutRef.current)
      }
      mouseInteractionTimeoutRef.current = setTimeout(() => {
        setSelectedElementIndex(-1)
      }, 100)
    }
  }, [keyboardMode])

  // Physics simulation
  const updatePhysics = useCallback(() => {
    const canvas = canvasRef.current
    if (!canvas || !physicsActive) return

    setElements((prevElements) => {
      const newElements = [...prevElements]
      let hasMovement = false

      // Apply gravity and update positions
      for (let i = 0; i < newElements.length; i++) {
        const element = newElements[i]

        // Skip physics for moveable elements
        if (element.state === "moveable") continue

        // Apply gravity
        element.vy += gravity

        // Apply friction
        element.vx *= friction
        element.vy *= friction

        // Update position
        element.x += element.vx
        element.y += element.vy

        // Check boundaries
        if (element.y + element.radius > canvas.height) {
          if (isClearing) {
            // During clearing, let elements fall through the floor
            continue
          } else {
            element.y = canvas.height - element.radius
            element.vy *= -bounciness
            if (Math.abs(element.vy) < 0.5) element.vy = 0
          }
        }

        if (element.x - element.radius < 0) {
          element.x = element.radius
          element.vx *= -bounciness
        }
        if (element.x + element.radius > canvas.width) {
          element.x = canvas.width - element.radius
          element.vx *= -bounciness
        }

        if (Math.abs(element.vx) > 0.1 || Math.abs(element.vy) > 0.1) {
          hasMovement = true
        }
      }

      // Element-to-element collisions
      for (let i = 0; i < newElements.length; i++) {
        for (let j = i + 1; j < newElements.length; j++) {
          const element1 = newElements[i]
          const element2 = newElements[j]

          // Skip collisions if either element is moveable
          if (element1.state === "moveable" || element2.state === "moveable") continue

          const dx = element2.x - element1.x
          const dy = element2.y - element1.y
          const dist = Math.sqrt(dx * dx + dy * dy)
          const minDist = element1.radius + element2.radius

          if (dist < minDist) {
            hasMovement = true

            const nx = dx / dist
            const ny = dy / dist

            const overlap = minDist - dist
            const separationX = (overlap * nx) / 2
            const separationY = (overlap * ny) / 2

            element1.x -= separationX
            element1.y -= separationY
            element2.x += separationX
            element2.y += separationY

            const dvx = element2.vx - element1.vx
            const dvy = element2.vy - element1.vy
            const dvn = dvx * nx + dvy * ny

            if (dvn > 0) continue

            const impulse = (2 * dvn) / (element1.mass + element2.mass)

            element1.vx += impulse * element2.mass * nx * bounciness
            element1.vy += impulse * element2.mass * ny * bounciness
            element2.vx -= impulse * element1.mass * nx * bounciness
            element2.vy -= impulse * element1.mass * ny * bounciness
          }
        }
      }

      // Stop physics if no movement
      if (!hasMovement) {
        setTimeout(() => setPhysicsActive(false), 100)
      }

      return newElements
    })
  }, [physicsActive, gravity, friction, bounciness, isClearing])

  // Physics animation loop
  useEffect(() => {
    if (physicsActive) {
      const animate = () => {
        updatePhysics()
        animationFrameRef.current = requestAnimationFrame(animate)
      }
      animationFrameRef.current = requestAnimationFrame(animate)
    } else {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
      }
    }

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
      }
    }
  }, [physicsActive, updatePhysics])

  // Check if clearing is complete
  useEffect(() => {
    if (isClearing && elements.length > 0) {
      const canvas = canvasRef.current
      if (!canvas) return

      const allElementsFallen = elements.every((element) => element.y - element.radius > canvas.height)

      if (allElementsFallen) {
        // All elements have fallen off screen
        setElements([])
        setIsClearing(false)
        setSelectedElementIndex(-1)
        setMoveableElementIndex(-1)
        setHoverElementId(null)

        // Restore physics state
        if (!wasPhysicsActiveBeforeClearing) {
          setPhysicsActive(false)
        }
      }
    }
  }, [elements, isClearing, wasPhysicsActiveBeforeClearing])

  // Handle keyboard events
  const handleKeyDown = useCallback(
    (e: KeyboardEvent) => {
      const canvas = canvasRef.current
      if (!canvas) return

      setKeyboardMode(true)
      if (mouseInteractionTimeoutRef.current) {
        clearTimeout(mouseInteractionTimeoutRef.current)
      }

      const moveableElement = getMoveableElement()

      switch (e.key) {
        case "ArrowUp":
          e.preventDefault()
          if (moveableElement) {
            setElements((prev) =>
              prev.map((element, index) =>
                index === moveableElementIndex
                  ? { ...element, y: Math.max(element.radius, element.y - movementSpeed) }
                  : element,
              ),
            )
          } else {
            if (elements.length > 0) {
              const nearestIndex = findNearestElementInDirection("up")
              if (nearestIndex >= 0) {
                setSelectedElementIndex(nearestIndex)
              } else if (selectedElementIndex < 0) {
                setSelectedElementIndex(0)
              }
            }
          }
          break

        case "ArrowDown":
          e.preventDefault()
          if (moveableElement) {
            setElements((prev) =>
              prev.map((element, index) =>
                index === moveableElementIndex
                  ? { ...element, y: Math.min(canvas.height - element.radius, element.y + movementSpeed) }
                  : element,
              ),
            )
          } else {
            if (elements.length > 0) {
              const nearestIndex = findNearestElementInDirection("down")
              if (nearestIndex >= 0) {
                setSelectedElementIndex(nearestIndex)
              } else if (selectedElementIndex < 0) {
                setSelectedElementIndex(0)
              }
            }
          }
          break

        case "ArrowLeft":
          e.preventDefault()
          if (moveableElement) {
            setElements((prev) =>
              prev.map((element, index) =>
                index === moveableElementIndex
                  ? { ...element, x: Math.max(element.radius, element.x - movementSpeed) }
                  : element,
              ),
            )
          } else {
            if (elements.length > 0) {
              const nearestIndex = findNearestElementInDirection("left")
              if (nearestIndex >= 0) {
                setSelectedElementIndex(nearestIndex)
              } else if (selectedElementIndex < 0) {
                setSelectedElementIndex(0)
              }
            }
          }
          break

        case "ArrowRight":
          e.preventDefault()
          if (moveableElement) {
            setElements((prev) =>
              prev.map((element, index) =>
                index === moveableElementIndex
                  ? { ...element, x: Math.min(canvas.width - element.radius, element.x + movementSpeed) }
                  : element,
              ),
            )
          } else {
            if (elements.length > 0) {
              const nearestIndex = findNearestElementInDirection("right")
              if (nearestIndex >= 0) {
                setSelectedElementIndex(nearestIndex)
              } else if (selectedElementIndex < 0) {
                setSelectedElementIndex(0)
              }
            }
          }
          break

        case " ": // Space key - toggle moveable state
          e.preventDefault()
          if (moveableElementIndex >= 0) {
            // Stop moving
            setMoveableElementIndex(-1)
          } else if (selectedElementIndex >= 0) {
            // Start moving
            setMoveableElementIndex(selectedElementIndex)
            setSelectedElementIndex(-1)
          }
          break

        case "Enter":
        case "Return": // Enter key - toggle gravity
          e.preventDefault()
          if (elements.length > 0) {
            if (physicsActive) {
              setPhysicsActive(false)
            } else {
              // Reset physics properties and start gravity
              setElements((prev) =>
                prev.map((element) => ({
                  ...element,
                  vx: (Math.random() - 0.5) * 2,
                  vy: Math.random() * -2,
                  mass: element.radius / 10,
                })),
              )
              setPhysicsActive(true)
            }
          }
          break

        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
        case "0":
          e.preventDefault()
          const numberValue = e.key === "0" ? 10 : Number.parseInt(e.key)
          const newRadius = Math.max(
            minRadius,
            Math.min(maxRadius, minRadius + (numberValue - 1) * ((maxRadius - minRadius) / 9)),
          )

          // Remember this radius for future use
          setLastUsedRadius(newRadius)

          const emptyArea = findMostEmptyArea()
          const newElementId = generateId()
          const newElement: Element = {
            id: newElementId,
            x: emptyArea.x,
            y: emptyArea.y,
            radius: newRadius,
            color: circleColor,
            type: "circle",
            state: "moveable",
            vx: 0,
            vy: 0,
            mass: newRadius / 10,
          }
          setElements((prev) => [...prev, newElement])
          setMoveableElementIndex(elements.length)
          setSelectedElementIndex(-1)
          break

        case "Escape":
          e.preventDefault()
          if (elements.length > 0) {
            // Start clearing process
            setIsClearing(true)
            setWasPhysicsActiveBeforeClearing(physicsActive)

            if (!physicsActive) {
              // Turn on physics if it wasn't already on
              setElements((prev) =>
                prev.map((element) => ({
                  ...element,
                  vx: (Math.random() - 0.5) * 2,
                  vy: Math.random() * -2,
                  mass: element.radius / 10,
                })),
              )
              setPhysicsActive(true)
            }

            // Clear any selected/moveable states
            setSelectedElementIndex(-1)
            setMoveableElementIndex(-1)
          }
          break

        default:
          // Handle letter keys
          if (e.key.length === 1 && e.key.match(/[a-zA-Z]/)) {
            e.preventDefault()
            const letter = e.key.toLowerCase()
            const emptyArea = findMostEmptyArea()
            const newElementId = generateId()
            const textRadius = Math.max(fontSize / 2, 20) // Use font size to determine collision radius

            const newElement: Element = {
              id: newElementId,
              x: emptyArea.x,
              y: emptyArea.y,
              radius: textRadius,
              color: textColor,
              type: "text",
              text: letter,
              fontSize: fontSize,
              state: "moveable",
              vx: 0,
              vy: 0,
              mass: textRadius / 10,
            }
            setElements((prev) => [...prev, newElement])
            setMoveableElementIndex(elements.length)
            setSelectedElementIndex(-1)
          }
          break
      }
    },
    [
      elements,
      selectedElementIndex,
      moveableElementIndex,
      movementSpeed,
      initialRadius,
      circleColor,
      textColor,
      minRadius,
      maxRadius,
      physicsActive,
      getSelectedElement,
      getMoveableElement,
      findNearestElementInDirection,
      findMostEmptyArea,
      lastUsedRadius,
      fontSize,
    ],
  )

  // Update element states
  useEffect(() => {
    setElements((prev) =>
      prev.map((element, index) => {
        let state: Element["state"] = "default"

        if (index === moveableElementIndex) {
          state = "moveable"
        } else if (index === selectedElementIndex && keyboardMode) {
          state = "selected"
        } else if (element.id === hoverElementId && !keyboardMode) {
          state = "selected"
        }

        return { ...element, state }
      }),
    )
  }, [selectedElementIndex, moveableElementIndex, hoverElementId, keyboardMode])

  // Drawing function
  const draw = useCallback(() => {
    const canvas = canvasRef.current
    if (!canvas) return

    const ctx = canvas.getContext("2d")
    if (!ctx) return

    // Clear canvas with dynamic background
    ctx.fillStyle = physicsActive ? physicsBackgroundColor : backgroundColor
    ctx.fillRect(0, 0, canvas.width, canvas.height)

    // Draw elements
    elements.forEach((element) => {
      if (element.type === "circle") {
        ctx.beginPath()
        ctx.arc(element.x, element.y, element.radius, 0, 2 * Math.PI)

        // Fill
        ctx.fillStyle = element.color
        ctx.fill()

        // Stroke based on state
        let strokeColorToUse = strokeColor
        let lineWidth = 1

        switch (element.state) {
          case "selected":
            strokeColorToUse = selectedColor
            lineWidth = 2
            break
          case "moveable":
            strokeColorToUse = moveableColor
            lineWidth = 3
            break
          default:
            strokeColorToUse = strokeColor
            lineWidth = 1
        }

        ctx.strokeStyle = strokeColorToUse
        ctx.lineWidth = lineWidth
        ctx.stroke()

        // Draw selection indicator
        if (element.state === "selected") {
          ctx.beginPath()
          ctx.arc(element.x, element.y, element.radius + 5, 0, 2 * Math.PI)
          ctx.strokeStyle = selectedColor
          ctx.lineWidth = 1
          ctx.setLineDash([5, 5])
          ctx.stroke()
          ctx.setLineDash([])
        }

        // Draw moveable indicator
        if (element.state === "moveable") {
          ctx.beginPath()
          ctx.arc(element.x, element.y, element.radius + 8, 0, 2 * Math.PI)
          ctx.strokeStyle = moveableColor
          ctx.lineWidth = 2
          ctx.setLineDash([3, 3])
          ctx.stroke()
          ctx.setLineDash([])
        }
      } else if (element.type === "text" && element.text) {
        // Draw text
        ctx.font = `${element.fontSize || fontSize}px Arial`
        ctx.textAlign = "center"
        ctx.textBaseline = "middle"
        ctx.fillStyle = element.color
        ctx.fillText(element.text, element.x, element.y)

        // Draw outline based on state
        let strokeColorToUse = strokeColor
        let lineWidth = 1

        switch (element.state) {
          case "selected":
            strokeColorToUse = selectedColor
            lineWidth = 2
            break
          case "moveable":
            strokeColorToUse = moveableColor
            lineWidth = 3
            break
          default:
            strokeColorToUse = strokeColor
            lineWidth = 1
        }

        if (element.state !== "default") {
          ctx.strokeStyle = strokeColorToUse
          ctx.lineWidth = lineWidth
          ctx.strokeText(element.text, element.x, element.y)
        }

        // Draw selection indicator for text
        if (element.state === "selected") {
          const dims = getTextDimensions(element.text, element.fontSize || fontSize)
          ctx.strokeStyle = selectedColor
          ctx.lineWidth = 1
          ctx.setLineDash([5, 5])
          ctx.strokeRect(
            element.x - dims.width / 2 - 5,
            element.y - dims.height / 2 - 5,
            dims.width + 10,
            dims.height + 10,
          )
          ctx.setLineDash([])
        }

        // Draw moveable indicator for text
        if (element.state === "moveable") {
          const dims = getTextDimensions(element.text, element.fontSize || fontSize)
          ctx.strokeStyle = moveableColor
          ctx.lineWidth = 2
          ctx.setLineDash([3, 3])
          ctx.strokeRect(
            element.x - dims.width / 2 - 8,
            element.y - dims.height / 2 - 8,
            dims.width + 16,
            dims.height + 16,
          )
          ctx.setLineDash([])
        }
      }
    })
  }, [
    elements,
    backgroundColor,
    physicsBackgroundColor,
    strokeColor,
    selectedColor,
    moveableColor,
    physicsActive,
    fontSize,
    getTextDimensions,
  ])

  // Handle mouse down
  const handleMouseDown = useCallback(
    (e: MouseEvent) => {
      e.preventDefault()
      handleMouseInteraction()

      const { x, y } = getCanvasCoordinates(e)
      const result = findElementAt(x, y)

      if (result) {
        const { element, index } = result
        // Make clicked element moveable
        setMoveableElementIndex(index)
        setSelectedElementIndex(-1)
        setPhysicsActive(false) // Stop physics when dragging

        setDragOffset({
          x: x - element.x,
          y: y - element.y,
        })
      } else {
        // Clear any moveable element when clicking outside
        setMoveableElementIndex(-1)
        setSelectedElementIndex(-1)

        // Start creating new circle
        const newElementId = generateId()
        const newElement: Element = {
          id: newElementId,
          x,
          y,
          radius: 5,
          color: circleColor,
          type: "circle",
          state: "default",
          vx: 0,
          vy: 0,
          mass: 1,
        }
        setElements((prev) => [...prev, newElement])
        setIsCreatingElement(true)
        setCreationStart({ x, y })
        setCreatingElementId(newElementId)
      }
    },
    [findElementAt, handleMouseInteraction, circleColor],
  )

  // Handle mouse move
  const handleMouseMove = useCallback(
    (e: MouseEvent) => {
      const { x, y } = getCanvasCoordinates(e)

      if (isCreatingElement && creationStart && creatingElementId) {
        // Update radius of circle being created
        const dragDistance = distance(creationStart.x, creationStart.y, x, y)
        const newRadius = Math.max(minRadius, Math.min(maxRadius, dragDistance))

        setElements((prev) =>
          prev.map((element) =>
            element.id === creatingElementId ? { ...element, radius: newRadius, mass: newRadius / 10 } : element,
          ),
        )
      } else if (moveableElementIndex >= 0 && e.buttons === 1) {
        // Handle dragging moveable element
        const canvas = canvasRef.current
        if (!canvas) return

        const moveableElement = getMoveableElement()
        if (moveableElement) {
          const newX = Math.max(
            moveableElement.radius,
            Math.min(canvas.width - moveableElement.radius, x - dragOffset.x),
          )
          const newY = Math.max(
            moveableElement.radius,
            Math.min(canvas.height - moveableElement.radius, y - dragOffset.y),
          )

          setElements((prev) =>
            prev.map((element, index) => (index === moveableElementIndex ? { ...element, x: newX, y: newY } : element)),
          )
        }
      } else {
        // Handle hover
        handleMouseInteraction()
        const result = findElementAt(x, y)
        setHoverElementId(result?.element.id || null)
      }
    },
    [
      moveableElementIndex,
      dragOffset,
      findElementAt,
      handleMouseInteraction,
      getMoveableElement,
      isCreatingElement,
      creationStart,
      creatingElementId,
      minRadius,
      maxRadius,
    ],
  )

  // Handle mouse up
  const handleMouseUp = useCallback(() => {
    if (isCreatingElement && creatingElementId) {
      // Finish creating element
      setIsCreatingElement(false)
      setCreationStart(null)
      setCreatingElementId(null)
    }
  }, [isCreatingElement, creatingElementId])

  // Handle touch start
  const handleTouchStart = useCallback(
    (e: TouchEvent) => {
      e.preventDefault()
      handleMouseInteraction()

      if (e.touches.length === 2) {
        // Two finger pinch
        const touch1 = e.touches[0]
        const touch2 = e.touches[1]
        const center = getTouchCenter(touch1, touch2)
        const result = findElementAt(center.x, center.y)

        if (result) {
          const { element, index } = result
          setIsPinching(true)
          setPinchStartDistance(getTouchDistance(touch1, touch2))
          setPinchStartRadius(element.radius)
          setPinchElementIndex(index)

          // Make the pinched element moveable
          setMoveableElementIndex(index)
          setSelectedElementIndex(-1)
          setPhysicsActive(false)
        }
      } else if (e.touches.length === 1) {
        // Single finger - treat like mouse
        const { x, y } = getCanvasCoordinates(e)
        const result = findElementAt(x, y)

        if (result) {
          const { element, index } = result
          setMoveableElementIndex(index)
          setSelectedElementIndex(-1)
          setPhysicsActive(false)

          setDragOffset({
            x: x - element.x,
            y: y - element.y,
          })
        } else {
          setMoveableElementIndex(-1)
          setSelectedElementIndex(-1)

          const newElementId = generateId()
          const newElement: Element = {
            id: newElementId,
            x,
            y,
            radius: 5,
            color: circleColor,
            type: "circle",
            state: "default",
            vx: 0,
            vy: 0,
            mass: 1,
          }
          setElements((prev) => [...prev, newElement])
          setIsCreatingElement(true)
          setCreationStart({ x, y })
          setCreatingElementId(newElementId)
        }
      }
    },
    [findElementAt, handleMouseInteraction, circleColor],
  )

  // Handle touch move
  const handleTouchMove = useCallback(
    (e: TouchEvent) => {
      e.preventDefault()

      if (isPinching && e.touches.length === 2 && pinchElementIndex >= 0) {
        // Handle pinch resize
        const touch1 = e.touches[0]
        const touch2 = e.touches[1]
        const currentDistance = getTouchDistance(touch1, touch2)
        const scale = currentDistance / pinchStartDistance
        const newRadius = Math.max(minRadius, Math.min(maxRadius, pinchStartRadius * scale))

        // Remember this radius for future use
        setLastUsedRadius(newRadius)

        setElements((prev) =>
          prev.map((element, index) =>
            index === pinchElementIndex ? { ...element, radius: newRadius, mass: newRadius / 10 } : element,
          ),
        )
      } else if (e.touches.length === 1) {
        // Single finger - treat like mouse move
        const { x, y } = getCanvasCoordinates(e)

        if (isCreatingElement && creationStart && creatingElementId) {
          const dragDistance = distance(creationStart.x, creationStart.y, x, y)
          const newRadius = Math.max(minRadius, Math.min(maxRadius, dragDistance))

          setElements((prev) =>
            prev.map((element) =>
              element.id === creatingElementId ? { ...element, radius: newRadius, mass: newRadius / 10 } : element,
            ),
          )
        } else if (moveableElementIndex >= 0) {
          const canvas = canvasRef.current
          if (!canvas) return

          const moveableElement = getMoveableElement()
          if (moveableElement) {
            const newX = Math.max(
              moveableElement.radius,
              Math.min(canvas.width - moveableElement.radius, x - dragOffset.x),
            )
            const newY = Math.max(
              moveableElement.radius,
              Math.min(canvas.height - moveableElement.radius, y - dragOffset.y),
            )

            setElements((prev) =>
              prev.map((element, index) =>
                index === moveableElementIndex ? { ...element, x: newX, y: newY } : element,
              ),
            )
          }
        }
      }
    },
    [
      isPinching,
      pinchElementIndex,
      pinchStartDistance,
      pinchStartRadius,
      minRadius,
      maxRadius,
      isCreatingElement,
      creationStart,
      creatingElementId,
      moveableElementIndex,
      dragOffset,
      getMoveableElement,
      lastUsedRadius,
    ],
  )

  // Handle touch end
  const handleTouchEnd = useCallback(
    (e: TouchEvent) => {
      e.preventDefault()

      if (isPinching) {
        setIsPinching(false)
        setPinchStartDistance(0)
        setPinchStartRadius(0)
        setPinchElementIndex(-1)
      }

      if (isCreatingElement && creatingElementId && e.touches.length === 0) {
        setIsCreatingElement(false)
        setCreationStart(null)
        setCreatingElementId(null)
      }
    },
    [isPinching, isCreatingElement, creatingElementId],
  )

  const handleContainerClick = useCallback(() => {
    if (containerRef.current) {
      containerRef.current.focus()
    }
  }, [])

  // Setup canvas and event listeners
  useEffect(() => {
    const canvas = canvasRef.current
    const container = containerRef.current
    if (!canvas || !container) return

    const resizeCanvas = () => {
      const rect = container.getBoundingClientRect()
      canvas.width = rect.width
      canvas.height = rect.height
      draw()
    }

    resizeCanvas()

    canvas.addEventListener("mousedown", handleMouseDown)
    canvas.addEventListener("mousemove", handleMouseMove)
    canvas.addEventListener("mouseup", handleMouseUp)
    canvas.addEventListener("touchstart", handleTouchStart, { passive: false })
    canvas.addEventListener("touchmove", handleTouchMove, { passive: false })
    canvas.addEventListener("touchend", handleTouchEnd, { passive: false })
    canvas.addEventListener("mouseleave", () => {
      setHoverElementId(null)
    })

    container.addEventListener("keydown", handleKeyDown)
    container.focus()

    window.addEventListener("resize", resizeCanvas)

    return () => {
      canvas.removeEventListener("mousedown", handleMouseDown)
      canvas.removeEventListener("mousemove", handleMouseMove)
      canvas.removeEventListener("mouseup", handleMouseUp)
      canvas.removeEventListener("touchstart", handleTouchStart)
      canvas.removeEventListener("touchmove", handleTouchMove)
      canvas.removeEventListener("touchend", handleTouchEnd)
      canvas.removeEventListener("mouseleave", () => {
        setHoverElementId(null)
      })
      container.removeEventListener("keydown", handleKeyDown)
      window.removeEventListener("resize", resizeCanvas)

      if (mouseInteractionTimeoutRef.current) {
        clearTimeout(mouseInteractionTimeoutRef.current)
      }
    }
  }, [
    handleMouseDown,
    handleMouseMove,
    handleMouseUp,
    handleTouchStart,
    handleTouchMove,
    handleTouchEnd,
    handleKeyDown,
    draw,
  ])

  // Redraw when elements change
  useEffect(() => {
    draw()
  }, [draw])

  return (
    <motion.div
      ref={containerRef}
      onClick={handleContainerClick}
      style={{
        ...style,
        width: "100%",
        height: "100%",
        minHeight: "400px",
        position: "relative",
        overflow: "hidden",
        outline: "none",
        cursor: "crosshair",
      }}
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ duration: 0.3 }}
      tabIndex={0}
    >
      <canvas
        ref={canvasRef}
        style={{
          display: "block",
          width: "100%",
          height: "100%",
          touchAction: "none",
        }}
      />

      {/* Instructions overlay */}
      {elements.length === 0 && (
        <div
          style={{
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            textAlign: "center",
            pointerEvents: "none",
            color: "#666",
            fontSize: "16px",
          }}
        >
          <div>Press numbers (1-9,0) to create circles or letters (a-z) for text</div>
          <div style={{ fontSize: "14px", marginTop: "8px" }}>
            Arrow keys to select • Space to toggle move • Enter for gravity • ESC to clear
          </div>
        </div>
      )}

      {/* Controls help */}
      <div
        style={{
          position: "absolute",
          top: "10px",
          left: "10px",
          background: "rgba(0,0,0,0.7)",
          color: "white",
          padding: "10px",
          borderRadius: "5px",
          fontSize: "12px",
          pointerEvents: "none",
          opacity: elements.length > 0 ? 1 : 0,
          transition: "opacity 0.3s",
        }}
      >
        <div>🎮 Controls:</div>
        <div>1-9,0 = Circles • A-Z = Letters • ↑↓←→ Select/Move • Space = Toggle Move</div>
        <div>Enter = Gravity • ESC = Clear • Click & Drag = Create/Move • Pinch = Resize</div>
        {selectedElementIndex >= 0 && keyboardMode && <div>📍 Selected: Element {selectedElementIndex + 1}</div>}
        {moveableElementIndex >= 0 && <div>🎯 Moving: Element {moveableElementIndex + 1}</div>}
        {physicsActive && <div>🌍 Gravity Active</div>}
      </div>
    </motion.div>
  )
}

// Property Controls
addPropertyControls(InteractiveCanvas, {
  backgroundColor: {
    type: ControlType.Color,
    title: "Background",
    defaultValue: "#f0f0f0",
  },
  physicsBackgroundColor: {
    type: ControlType.Color,
    title: "Physics Background",
    defaultValue: "#e8f4f8",
  },
  circleColor: {
    type: ControlType.Color,
    title: "Circle Color",
    defaultValue: "#3b82f6",
  },
  textColor: {
    type: ControlType.Color,
    title: "Text Color",
    defaultValue: "#2563eb",
  },
  selectedColor: {
    type: ControlType.Color,
    title: "Selected/Hover Color",
    defaultValue: "#ff00ff",
  },
  moveableColor: {
    type: ControlType.Color,
    title: "Moveable Color",
    defaultValue: "#ff0000",
  },
  strokeColor: {
    type: ControlType.Color,
    title: "Default Stroke Color",
    defaultValue: "#000000",
  },
  fontSize: {
    type: ControlType.Number,
    title: "Font Size",
    min: 16,
    max: 72,
    step: 4,
    unit: "px",
    defaultValue: 32,
  },
  movementSpeed: {
    type: ControlType.Number,
    title: "Movement Speed",
    min: 5,
    max: 50,
    step: 5,
    unit: "px",
    defaultValue: 15,
  },
  initialRadius: {
    type: ControlType.Number,
    title: "Initial Radius",
    min: 10,
    max: 200,
    step: 5,
    unit: "px",
    defaultValue: 40,
  },
  minRadius: {
    type: ControlType.Number,
    title: "Min Radius",
    min: 5,
    max: 100,
    step: 5,
    unit: "px",
    defaultValue: 20,
  },
  maxRadius: {
    type: ControlType.Number,
    title: "Max Radius",
    min: 50,
    max: 300,
    step: 10,
    unit: "px",
    defaultValue: 100,
  },
  gravity: {
    type: ControlType.Number,
    title: "Gravity",
    min: 0.1,
    max: 2,
    step: 0.1,
    defaultValue: 0.5,
  },
  friction: {
    type: ControlType.Number,
    title: "Friction",
    min: 0.9,
    max: 1,
    step: 0.01,
    defaultValue: 0.98,
  },
  bounciness: {
    type: ControlType.Number,
    title: "Bounciness",
    min: 0,
    max: 1,
    step: 0.1,
    defaultValue: 0.7,
  },
})
