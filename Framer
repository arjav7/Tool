"use client"

import { useEffect, useRef, useState, useCallback } from "react"
import { addPropertyControls, ControlType } from "framer"
import { motion } from "framer-motion"

interface Circle {
  id: string
  x: number
  y: number
  radius: number
  color: string
  state: "default" | "selected" | "moveable"
  // Physics properties
  vx: number
  vy: number
  mass: number
}

/**
 * @framerDisableUnlink
 * @framerSupportedLayoutWidth any
 * @framerSupportedLayoutHeight any
 * @framerIntrinsicWidth 800
 * @framerIntrinsicHeight 600
 */
export default function InteractiveCanvas(props) {
  const {
    backgroundColor = "#f0f0f0",
    physicsBackgroundColor = "#e8f4f8",
    circleColor = "#3b82f6",
    hoverColor = "#00ff00",
    selectedColor = "#ff00ff",
    moveableColor = "#ff0000",
    strokeColor = "#000000",
    minRadius = 20,
    maxRadius = 100,
    initialRadius = 40,
    movementSpeed = 15,
    gravity = 0.5,
    friction = 0.98,
    bounciness = 0.7,
    style,
  } = props

  const containerRef = useRef<HTMLDivElement>(null)
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const animationFrameRef = useRef<number>()
  const mouseInteractionTimeoutRef = useRef<NodeJS.Timeout>()

  const [circles, setCircles] = useState<Circle[]>([])
  const [selectedCircleIndex, setSelectedCircleIndex] = useState<number>(-1)
  const [moveableCircleIndex, setMoveableCircleIndex] = useState<number>(-1)
  const [hoverCircleId, setHoverCircleId] = useState<string | null>(null)
  const [keyboardMode, setKeyboardMode] = useState(false)
  const [dragOffset, setDragOffset] = useState<{ x: number; y: number }>({ x: 0, y: 0 })
  const [physicsActive, setPhysicsActive] = useState(false)
  const [isCreatingCircle, setIsCreatingCircle] = useState(false)
  const [creationStart, setCreationStart] = useState<{ x: number; y: number } | null>(null)
  const [creatingCircleId, setCreatingCircleId] = useState<string | null>(null)

  // Pinch gesture state
  const [isPinching, setIsPinching] = useState(false)
  const [pinchStartDistance, setPinchStartDistance] = useState(0)
  const [pinchStartRadius, setPinchStartRadius] = useState(0)
  const [pinchCircleIndex, setPinchCircleIndex] = useState(-1)

  const [isClearing, setIsClearing] = useState(false)
  const [wasPhysicsActiveBeforeClearing, setWasPhysicsActiveBeforeClearing] = useState(false)
  const [lastUsedRadius, setLastUsedRadius] = useState(initialRadius)

  // Generate unique ID for circles
  const generateId = () => Math.random().toString(36).substr(2, 9)

  // Calculate distance between two points
  const distance = (x1: number, y1: number, x2: number, y2: number) => {
    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
  }

  // Calculate distance between two touch points
  const getTouchDistance = (touch1: Touch, touch2: Touch) => {
    const dx = touch2.clientX - touch1.clientX
    const dy = touch2.clientY - touch1.clientY
    return Math.sqrt(dx * dx + dy * dy)
  }

  // Get center point between two touches
  const getTouchCenter = (touch1: Touch, touch2: Touch) => {
    const rect = canvasRef.current?.getBoundingClientRect()
    if (!rect) return { x: 0, y: 0 }

    return {
      x: (touch1.clientX + touch2.clientX) / 2 - rect.left,
      y: (touch1.clientY + touch2.clientY) / 2 - rect.top,
    }
  }

  // Find circle at position
  const findCircleAt = useCallback(
    (x: number, y: number): { circle: Circle; index: number } | null => {
      for (let i = circles.length - 1; i >= 0; i--) {
        const circle = circles[i]
        if (distance(x, y, circle.x, circle.y) <= circle.radius) {
          return { circle, index: i }
        }
      }
      return null
    },
    [circles],
  )

  // Find the most empty area on canvas
  const findMostEmptyArea = useCallback(() => {
    const canvas = canvasRef.current
    if (!canvas) return { x: canvas?.width / 2 || 400, y: canvas?.height / 2 || 300 }

    const gridSize = 50
    const cols = Math.ceil(canvas.width / gridSize)
    const rows = Math.ceil(canvas.height / gridSize)

    let bestScore = Number.POSITIVE_INFINITY
    let bestX = canvas.width / 2
    let bestY = canvas.height / 2

    // Check each grid cell
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const centerX = (col + 0.5) * gridSize
        const centerY = (row + 0.5) * gridSize

        // Skip if too close to edges
        if (
          centerX < initialRadius ||
          centerX > canvas.width - initialRadius ||
          centerY < initialRadius ||
          centerY > canvas.height - initialRadius
        ) {
          continue
        }

        // Count overlapping circles
        let score = 0
        circles.forEach((circle) => {
          const dist = distance(centerX, centerY, circle.x, circle.y)
          if (dist < circle.radius + initialRadius + 20) {
            score += circle.radius + initialRadius + 20 - dist
          }
        })

        if (score < bestScore) {
          bestScore = score
          bestX = centerX
          bestY = centerY
        }
      }
    }

    return { x: bestX, y: bestY }
  }, [circles, initialRadius])

  // Get canvas coordinates from event
  const getCanvasCoordinates = (e: MouseEvent | TouchEvent) => {
    const rect = canvasRef.current?.getBoundingClientRect()
    if (!rect) return { x: 0, y: 0 }

    let clientX, clientY
    if (e instanceof MouseEvent) {
      clientX = e.clientX
      clientY = e.clientY
    } else {
      clientX = e.touches[0]?.clientX || e.changedTouches[0]?.clientX || 0
      clientY = e.touches[0]?.clientY || e.changedTouches[0]?.clientY || 0
    }

    return {
      x: clientX - rect.left,
      y: clientY - rect.top,
    }
  }

  // Get selected circle
  const getSelectedCircle = useCallback(() => {
    if (selectedCircleIndex >= 0 && selectedCircleIndex < circles.length) {
      return circles[selectedCircleIndex]
    }
    return null
  }, [circles, selectedCircleIndex])

  // Get moveable circle
  const getMoveableCircle = useCallback(() => {
    if (moveableCircleIndex >= 0 && moveableCircleIndex < circles.length) {
      return circles[moveableCircleIndex]
    }
    return null
  }, [circles, moveableCircleIndex])

  // Find nearest circle in a direction
  const findNearestCircleInDirection = useCallback(
    (direction: "left" | "right" | "up" | "down") => {
      const currentCircle = getSelectedCircle()
      if (circles.length <= 1) return -1

      if (!currentCircle) {
        return 0
      }

      const candidates: Array<{
        index: number
        distance: number
        alignmentScore: number
      }> = []

      circles.forEach((circle, index) => {
        if (circle.id === currentCircle.id) return

        const dx = circle.x - currentCircle.x
        const dy = circle.y - currentCircle.y
        const distance = Math.sqrt(dx * dx + dy * dy)

        if (distance < 5) return

        let isInDirection = false
        let alignmentScore = 0

        switch (direction) {
          case "right":
            isInDirection = dx > 0
            alignmentScore = Math.abs(dy)
            break
          case "left":
            isInDirection = dx < 0
            alignmentScore = Math.abs(dy)
            break
          case "down":
            isInDirection = dy > 0
            alignmentScore = Math.abs(dx)
            break
          case "up":
            isInDirection = dy < 0
            alignmentScore = Math.abs(dx)
            break
        }

        if (isInDirection) {
          candidates.push({
            index,
            distance,
            alignmentScore,
          })
        }
      })

      if (candidates.length === 0) return -1

      candidates.sort((a, b) => {
        const alignmentDiff = a.alignmentScore - b.alignmentScore
        if (Math.abs(alignmentDiff) > 20) {
          return alignmentDiff
        }
        return a.distance - b.distance
      })

      return candidates[0].index
    },
    [circles, getSelectedCircle],
  )

  // Clear selection when switching to mouse mode
  const handleMouseInteraction = useCallback(() => {
    if (keyboardMode) {
      setKeyboardMode(false)
      if (mouseInteractionTimeoutRef.current) {
        clearTimeout(mouseInteractionTimeoutRef.current)
      }
      mouseInteractionTimeoutRef.current = setTimeout(() => {
        setSelectedCircleIndex(-1)
      }, 100)
    }
  }, [keyboardMode])

  // Physics simulation
  const updatePhysics = useCallback(() => {
    const canvas = canvasRef.current
    if (!canvas || !physicsActive) return

    setCircles((prevCircles) => {
      const newCircles = [...prevCircles]
      let hasMovement = false

      // Apply gravity and update positions
      for (let i = 0; i < newCircles.length; i++) {
        const circle = newCircles[i]

        // Skip physics for moveable circles
        if (circle.state === "moveable") continue

        // Apply gravity
        circle.vy += gravity

        // Apply friction
        circle.vx *= friction
        circle.vy *= friction

        // Update position
        circle.x += circle.vx
        circle.y += circle.vy

        // Check boundaries
        if (circle.y + circle.radius > canvas.height) {
          if (isClearing) {
            // During clearing, let circles fall through the floor
            continue
          } else {
            circle.y = canvas.height - circle.radius
            circle.vy *= -bounciness
            if (Math.abs(circle.vy) < 0.5) circle.vy = 0
          }
        }

        if (circle.x - circle.radius < 0) {
          circle.x = circle.radius
          circle.vx *= -bounciness
        }
        if (circle.x + circle.radius > canvas.width) {
          circle.x = canvas.width - circle.radius
          circle.vx *= -bounciness
        }

        if (Math.abs(circle.vx) > 0.1 || Math.abs(circle.vy) > 0.1) {
          hasMovement = true
        }
      }

      // Circle-to-circle collisions
      for (let i = 0; i < newCircles.length; i++) {
        for (let j = i + 1; j < newCircles.length; j++) {
          const circle1 = newCircles[i]
          const circle2 = newCircles[j]

          // Skip collisions if either circle is moveable
          if (circle1.state === "moveable" || circle2.state === "moveable") continue

          const dx = circle2.x - circle1.x
          const dy = circle2.y - circle1.y
          const dist = Math.sqrt(dx * dx + dy * dy)
          const minDist = circle1.radius + circle2.radius

          if (dist < minDist) {
            hasMovement = true

            const nx = dx / dist
            const ny = dy / dist

            const overlap = minDist - dist
            const separationX = (overlap * nx) / 2
            const separationY = (overlap * ny) / 2

            circle1.x -= separationX
            circle1.y -= separationY
            circle2.x += separationX
            circle2.y += separationY

            const dvx = circle2.vx - circle1.vx
            const dvy = circle2.vy - circle1.vy
            const dvn = dvx * nx + dvy * ny

            if (dvn > 0) continue

            const impulse = (2 * dvn) / (circle1.mass + circle2.mass)

            circle1.vx += impulse * circle2.mass * nx * bounciness
            circle1.vy += impulse * circle2.mass * ny * bounciness
            circle2.vx -= impulse * circle1.mass * nx * bounciness
            circle2.vy -= impulse * circle1.mass * ny * bounciness
          }
        }
      }

      // Stop physics if no movement
      if (!hasMovement) {
        setTimeout(() => setPhysicsActive(false), 100)
      }

      return newCircles
    })
  }, [physicsActive, gravity, friction, bounciness, isClearing])

  // Physics animation loop
  useEffect(() => {
    if (physicsActive) {
      const animate = () => {
        updatePhysics()
        animationFrameRef.current = requestAnimationFrame(animate)
      }
      animationFrameRef.current = requestAnimationFrame(animate)
    } else {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
      }
    }

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
      }
    }
  }, [physicsActive, updatePhysics])

  // Check if clearing is complete
  useEffect(() => {
    if (isClearing && circles.length > 0) {
      const canvas = canvasRef.current
      if (!canvas) return

      const allCirclesFallen = circles.every((circle) => circle.y - circle.radius > canvas.height)

      if (allCirclesFallen) {
        // All circles have fallen off screen
        setCircles([])
        setIsClearing(false)
        setSelectedCircleIndex(-1)
        setMoveableCircleIndex(-1)
        setHoverCircleId(null)

        // Restore physics state
        if (!wasPhysicsActiveBeforeClearing) {
          setPhysicsActive(false)
        }
      }
    }
  }, [circles, isClearing, wasPhysicsActiveBeforeClearing])

  // Handle keyboard events
  const handleKeyDown = useCallback(
    (e: KeyboardEvent) => {
      const canvas = canvasRef.current
      if (!canvas) return

      setKeyboardMode(true)
      if (mouseInteractionTimeoutRef.current) {
        clearTimeout(mouseInteractionTimeoutRef.current)
      }

      const moveableCircle = getMoveableCircle()

      switch (e.key) {
        case "ArrowUp":
          e.preventDefault()
          if (moveableCircle) {
            setCircles((prev) =>
              prev.map((circle, index) =>
                index === moveableCircleIndex
                  ? { ...circle, y: Math.max(circle.radius, circle.y - movementSpeed) }
                  : circle,
              ),
            )
          } else {
            if (circles.length > 0) {
              const nearestIndex = findNearestCircleInDirection("up")
              if (nearestIndex >= 0) {
                setSelectedCircleIndex(nearestIndex)
              } else if (selectedCircleIndex < 0) {
                setSelectedCircleIndex(0)
              }
            }
          }
          break

        case "ArrowDown":
          e.preventDefault()
          if (moveableCircle) {
            setCircles((prev) =>
              prev.map((circle, index) =>
                index === moveableCircleIndex
                  ? { ...circle, y: Math.min(canvas.height - circle.radius, circle.y + movementSpeed) }
                  : circle,
              ),
            )
          } else {
            if (circles.length > 0) {
              const nearestIndex = findNearestCircleInDirection("down")
              if (nearestIndex >= 0) {
                setSelectedCircleIndex(nearestIndex)
              } else if (selectedCircleIndex < 0) {
                setSelectedCircleIndex(0)
              }
            }
          }
          break

        case "ArrowLeft":
          e.preventDefault()
          if (moveableCircle) {
            setCircles((prev) =>
              prev.map((circle, index) =>
                index === moveableCircleIndex
                  ? { ...circle, x: Math.max(circle.radius, circle.x - movementSpeed) }
                  : circle,
              ),
            )
          } else {
            if (circles.length > 0) {
              const nearestIndex = findNearestCircleInDirection("left")
              if (nearestIndex >= 0) {
                setSelectedCircleIndex(nearestIndex)
              } else if (selectedCircleIndex < 0) {
                setSelectedCircleIndex(0)
              }
            }
          }
          break

        case "ArrowRight":
          e.preventDefault()
          if (moveableCircle) {
            setCircles((prev) =>
              prev.map((circle, index) =>
                index === moveableCircleIndex
                  ? { ...circle, x: Math.min(canvas.width - circle.radius, circle.x + movementSpeed) }
                  : circle,
              ),
            )
          } else {
            if (circles.length > 0) {
              const nearestIndex = findNearestCircleInDirection("right")
              if (nearestIndex >= 0) {
                setSelectedCircleIndex(nearestIndex)
              } else if (selectedCircleIndex < 0) {
                setSelectedCircleIndex(0)
              }
            }
          }
          break

        case " ": // Space key - toggle moveable state
          e.preventDefault()
          if (moveableCircleIndex >= 0) {
            // Stop moving
            setMoveableCircleIndex(-1)
          } else if (selectedCircleIndex >= 0) {
            // Start moving
            setMoveableCircleIndex(selectedCircleIndex)
            setSelectedCircleIndex(-1)
          }
          break

        case "Enter":
        case "Return": // Enter key - toggle gravity
          e.preventDefault()
          if (circles.length > 0) {
            if (physicsActive) {
              setPhysicsActive(false)
            } else {
              // Reset physics properties and start gravity
              setCircles((prev) =>
                prev.map((circle) => ({
                  ...circle,
                  vx: (Math.random() - 0.5) * 2,
                  vy: Math.random() * -2,
                  mass: circle.radius / 10,
                })),
              )
              setPhysicsActive(true)
            }
          }
          break

        case "n":
        case "N": // N key - create new object
          e.preventDefault()
          const emptyArea = findMostEmptyArea()
          const newCircleId = generateId()
          const newCircle: Circle = {
            id: newCircleId,
            x: emptyArea.x,
            y: emptyArea.y,
            radius: lastUsedRadius,
            color: circleColor,
            state: "moveable",
            vx: 0,
            vy: 0,
            mass: lastUsedRadius / 10,
          }
          setCircles((prev) => [...prev, newCircle])
          setMoveableCircleIndex(circles.length)
          setSelectedCircleIndex(-1)
          break

        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
        case "0":
          e.preventDefault()
          const targetCircle = getMoveableCircle() || getSelectedCircle()
          if (targetCircle) {
            const numberValue = e.key === "0" ? 10 : Number.parseInt(e.key)
            const newRadius = Math.max(
              minRadius,
              Math.min(maxRadius, minRadius + (numberValue - 1) * ((maxRadius - minRadius) / 9)),
            )

            // Remember this radius for future use
            setLastUsedRadius(newRadius)

            const targetIndex = moveableCircleIndex >= 0 ? moveableCircleIndex : selectedCircleIndex
            setCircles((prev) =>
              prev.map((circle, index) =>
                index === targetIndex ? { ...circle, radius: newRadius, mass: newRadius / 10 } : circle,
              ),
            )
          }
          break

        case "Escape":
          e.preventDefault()
          if (circles.length > 0) {
            // Start clearing process
            setIsClearing(true)
            setWasPhysicsActiveBeforeClearing(physicsActive)

            if (!physicsActive) {
              // Turn on physics if it wasn't already on
              setCircles((prev) =>
                prev.map((circle) => ({
                  ...circle,
                  vx: (Math.random() - 0.5) * 2,
                  vy: Math.random() * -2,
                  mass: circle.radius / 10,
                })),
              )
              setPhysicsActive(true)
            }

            // Clear any selected/moveable states
            setSelectedCircleIndex(-1)
            setMoveableCircleIndex(-1)
          }
          break

        default:
          break
      }
    },
    [
      circles,
      selectedCircleIndex,
      moveableCircleIndex,
      movementSpeed,
      initialRadius,
      circleColor,
      minRadius,
      maxRadius,
      physicsActive,
      getSelectedCircle,
      getMoveableCircle,
      findNearestCircleInDirection,
      findMostEmptyArea,
      lastUsedRadius,
      physicsActive,
    ],
  )

  // Update circle states
  useEffect(() => {
    setCircles((prev) =>
      prev.map((circle, index) => {
        let state: Circle["state"] = "default"

        if (index === moveableCircleIndex) {
          state = "moveable"
        } else if (index === selectedCircleIndex && keyboardMode) {
          state = "selected"
        } else if (circle.id === hoverCircleId && !keyboardMode) {
          state = "selected"
        }

        return { ...circle, state }
      }),
    )
  }, [selectedCircleIndex, moveableCircleIndex, hoverCircleId, keyboardMode])

  // Drawing function
  const draw = useCallback(() => {
    const canvas = canvasRef.current
    if (!canvas) return

    const ctx = canvas.getContext("2d")
    if (!ctx) return

    // Clear canvas with dynamic background
    ctx.fillStyle = physicsActive ? physicsBackgroundColor : backgroundColor
    ctx.fillRect(0, 0, canvas.width, canvas.height)

    // Draw circles
    circles.forEach((circle) => {
      ctx.beginPath()
      ctx.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI)

      // Fill
      ctx.fillStyle = circle.color
      ctx.fill()

      // Stroke based on state
      let strokeColorToUse = strokeColor
      let lineWidth = 1

      switch (circle.state) {
        case "selected":
          strokeColorToUse = selectedColor
          lineWidth = 2
          break
        case "moveable":
          strokeColorToUse = moveableColor
          lineWidth = 3
          break
        default:
          strokeColorToUse = strokeColor
          lineWidth = 1
      }

      ctx.strokeStyle = strokeColorToUse
      ctx.lineWidth = lineWidth
      ctx.stroke()

      // Draw selection indicator
      if (circle.state === "selected") {
        ctx.beginPath()
        ctx.arc(circle.x, circle.y, circle.radius + 5, 0, 2 * Math.PI)
        ctx.strokeStyle = selectedColor
        ctx.lineWidth = 1
        ctx.setLineDash([5, 5])
        ctx.stroke()
        ctx.setLineDash([])
      }

      // Draw moveable indicator
      if (circle.state === "moveable") {
        ctx.beginPath()
        ctx.arc(circle.x, circle.y, circle.radius + 8, 0, 2 * Math.PI)
        ctx.strokeStyle = moveableColor
        ctx.lineWidth = 2
        ctx.setLineDash([3, 3])
        ctx.stroke()
        ctx.setLineDash([])
      }
    })
  }, [circles, backgroundColor, physicsBackgroundColor, strokeColor, selectedColor, moveableColor, physicsActive])

  // Handle mouse down
  const handleMouseDown = useCallback(
    (e: MouseEvent) => {
      e.preventDefault()
      handleMouseInteraction()

      const { x, y } = getCanvasCoordinates(e)
      const result = findCircleAt(x, y)

      if (result) {
        const { circle, index } = result
        // Make clicked circle moveable
        setMoveableCircleIndex(index)
        setSelectedCircleIndex(-1)
        setPhysicsActive(false) // Stop physics when dragging

        setDragOffset({
          x: x - circle.x,
          y: y - circle.y,
        })
      } else {
        // Clear any moveable circle when clicking outside
        setMoveableCircleIndex(-1)
        setSelectedCircleIndex(-1)

        // Start creating new circle
        const newCircleId = generateId()
        const newCircle: Circle = {
          id: newCircleId,
          x,
          y,
          radius: 5,
          color: circleColor,
          state: "default",
          vx: 0,
          vy: 0,
          mass: 1,
        }
        setCircles((prev) => [...prev, newCircle])
        setIsCreatingCircle(true)
        setCreationStart({ x, y })
        setCreatingCircleId(newCircleId)
      }
    },
    [findCircleAt, handleMouseInteraction, circleColor],
  )

  // Handle mouse move
  const handleMouseMove = useCallback(
    (e: MouseEvent) => {
      const { x, y } = getCanvasCoordinates(e)

      if (isCreatingCircle && creationStart && creatingCircleId) {
        // Update radius of circle being created
        const dragDistance = distance(creationStart.x, creationStart.y, x, y)
        const newRadius = Math.max(minRadius, Math.min(maxRadius, dragDistance))

        setCircles((prev) =>
          prev.map((circle) =>
            circle.id === creatingCircleId ? { ...circle, radius: newRadius, mass: newRadius / 10 } : circle,
          ),
        )
      } else if (moveableCircleIndex >= 0 && e.buttons === 1) {
        // Handle dragging moveable circle
        const canvas = canvasRef.current
        if (!canvas) return

        const moveableCircle = getMoveableCircle()
        if (moveableCircle) {
          const newX = Math.max(moveableCircle.radius, Math.min(canvas.width - moveableCircle.radius, x - dragOffset.x))
          const newY = Math.max(
            moveableCircle.radius,
            Math.min(canvas.height - moveableCircle.radius, y - dragOffset.y),
          )

          setCircles((prev) =>
            prev.map((circle, index) => (index === moveableCircleIndex ? { ...circle, x: newX, y: newY } : circle)),
          )
        }
      } else {
        // Handle hover
        handleMouseInteraction()
        const result = findCircleAt(x, y)
        setHoverCircleId(result?.circle.id || null)
      }
    },
    [
      moveableCircleIndex,
      dragOffset,
      findCircleAt,
      handleMouseInteraction,
      getMoveableCircle,
      isCreatingCircle,
      creationStart,
      creatingCircleId,
      minRadius,
      maxRadius,
    ],
  )

  // Handle mouse up
  const handleMouseUp = useCallback(() => {
    if (isCreatingCircle && creatingCircleId) {
      // Finish creating circle
      setIsCreatingCircle(false)
      setCreationStart(null)
      setCreatingCircleId(null)
    }
  }, [isCreatingCircle, creatingCircleId])

  // Handle touch start
  const handleTouchStart = useCallback(
    (e: TouchEvent) => {
      e.preventDefault()
      handleMouseInteraction()

      if (e.touches.length === 2) {
        // Two finger pinch
        const touch1 = e.touches[0]
        const touch2 = e.touches[1]
        const center = getTouchCenter(touch1, touch2)
        const result = findCircleAt(center.x, center.y)

        if (result) {
          const { circle, index } = result
          setIsPinching(true)
          setPinchStartDistance(getTouchDistance(touch1, touch2))
          setPinchStartRadius(circle.radius)
          setPinchCircleIndex(index)

          // Make the pinched circle moveable
          setMoveableCircleIndex(index)
          setSelectedCircleIndex(-1)
          setPhysicsActive(false)
        }
      } else if (e.touches.length === 1) {
        // Single finger - treat like mouse
        const { x, y } = getCanvasCoordinates(e)
        const result = findCircleAt(x, y)

        if (result) {
          const { circle, index } = result
          setMoveableCircleIndex(index)
          setSelectedCircleIndex(-1)
          setPhysicsActive(false)

          setDragOffset({
            x: x - circle.x,
            y: y - circle.y,
          })
        } else {
          setMoveableCircleIndex(-1)
          setSelectedCircleIndex(-1)

          const newCircleId = generateId()
          const newCircle: Circle = {
            id: newCircleId,
            x,
            y,
            radius: 5,
            color: circleColor,
            state: "default",
            vx: 0,
            vy: 0,
            mass: 1,
          }
          setCircles((prev) => [...prev, newCircle])
          setIsCreatingCircle(true)
          setCreationStart({ x, y })
          setCreatingCircleId(newCircleId)
        }
      }
    },
    [findCircleAt, handleMouseInteraction, circleColor],
  )

  // Handle touch move
  const handleTouchMove = useCallback(
    (e: TouchEvent) => {
      e.preventDefault()

      if (isPinching && e.touches.length === 2 && pinchCircleIndex >= 0) {
        // Handle pinch resize
        const touch1 = e.touches[0]
        const touch2 = e.touches[1]
        const currentDistance = getTouchDistance(touch1, touch2)
        const scale = currentDistance / pinchStartDistance
        const newRadius = Math.max(minRadius, Math.min(maxRadius, pinchStartRadius * scale))

        // Remember this radius for future use
        setLastUsedRadius(newRadius)

        setCircles((prev) =>
          prev.map((circle, index) =>
            index === pinchCircleIndex ? { ...circle, radius: newRadius, mass: newRadius / 10 } : circle,
          ),
        )
      } else if (e.touches.length === 1) {
        // Single finger - treat like mouse move
        const { x, y } = getCanvasCoordinates(e)

        if (isCreatingCircle && creationStart && creatingCircleId) {
          const dragDistance = distance(creationStart.x, creationStart.y, x, y)
          const newRadius = Math.max(minRadius, Math.min(maxRadius, dragDistance))

          setCircles((prev) =>
            prev.map((circle) =>
              circle.id === creatingCircleId ? { ...circle, radius: newRadius, mass: newRadius / 10 } : circle,
            ),
          )
        } else if (moveableCircleIndex >= 0) {
          const canvas = canvasRef.current
          if (!canvas) return

          const moveableCircle = getMoveableCircle()
          if (moveableCircle) {
            const newX = Math.max(
              moveableCircle.radius,
              Math.min(canvas.width - moveableCircle.radius, x - dragOffset.x),
            )
            const newY = Math.max(
              moveableCircle.radius,
              Math.min(canvas.height - moveableCircle.radius, y - dragOffset.y),
            )

            setCircles((prev) =>
              prev.map((circle, index) => (index === moveableCircleIndex ? { ...circle, x: newX, y: newY } : circle)),
            )
          }
        }
      }
    },
    [
      isPinching,
      pinchCircleIndex,
      pinchStartDistance,
      pinchStartRadius,
      minRadius,
      maxRadius,
      isCreatingCircle,
      creationStart,
      creatingCircleId,
      moveableCircleIndex,
      dragOffset,
      getMoveableCircle,
      lastUsedRadius,
    ],
  )

  // Handle touch end
  const handleTouchEnd = useCallback(
    (e: TouchEvent) => {
      e.preventDefault()

      if (isPinching) {
        setIsPinching(false)
        setPinchStartDistance(0)
        setPinchStartRadius(0)
        setPinchCircleIndex(-1)
      }

      if (isCreatingCircle && creatingCircleId && e.touches.length === 0) {
        setIsCreatingCircle(false)
        setCreationStart(null)
        setCreatingCircleId(null)
      }
    },
    [isPinching, isCreatingCircle, creatingCircleId],
  )

  const handleContainerClick = useCallback(() => {
    if (containerRef.current) {
      containerRef.current.focus()
    }
  }, [])

  // Setup canvas and event listeners
  useEffect(() => {
    const canvas = canvasRef.current
    const container = containerRef.current
    if (!canvas || !container) return

    const resizeCanvas = () => {
      const rect = container.getBoundingClientRect()
      canvas.width = rect.width
      canvas.height = rect.height
      draw()
    }

    resizeCanvas()

    canvas.addEventListener("mousedown", handleMouseDown)
    canvas.addEventListener("mousemove", handleMouseMove)
    canvas.addEventListener("mouseup", handleMouseUp)
    canvas.addEventListener("touchstart", handleTouchStart, { passive: false })
    canvas.addEventListener("touchmove", handleTouchMove, { passive: false })
    canvas.addEventListener("touchend", handleTouchEnd, { passive: false })
    canvas.addEventListener("mouseleave", () => {
      setHoverCircleId(null)
    })

    container.addEventListener("keydown", handleKeyDown)
    container.focus()

    window.addEventListener("resize", resizeCanvas)

    return () => {
      canvas.removeEventListener("mousedown", handleMouseDown)
      canvas.removeEventListener("mousemove", handleMouseMove)
      canvas.removeEventListener("mouseup", handleMouseUp)
      canvas.removeEventListener("touchstart", handleTouchStart)
      canvas.removeEventListener("touchmove", handleTouchMove)
      canvas.removeEventListener("touchend", handleTouchEnd)
      canvas.removeEventListener("mouseleave", () => {
        setHoverCircleId(null)
      })
      container.removeEventListener("keydown", handleKeyDown)
      window.removeEventListener("resize", resizeCanvas)

      if (mouseInteractionTimeoutRef.current) {
        clearTimeout(mouseInteractionTimeoutRef.current)
      }
    }
  }, [
    handleMouseDown,
    handleMouseMove,
    handleMouseUp,
    handleTouchStart,
    handleTouchMove,
    handleTouchEnd,
    handleKeyDown,
    draw,
  ])

  // Redraw when circles change
  useEffect(() => {
    draw()
  }, [draw])

  return (
    <motion.div
      ref={containerRef}
      onClick={handleContainerClick}
      style={{
        ...style,
        width: "100%",
        height: "100%",
        minHeight: "400px",
        position: "relative",
        overflow: "hidden",
        outline: "none",
        cursor: "crosshair",
      }}
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ duration: 0.3 }}
      tabIndex={0}
    >
      <canvas
        ref={canvasRef}
        style={{
          display: "block",
          width: "100%",
          height: "100%",
          touchAction: "none",
        }}
      />

      {/* Instructions overlay */}
      {circles.length === 0 && (
        <div
          style={{
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            textAlign: "center",
            pointerEvents: "none",
            color: "#666",
            fontSize: "16px",
          }}
        >
          <div>Press 'N' to create a new circle or click and drag</div>
          <div style={{ fontSize: "14px", marginTop: "8px" }}>
            Arrow keys to select • Space to toggle move • Enter for gravity • Numbers to resize
          </div>
        </div>
      )}

      {/* Controls help */}
      <div
        style={{
          position: "absolute",
          top: "10px",
          left: "10px",
          background: "rgba(0,0,0,0.7)",
          color: "white",
          padding: "10px",
          borderRadius: "5px",
          fontSize: "12px",
          pointerEvents: "none",
          opacity: circles.length > 0 ? 1 : 0,
          transition: "opacity 0.3s",
        }}
      >
        <div>🎮 Controls:</div>
        <div>N = New • ↑↓←→ Select/Move • Space = Toggle Move • Enter = Gravity • ESC = Clear</div>
        <div>1-9,0 = Resize • Click & Drag = Create/Move • Pinch = Resize</div>
        {selectedCircleIndex >= 0 && keyboardMode && <div>📍 Selected: Circle {selectedCircleIndex + 1}</div>}
        {moveableCircleIndex >= 0 && <div>🎯 Moving: Circle {moveableCircleIndex + 1}</div>}
        {physicsActive && <div>🌍 Gravity Active</div>}
      </div>
    </motion.div>
  )
}

// Property Controls
addPropertyControls(InteractiveCanvas, {
  backgroundColor: {
    type: ControlType.Color,
    title: "Background",
    defaultValue: "#f0f0f0",
  },
  physicsBackgroundColor: {
    type: ControlType.Color,
    title: "Physics Background",
    defaultValue: "#e8f4f8",
  },
  circleColor: {
    type: ControlType.Color,
    title: "Circle Color",
    defaultValue: "#3b82f6",
  },
  selectedColor: {
    type: ControlType.Color,
    title: "Selected/Hover Color",
    defaultValue: "#ff00ff",
  },
  moveableColor: {
    type: ControlType.Color,
    title: "Moveable Color",
    defaultValue: "#ff0000",
  },
  strokeColor: {
    type: ControlType.Color,
    title: "Default Stroke Color",
    defaultValue: "#000000",
  },
  movementSpeed: {
    type: ControlType.Number,
    title: "Movement Speed",
    min: 5,
    max: 50,
    step: 5,
    unit: "px",
    defaultValue: 15,
  },
  initialRadius: {
    type: ControlType.Number,
    title: "Initial Radius",
    min: 10,
    max: 200,
    step: 5,
    unit: "px",
    defaultValue: 40,
  },
  minRadius: {
    type: ControlType.Number,
    title: "Min Radius",
    min: 5,
    max: 100,
    step: 5,
    unit: "px",
    defaultValue: 20,
  },
  maxRadius: {
    type: ControlType.Number,
    title: "Max Radius",
    min: 50,
    max: 300,
    step: 10,
    unit: "px",
    defaultValue: 100,
  },
  gravity: {
    type: ControlType.Number,
    title: "Gravity",
    min: 0.1,
    max: 2,
    step: 0.1,
    defaultValue: 0.5,
  },
  friction: {
    type: ControlType.Number,
    title: "Friction",
    min: 0.9,
    max: 1,
    step: 0.01,
    defaultValue: 0.98,
  },
  bounciness: {
    type: ControlType.Number,
    title: "Bounciness",
    min: 0,
    max: 1,
    step: 0.1,
    defaultValue: 0.7,
  },
})
